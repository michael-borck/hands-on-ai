{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ChatCraft!","text":"<p>ChatCraft makes AI accessible for classrooms by providing fun and friendly chatbot personalities that educators and students can interact with in pure Python.</p> <ul> <li>No API keys</li> <li>No setup headaches</li> <li>Works offline with Ollama</li> </ul> <p>Explore how it works, view the bot gallery, or try one of our mini-projects!</p>"},{"location":"bot-gallery/","title":"\ud83e\udd16 ChatCraft Bot Gallery","text":"<p>This gallery lists all available personality bots in ChatCraft. Each bot can be called with a prompt and will respond in its own unique style.</p> <p>Below you'll find each bot's name and its docstring, which includes usage examples, educational applications, and example responses (as written in the docstring).</p>"},{"location":"bot-gallery/#clarifying-concepts","title":"\ud83c\udff7\ufe0f Clarifying concepts","text":""},{"location":"bot-gallery/#teacher_bot","title":"<code>teacher_bot</code>","text":"<p>Generate structured explanations like a calm teacher.</p> <p>Educational Uses: - Step-by-step tutorials - Clarifying concepts</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A clear, instructional explanation</p>"},{"location":"bot-gallery/#code-literacy-and-syntax-help","title":"\ud83c\udff7\ufe0f Code literacy and syntax help","text":""},{"location":"bot-gallery/#coder_bot","title":"<code>coder_bot</code>","text":"<p>Give programming help with code examples and explanations.</p> <p>Educational Uses: - Debugging and code reviews - Code literacy and syntax help</p> <p>Args:     prompt (str): A programming question or code snippet</p> <p>Returns:     str: A code-focused AI response</p>"},{"location":"bot-gallery/#confidence-building","title":"\ud83c\udff7\ufe0f Confidence building","text":""},{"location":"bot-gallery/#coach_bot","title":"<code>coach_bot</code>","text":"<p>Motivate and encourage like a personal coach.</p> <p>Educational Uses: - Confidence building - Encouraging self-direction</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A motivational response</p>"},{"location":"bot-gallery/#creative-writing","title":"\ud83c\udff7\ufe0f Creative writing","text":""},{"location":"bot-gallery/#pirate_bot","title":"<code>pirate_bot</code>","text":"<p>Respond like a witty pirate using nautical slang and playful tone.</p> <p>Educational Uses: - Creative writing - Reframing problem-solving</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A response in pirate speak</p>"},{"location":"bot-gallery/#critical-thinking-prompts","title":"\ud83c\udff7\ufe0f Critical thinking prompts","text":""},{"location":"bot-gallery/#grumpy_professor_bot","title":"<code>grumpy_professor_bot</code>","text":"<p>Respond with brilliance and mild academic impatience.</p> <p>Educational Uses: - Humorous contrast - Critical thinking prompts</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A sarcastic yet insightful professor response</p>"},{"location":"bot-gallery/#cultural-studies","title":"\ud83c\udff7\ufe0f Cultural studies","text":""},{"location":"bot-gallery/#alien_bot","title":"<code>alien_bot</code>","text":"<p>Speak as an intelligent alien discovering humanity.</p> <p>Educational Uses: - Cultural studies - Writing prompts</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: An alien's thoughtful perspective</p>"},{"location":"bot-gallery/#cyber-culture-exploration","title":"\ud83c\udff7\ufe0f Cyber culture exploration","text":""},{"location":"bot-gallery/#hacker_bot","title":"<code>hacker_bot</code>","text":"<p>Respond like a 90s hacker using tech slang and lingo.</p> <p>Educational Uses: - Cyber culture exploration - Technical storytelling</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A cyberpunk-themed response</p>"},{"location":"bot-gallery/#debugging-and-code-reviews","title":"\ud83c\udff7\ufe0f Debugging and code reviews","text":""},{"location":"bot-gallery/#coder_bot_1","title":"<code>coder_bot</code>","text":"<p>Give programming help with code examples and explanations.</p> <p>Educational Uses: - Debugging and code reviews - Code literacy and syntax help</p> <p>Args:     prompt (str): A programming question or code snippet</p> <p>Returns:     str: A code-focused AI response</p>"},{"location":"bot-gallery/#digital-communication","title":"\ud83c\udff7\ufe0f Digital communication","text":""},{"location":"bot-gallery/#emoji_bot","title":"<code>emoji_bot</code>","text":"<p>Communicate primarily using expressive emojis.</p> <p>Educational Uses: - Symbolism and interpretation - Digital communication</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A response composed primarily of emojis</p>"},{"location":"bot-gallery/#encouraging-self-direction","title":"\ud83c\udff7\ufe0f Encouraging self-direction","text":""},{"location":"bot-gallery/#coach_bot_1","title":"<code>coach_bot</code>","text":"<p>Motivate and encourage like a personal coach.</p> <p>Educational Uses: - Confidence building - Encouraging self-direction</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A motivational response</p>"},{"location":"bot-gallery/#exploring-language-style","title":"\ud83c\udff7\ufe0f Exploring language style","text":""},{"location":"bot-gallery/#shakespeare_bot","title":"<code>shakespeare_bot</code>","text":"<p>Generate responses in Shakespearean English and poetic tone.</p> <p>Educational Uses: - Literature and poetry study - Exploring language style</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A Shakespearean response</p>"},{"location":"bot-gallery/#general-question-answering","title":"\ud83c\udff7\ufe0f General question answering","text":""},{"location":"bot-gallery/#friendly_bot","title":"<code>friendly_bot</code>","text":"<p>Generate a friendly and helpful response to the given prompt.</p> <p>Educational Uses: - General question answering - Student support - Introductory AI interactions</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A friendly and helpful response</p>"},{"location":"bot-gallery/#humor-based-feedback","title":"\ud83c\udff7\ufe0f Humor-based feedback","text":""},{"location":"bot-gallery/#sarcastic_bot","title":"<code>sarcastic_bot</code>","text":"<p>Generate a sarcastic response with dry humor to the given prompt.</p> <p>Educational Uses: - Humor-based feedback - Personality contrast exercises</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A sarcastic response with dry humor</p>"},{"location":"bot-gallery/#humorous-contrast","title":"\ud83c\udff7\ufe0f Humorous contrast","text":""},{"location":"bot-gallery/#grumpy_professor_bot_1","title":"<code>grumpy_professor_bot</code>","text":"<p>Respond with brilliance and mild academic impatience.</p> <p>Educational Uses: - Humorous contrast - Critical thinking prompts</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A sarcastic yet insightful professor response</p>"},{"location":"bot-gallery/#introductory-ai-interactions","title":"\ud83c\udff7\ufe0f Introductory AI interactions","text":""},{"location":"bot-gallery/#friendly_bot_1","title":"<code>friendly_bot</code>","text":"<p>Generate a friendly and helpful response to the given prompt.</p> <p>Educational Uses: - General question answering - Student support - Introductory AI interactions</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A friendly and helpful response</p>"},{"location":"bot-gallery/#language-reduction-and-abstraction","title":"\ud83c\udff7\ufe0f Language reduction and abstraction","text":""},{"location":"bot-gallery/#caveman_bot","title":"<code>caveman_bot</code>","text":"<p>Use primitive speech patterns for fun and simplicity.</p> <p>Educational Uses: - Language reduction and abstraction - Vocabulary awareness</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A simplified caveman-style response</p>"},{"location":"bot-gallery/#literature-and-poetry-study","title":"\ud83c\udff7\ufe0f Literature and poetry study","text":""},{"location":"bot-gallery/#shakespeare_bot_1","title":"<code>shakespeare_bot</code>","text":"<p>Generate responses in Shakespearean English and poetic tone.</p> <p>Educational Uses: - Literature and poetry study - Exploring language style</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A Shakespearean response</p>"},{"location":"bot-gallery/#mental-health-awareness","title":"\ud83c\udff7\ufe0f Mental health awareness","text":""},{"location":"bot-gallery/#therapist_bot","title":"<code>therapist_bot</code>","text":"<p>Provide empathetic and reflective support.</p> <p>Educational Uses: - Mental health awareness - Roleplaying and support</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A therapeutic, supportive response</p>"},{"location":"bot-gallery/#personality-contrast-exercises","title":"\ud83c\udff7\ufe0f Personality contrast exercises","text":""},{"location":"bot-gallery/#sarcastic_bot_1","title":"<code>sarcastic_bot</code>","text":"<p>Generate a sarcastic response with dry humor to the given prompt.</p> <p>Educational Uses: - Humor-based feedback - Personality contrast exercises</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A sarcastic response with dry humor</p>"},{"location":"bot-gallery/#reframing-problem-solving","title":"\ud83c\udff7\ufe0f Reframing problem-solving","text":""},{"location":"bot-gallery/#pirate_bot_1","title":"<code>pirate_bot</code>","text":"<p>Respond like a witty pirate using nautical slang and playful tone.</p> <p>Educational Uses: - Creative writing - Reframing problem-solving</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A response in pirate speak</p>"},{"location":"bot-gallery/#roleplaying-and-support","title":"\ud83c\udff7\ufe0f Roleplaying and support","text":""},{"location":"bot-gallery/#therapist_bot_1","title":"<code>therapist_bot</code>","text":"<p>Provide empathetic and reflective support.</p> <p>Educational Uses: - Mental health awareness - Roleplaying and support</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A therapeutic, supportive response</p>"},{"location":"bot-gallery/#step-by-step-tutorials","title":"\ud83c\udff7\ufe0f Step-by-step tutorials","text":""},{"location":"bot-gallery/#teacher_bot_1","title":"<code>teacher_bot</code>","text":"<p>Generate structured explanations like a calm teacher.</p> <p>Educational Uses: - Step-by-step tutorials - Clarifying concepts</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A clear, instructional explanation</p>"},{"location":"bot-gallery/#student-support","title":"\ud83c\udff7\ufe0f Student support","text":""},{"location":"bot-gallery/#friendly_bot_2","title":"<code>friendly_bot</code>","text":"<p>Generate a friendly and helpful response to the given prompt.</p> <p>Educational Uses: - General question answering - Student support - Introductory AI interactions</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A friendly and helpful response</p>"},{"location":"bot-gallery/#symbolism-and-interpretation","title":"\ud83c\udff7\ufe0f Symbolism and interpretation","text":""},{"location":"bot-gallery/#emoji_bot_1","title":"<code>emoji_bot</code>","text":"<p>Communicate primarily using expressive emojis.</p> <p>Educational Uses: - Symbolism and interpretation - Digital communication</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A response composed primarily of emojis</p>"},{"location":"bot-gallery/#technical-storytelling","title":"\ud83c\udff7\ufe0f Technical storytelling","text":""},{"location":"bot-gallery/#hacker_bot_1","title":"<code>hacker_bot</code>","text":"<p>Respond like a 90s hacker using tech slang and lingo.</p> <p>Educational Uses: - Cyber culture exploration - Technical storytelling</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A cyberpunk-themed response</p>"},{"location":"bot-gallery/#vocabulary-awareness","title":"\ud83c\udff7\ufe0f Vocabulary awareness","text":""},{"location":"bot-gallery/#caveman_bot_1","title":"<code>caveman_bot</code>","text":"<p>Use primitive speech patterns for fun and simplicity.</p> <p>Educational Uses: - Language reduction and abstraction - Vocabulary awareness</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: A simplified caveman-style response</p>"},{"location":"bot-gallery/#writing-prompts","title":"\ud83c\udff7\ufe0f Writing prompts","text":""},{"location":"bot-gallery/#alien_bot_1","title":"<code>alien_bot</code>","text":"<p>Speak as an intelligent alien discovering humanity.</p> <p>Educational Uses: - Cultural studies - Writing prompts</p> <p>Args:     prompt (str): The user's input text/question</p> <p>Returns:     str: An alien's thoughtful perspective</p>"},{"location":"classroom-setup/","title":"Classroom Setup for ChatCraft","text":"<p>This guide walks educators and students through the technical setup needed to use ChatCraft in a classroom environment. It assumes basic familiarity with Python and the command line.</p>"},{"location":"classroom-setup/#system-requirements","title":"\ud83d\udcbb System Requirements","text":"<ul> <li>Operating System: Linux, macOS, or WSL on Windows</li> <li>Python: 3.8+</li> <li>Ollama installed and running (for local LLM inference)</li> <li>Internet access (for first-time setup or optional remote models)</li> </ul>"},{"location":"classroom-setup/#installation-steps","title":"\ud83d\udd27 Installation Steps","text":""},{"location":"classroom-setup/#1-clone-the-chatcraft-repository","title":"1. Clone the ChatCraft Repository","text":"<pre><code>git clone https://github.com/teaching-repositories/chatcraft.git\ncd chatcraft\n</code></pre>"},{"location":"classroom-setup/#2-create-a-virtual-environment","title":"2. Create a Virtual Environment","text":"<p>We recommend <code>uv</code> for fast installs, but <code>venv</code> or <code>virtualenv</code> also works. <pre><code>uv venv .venv\nsource .venv/bin/activate\n</code></pre></p>"},{"location":"classroom-setup/#3-install-chatcraft-editable-mode","title":"3. Install ChatCraft (Editable Mode)","text":"<p><pre><code>uv pip install -e '.[dev]'\n</code></pre> This installs the core package, CLI entry point, and development tools.</p>"},{"location":"classroom-setup/#run-ollama","title":"\ud83e\udd16 Run Ollama","text":"<p>ChatCraft expects a local Ollama server by default.</p>"},{"location":"classroom-setup/#1-install-ollama","title":"1. Install Ollama","text":"<p>Follow instructions at: https://ollama.com/download</p>"},{"location":"classroom-setup/#2-start-the-server","title":"2. Start the Server","text":"<p><pre><code>ollama run llama3\n</code></pre> Or use a model of your choice (e.g., <code>codellama</code>, <code>mistral</code>, etc.)</p>"},{"location":"classroom-setup/#test-the-setup","title":"\ud83d\ude80 Test the Setup","text":""},{"location":"classroom-setup/#cli-check","title":"CLI Check:","text":"<p><pre><code>chatcraft doctor\n</code></pre> Should report that Ollama is reachable.</p>"},{"location":"classroom-setup/#interactive-mode","title":"Interactive Mode:","text":"<p><pre><code>chatcraft interactive\n</code></pre> Chat with any of the built-in personalities.</p>"},{"location":"classroom-setup/#classroom-preparation","title":"\ud83e\uddea Classroom Preparation","text":"<ul> <li>\u2705 Ensure all students have Python and Ollama installed</li> <li>\u2705 Pre-install the models if bandwidth is limited</li> <li>\u2705 Use <code>just doctor</code> or <code>chatcraft doctor</code> to verify working setup</li> <li>\u2705 Optionally, preload <code>.venv</code> and models on lab machines</li> <li>\u2705 Use offline bundle (<code>just bundle</code>) if internet is restricted</li> </ul>"},{"location":"classroom-setup/#optional-offline-setup","title":"\ud83d\udce6 Optional: Offline Setup","text":"<p>Use the offline zip bundle: <pre><code>just bundle\n</code></pre> Distribute <code>ChatCraft_Offline_Bundle.zip</code> to students for isolated environments.</p>"},{"location":"classroom-setup/#remote-ollama-advanced","title":"\ud83c\udf10 Remote Ollama (Advanced)","text":"<p>You can point ChatCraft to a remote Ollama server by setting the environment variable: <pre><code>export CHATCRAFT_SERVER_URL=http://your-ollama-server:11434\n</code></pre> Useful for running a central server in class.</p>"},{"location":"classroom-setup/#related-tools","title":"\ud83e\uddf0 Related Tools","text":"<ul> <li><code>just doctor</code> - Check environment</li> <li><code>just repl</code> or <code>chatcraft interactive</code> - Start REPL</li> <li><code>just build-all</code> - Build docs and mini-projects</li> <li><code>mkdocs serve</code> - Live preview of documentation site</li> </ul>"},{"location":"classroom-setup/#see-also","title":"\ud83d\udcd8 See Also","text":"<ul> <li>CLI Guide</li> <li>Ollama Setup</li> <li>Education Guide</li> </ul>"},{"location":"cli-guide/","title":"ChatCraft CLI Guide","text":"<p>This guide explains how to use the ChatCraft command-line interface (CLI) to interact with educational chatbot personalities powered by Ollama.</p>"},{"location":"cli-guide/#installation","title":"\ud83d\udce6 Installation","text":"<p>Once ChatCraft is installed with pip:</p> <pre><code>uv pip install -e '.[dev]'\n</code></pre> <p>You\u2019ll have access to a CLI tool:</p> <pre><code>chatcraft --help\n</code></pre>"},{"location":"cli-guide/#basic-commands","title":"\ud83d\udcac Basic Commands","text":""},{"location":"cli-guide/#ask-a-single-prompt","title":"Ask a Single Prompt","text":"<p>Send a question to a selected personality:</p> <pre><code>chatcraft ask \"What is Python used for?\" --personality coder\n</code></pre> <p>By default, the <code>friendly</code> bot is used unless another personality is specified.</p>"},{"location":"cli-guide/#list-available-bots","title":"List Available Bots","text":"<pre><code>chatcraft bots\n</code></pre> <p>Displays all personality bots with a brief description.</p>"},{"location":"cli-guide/#check-system-doctor","title":"Check System (Doctor)","text":"<pre><code>chatcraft doctor\n</code></pre> <p>Performs a diagnostic to check if the Ollama server is reachable and responding.</p>"},{"location":"cli-guide/#interactive-mode-repl","title":"\ud83d\udda5\ufe0f Interactive Mode (REPL)","text":"<p>Run:</p> <pre><code>chatcraft interactive\n</code></pre> <p>This opens a text-based, stateless REPL (Read-Eval-Print Loop).</p>"},{"location":"cli-guide/#repl-commands","title":"REPL Commands","text":"<p>Use commands prefixed with <code>/</code> inside the REPL:</p> Command Description <code>/help</code> Show help menu <code>/exit</code> Exit the REPL <code>/bots</code> List available bot personalities <code>/personality NAME</code> Switch to a different bot <code>/doctor</code> Check Ollama server status <p>\u2757 This REPL is stateless: it does not retain memory or chat history between turns.</p>"},{"location":"cli-guide/#custom-personalities","title":"\ud83e\udde0 Custom Personalities","text":"<p>ChatCraft bots are defined as simple Python functions using <code>get_response()</code>. You can create your own bots or extend existing ones.</p> <p>All built-in bots are available via:</p> <pre><code>from chatcraft import friendly_bot, pirate_bot, coder_bot, ...\n</code></pre>"},{"location":"cli-guide/#troubleshooting","title":"\ud83e\uddea Troubleshooting","text":"<ul> <li>If you see <code>\u274c Ollama server not reachable</code>, ensure Ollama is running on your machine.</li> <li>Use <code>chatcraft doctor</code> for diagnostics.</li> <li>To change the server URL, set the <code>OLLAMA_HOST</code> environment variable.</li> </ul> <pre><code>export OLLAMA_HOST=http://remote-server:11434\n</code></pre>"},{"location":"cli-guide/#related-docs","title":"\ud83d\udcda Related Docs","text":"<ul> <li>Ollama Setup Guide</li> <li>Mini Projects</li> <li>Education Guide</li> </ul> <p>ChatCraft CLI is designed for educational use, rapid prototyping, and personality-driven chatbot interaction.</p> <p>For more advanced usage, consider integrating ChatCraft into your Python projects using the <code>chatcraft</code> library.</p>"},{"location":"configuration/","title":"ChatCraft Configuration Guide","text":"<p>This document outlines how to configure ChatCraft for different environments and usage needs. ChatCraft is designed to be flexible and educator-friendly, supporting both local development and classroom deployment.</p>"},{"location":"configuration/#configuration-priorities","title":"\ud83d\udd27 Configuration Priorities","text":"<p>ChatCraft supports configuration via the following priority order:</p> <ol> <li>Environment Variables (highest priority)</li> <li>User Configuration File (<code>~/.chatcraft/config.json</code>)</li> <li>Built-in Defaults (fallback if no config found)</li> </ol>"},{"location":"configuration/#configuration-options","title":"\ud83e\udde9 Configuration Options","text":"<p>The following options can be configured:</p>"},{"location":"configuration/#ollama_host","title":"<code>OLLAMA_HOST</code>","text":"<ul> <li>Description: URL of the Ollama server to use</li> <li>Default: <code>http://localhost:11434</code></li> <li>Set via:</li> <li>Environment: <code>OLLAMA_HOST=http://remote-server:11434</code></li> <li>Config File: <code>{ \"ollama_host\": \"http://remote-server:11434\" }</code></li> </ul>"},{"location":"configuration/#default_model","title":"<code>DEFAULT_MODEL</code>","text":"<ul> <li>Description: Default model to use (e.g., <code>llama3</code>, <code>codellama</code>)</li> <li>Default: <code>llama3</code></li> <li>Set via:</li> <li>Environment: <code>DEFAULT_MODEL=codellama</code></li> <li>Config File: <code>{ \"default_model\": \"codellama\" }</code></li> </ul>"},{"location":"configuration/#default_personality","title":"<code>DEFAULT_PERSONALITY</code>","text":"<ul> <li>Description: Default bot personality for REPL and CLI</li> <li>Default: <code>friendly</code></li> <li>Set via:</li> <li>Environment: <code>DEFAULT_PERSONALITY=hacker</code></li> <li>Config File: <code>{ \"default_personality\": \"hacker\" }</code></li> </ul>"},{"location":"configuration/#timeout","title":"<code>TIMEOUT</code>","text":"<ul> <li>Description: Request timeout (in seconds)</li> <li>Default: <code>10</code></li> <li>Set via:</li> <li>Environment: <code>CHATCRAFT_TIMEOUT=15</code></li> <li>Config File: <code>{ \"timeout\": 15 }</code></li> </ul>"},{"location":"configuration/#configuration-file-location","title":"\ud83d\udcc1 Configuration File Location","text":"<p>By default, ChatCraft looks for a JSON config file at: <pre><code>~/.chatcraft/config.json\n</code></pre> Example: <pre><code>{\n  \"ollama_host\": \"http://192.168.1.42:11434\",\n  \"default_model\": \"llama3\",\n  \"default_personality\": \"coder\",\n  \"timeout\": 12\n}\n</code></pre></p>"},{"location":"configuration/#developer-overrides","title":"\u2699\ufe0f Developer Overrides","text":"<p>For local development or advanced use, ChatCraft also supports fallback personality message overrides:</p> <ul> <li><code>~/.chatcraft/fallbacks.json</code> \u2013 user-specific overrides</li> <li><code>chatcraft/data/fallbacks.local.json</code> \u2013 local project overrides</li> <li><code>chatcraft/data/fallbacks.json</code> \u2013 default bundled fallback messages</li> </ul>"},{"location":"configuration/#verifying-configuration","title":"\ud83e\uddea Verifying Configuration","text":"<p>Run the built-in diagnostic command: <pre><code>chatcraft doctor\n</code></pre> This will: - Check the Ollama server connection - Display the resolved configuration - List available models (if reachable)</p>"},{"location":"configuration/#tips-for-educators","title":"\ud83d\udca1 Tips for Educators","text":"<ul> <li>Create a shared classroom config file and distribute it to students (e.g., via <code>curl</code> script)</li> <li>Use environment variables to avoid hardcoding URLs into student projects</li> <li>Customize fallback personality messages for your learning context</li> </ul>"},{"location":"configuration/#related-commands","title":"\ud83d\udee0\ufe0f Related Commands","text":"<ul> <li><code>just doctor</code> \u2013 Run diagnostics</li> <li><code>just repl</code> \u2013 Start CLI REPL</li> <li><code>chatcraft --help</code> \u2013 View CLI options</li> </ul> <p>For advanced configuration of Ollama itself, refer to the Ollama Guide.</p>"},{"location":"education-guide/","title":"ChatCraft: Education Guide","text":"<p>\"LLMs made simple for students and educators\"</p> <p>This guide provides educational rationale, classroom implementation strategies, and learning objectives for using ChatCraft in various educational settings.</p>"},{"location":"education-guide/#educational-value","title":"Educational Value","text":"<p>ChatCraft was designed with specific educational benefits in mind:</p> <ol> <li>Removing Technical Barriers - Students can experiment with AI without getting lost in API keys, tokens, or complex setup</li> <li>Focusing on Core Programming Concepts - Function calls, variables, conditionals, and user input are reinforced</li> <li>Encouraging Creative Expression - Personality bots invite students to think about tone, voice, and creative writing</li> <li>Making AI Approachable - Simplifies complex technology into manageable, fun interactions</li> <li>Building Critical AI Literacy - Students learn about AI capabilities and limitations through hands-on experimentation</li> </ol>"},{"location":"education-guide/#curriculum-integration","title":"Curriculum Integration","text":"<p>ChatCraft can be integrated into various levels of computer science education:</p>"},{"location":"education-guide/#beginner-level-no-prior-programming-experience","title":"Beginner Level (No Prior Programming Experience)","text":"<ul> <li>Objectives: Basic syntax, function calls, variables</li> <li>Activities: </li> <li>Modify existing bot personalities</li> <li>Create simple conversation scripts</li> <li>Experiment with different prompts</li> </ul>"},{"location":"education-guide/#intermediate-level-some-programming-experience","title":"Intermediate Level (Some Programming Experience)","text":"<ul> <li>Objectives: Conditionals, loops, functions, error handling</li> <li>Activities: </li> <li>Create custom bot personalities from scratch</li> <li>Build a menu-based chatbot interface</li> <li>Develop a simple Q&amp;A system</li> </ul>"},{"location":"education-guide/#advanced-level-proficient-in-python","title":"Advanced Level (Proficient in Python)","text":"<ul> <li>Objectives: API integration, state management, more complex applications</li> <li>Activities: </li> <li>Create multi-bot conversation simulations</li> <li>Build a chatbot with memory/context</li> <li>Extend ChatCraft with additional backends</li> </ul>"},{"location":"education-guide/#classroom-implementation-models","title":"Classroom Implementation Models","text":""},{"location":"education-guide/#1-guided-tour-1-hour","title":"1. Guided Tour (1 Hour)","text":"<p>A quick introduction to AI concepts through ChatCraft: - 10 min: Introduction to LLMs and ChatCraft - 15 min: Demonstration of pre-built bots - 25 min: Hands-on with simple modifications - 10 min: Discussion and reflection</p>"},{"location":"education-guide/#2-mini-project-workshop-2-3-hours","title":"2. Mini-Project Workshop (2-3 Hours)","text":"<p>Students build a specific application with ChatCraft: - 15 min: Introduction and demo - 30 min: Planning and design - 90 min: Development time - 15 min: Showcase and sharing</p>"},{"location":"education-guide/#3-multi-week-unit-2-3-weeks","title":"3. Multi-Week Unit (2-3 Weeks)","text":"<p>Deeper exploration of AI concepts and applications: - Week 1: Introduction to ChatCraft and basic interactions - Week 2: Building custom personalities and applications - Week 3: Culminating projects and presentations</p>"},{"location":"education-guide/#learning-objectives-by-domain","title":"Learning Objectives by Domain","text":""},{"location":"education-guide/#computer-science","title":"Computer Science","text":"<ul> <li>Understand function calls and parameters</li> <li>Practice string manipulation and text processing</li> <li>Implement basic control structures</li> <li>Gain exposure to API concepts</li> </ul>"},{"location":"education-guide/#ai-literacy","title":"AI Literacy","text":"<ul> <li>Recognize capabilities and limitations of LLMs</li> <li>Understand the role of system prompts in shaping responses</li> <li>Identify patterns in AI-generated content</li> <li>Develop critical thinking about AI outputs</li> </ul>"},{"location":"education-guide/#creativity-communication","title":"Creativity &amp; Communication","text":"<ul> <li>Design unique bot personalities</li> <li>Craft effective prompts for desired outcomes</li> <li>Create narrative-based interactions</li> <li>Express ideas through multiple communication styles</li> </ul>"},{"location":"education-guide/#assessment-ideas","title":"Assessment Ideas","text":"<ul> <li>Portfolio: Collection of bot personalities created by students</li> <li>Project: Functional application built with ChatCraft (quiz bot, story bot, etc.)</li> <li>Reflection: Written analysis of AI strengths/limitations observed</li> <li>Presentation: Demo of custom bot and explanation of design choices</li> </ul>"},{"location":"education-guide/#classroom-setup-requirements","title":"Classroom Setup Requirements","text":""},{"location":"education-guide/#hardware","title":"Hardware","text":"<ul> <li>Standard classroom computers or laptops</li> <li>Internet connection (if using remote LLM APIs)</li> <li>Or: Sufficient local processing power for running Ollama locally</li> </ul>"},{"location":"education-guide/#software","title":"Software","text":"<ul> <li>Python 3.6+</li> <li>ChatCraft library installed</li> <li>Ollama or alternative LLM backend</li> </ul>"},{"location":"education-guide/#preparation-steps","title":"Preparation Steps","text":"<ol> <li>Install Python on all classroom machines</li> <li>Install ChatCraft (<code>pip install chatcraft</code>)</li> <li>Set up Ollama with desired models (llama3 recommended for beginners)</li> <li>Test a basic example before class</li> </ol>"},{"location":"education-guide/#ethical-considerations","title":"Ethical Considerations","text":"<p>When introducing AI in the classroom, consider discussing:</p> <ul> <li>Attribution: When is AI-generated content appropriate to use?</li> <li>Transparency: The importance of disclosing when AI has been used</li> <li>Critical evaluation: Not accepting AI outputs without verification</li> <li>Appropriate uses: Setting boundaries for how the tool should be used</li> </ul>"},{"location":"education-guide/#additional-resources","title":"Additional Resources","text":"<ul> <li>mini-projects.md - Ready-to-use classroom activities</li> <li>bot-gallery.md - Library of pre-built personality bots</li> <li>classroom0setup.md - Detailed technical setup instructions</li> </ul>"},{"location":"education-guide/#example-lesson-plan-personality-bot-workshop","title":"Example Lesson Plan: \"Personality Bot Workshop\"","text":"<p>Duration: 90 minutes Level: Beginner to Intermediate Objective: Students will create and interact with custom personality bots</p>"},{"location":"education-guide/#materials","title":"Materials","text":"<ul> <li>Computers with Python and ChatCraft installed</li> <li>Handout with personality prompt examples</li> <li>Worksheet for planning bot personalities</li> </ul>"},{"location":"education-guide/#lesson-flow","title":"Lesson Flow","text":"<ol> <li>Introduction (15 min)</li> <li>Demonstrate existing personality bots</li> <li>Explain the concept of system prompts</li> <li> <p>Show how personality affects responses</p> </li> <li> <p>Planning Phase (15 min)</p> </li> <li>Students brainstorm bot personalities</li> <li>Complete worksheet defining tone, style, quirks</li> <li> <p>Share ideas with a partner for feedback</p> </li> <li> <p>Implementation (30 min)</p> </li> <li>Code their personality bot function</li> <li>Test with various prompts</li> <li> <p>Refine system prompts based on results</p> </li> <li> <p>Challenge Extension (15 min)</p> </li> <li>Create a conversation between two different bots</li> <li> <p>Implement a simple menu to switch between bots</p> </li> <li> <p>Showcase &amp; Reflection (15 min)</p> </li> <li>Students demonstrate their bots</li> <li>Class votes on most creative, most helpful, most amusing bots</li> <li>Discussion: What did you learn about how system prompts affect responses?</li> </ol>"},{"location":"education-guide/#assessment","title":"Assessment","text":"<ul> <li>Completed personality bot function</li> <li>Creative application of system prompts</li> <li>Thoughtful reflection on bot behavior</li> </ul> <p>Note: ChatCraft is designed to be used with age-appropriate models and settings. Always review school policies regarding AI tools before implementation.</p>"},{"location":"mini-project-template/","title":"Template","text":"<p>I need a python script to modify all markdown file in a folder from the current format to the new format.</p> <p>The instructions also contain python code with comments, so we do not want to modify the comments in the python code.  the python code is gated \"<code>python\" and \"</code>\"</p> <p>The current format is as follows:</p> <pre><code>## Project Title\n\n**Difficulty**: Beginner  \n**Time**: 30 minutes  \n**Learning Focus**: Lists, loops, user input\n\n### Overview\nA short description of what the student will build or learn.\n\n### Instructions\nStep-by-step or scaffolded guidance.\n\n### Extension Ideas\nOptional: Ways to expand or personalize the project.\n</code></pre> <p>The new format is as follows:</p> <pre><code># Project Title\n\n**Difficulty**: Beginner  \n**Time**: 30 minutes  \n**Learning Focus**: Lists, loops, user input\n\n## Overview\nA short description of what the student will build or learn.\n\n## Instructions\nStep-by-step or scaffolded guidance.\n\n## Extension Ideas\nOptional: Ways to expand or personalize the project.\n</code></pre>"},{"location":"mini-projects/","title":"Mini Project Examples","text":"<p>This document contains ready-to-use mini-projects and activities for using ChatCraft in educational settings. Each project includes learning objectives, difficulty level, estimated time, and complete code examples.</p>"},{"location":"mini-projects/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Advanced Journal Assistant</li> <li>Bot Personality Menu Generator</li> <li>Build Your Own Personality Bot</li> <li>Choose Your Own Adventure</li> <li>Classroom Simulation Bot</li> <li>Code Explainer Tool</li> <li>Creative Writing Partner</li> <li>Data Visualization Dashboard</li> <li>AI Persona Dialogue Simulator</li> <li>Emotional Support Bot</li> <li>Historical Figure Chat</li> <li>Image Gallery Creator</li> <li>Journal or Reflection Bot</li> <li>Knowledge Quiz Bot</li> <li>Language Translation Helper</li> <li>Mood Journal Assistant</li> <li>PDF Question Answering Chatbot</li> <li>Personality Bot Creator</li> <li>Smart To-Do List</li> <li>Subject Expert Tutor</li> <li>Text Adventure Game Engine</li> <li>Trivia or Quiz Bot</li> <li>Weather Dashboard</li> <li>YouTube to Blog Converter</li> </ol>"},{"location":"mini-projects/#advanced-journal-assistant","title":"Advanced Journal Assistant","text":"<p>Difficulty: Intermediate-Advanced Time: 60-90 minutes Learning Focus: Data structures, file I/O, data visualization, natural language processing, user experience design</p>"},{"location":"mini-projects/#overview","title":"Overview","text":"<p>Create a comprehensive journaling application that combines structured mood tracking with flexible reflection prompts, offering users deep insights through data visualization and AI-powered analysis.</p>"},{"location":"mini-projects/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport datetime\nimport os\nimport json\nimport matplotlib.pyplot as plt\nfrom collections import Counter\nimport re\n\nclass AdvancedJournalAssistant:\n    def __init__(self):\n        \"\"\"Initialize the journal assistant with necessary directories and files\"\"\"\n        # Set up storage directories\n        self.journal_dir = os.path.expanduser(\"~/.advanced_journal\")\n        self.visualization_dir = os.path.join(self.journal_dir, \"visualizations\")\n        os.makedirs(self.journal_dir, exist_ok=True)\n        os.makedirs(self.visualization_dir, exist_ok=True)\n\n        # Define file paths\n        self.journal_file = os.path.join(self.journal_dir, \"journal_entries.json\")\n        self.prompt_file = os.path.join(self.journal_dir, \"custom_prompts.json\")\n\n        # Initialize data structures\n        self.entries = self._load_entries()\n        self.custom_prompts = self._load_custom_prompts()\n\n        # Default prompts\n        self.default_prompts = [\n            \"What's something that happened today that you'd like to reflect on?\",\n            \"What's something you learned today?\",\n            \"What's something you're grateful for today?\",\n            \"What's something that challenged you today?\",\n            \"What's something you're looking forward to?\",\n            \"How did you take care of yourself today?\",\n            \"Was there a moment today that stood out? Why?\",\n            \"What's something you'd like to remember about today?\"\n        ]\n\n        # Define mood labels for better interpretation\n        self.mood_labels = {\n            1: \"Very Low\", 2: \"Low\", 3: \"Somewhat Low\", 4: \"Below Average\", 5: \"Neutral\", \n            6: \"Slightly Positive\", 7: \"Good\", 8: \"Very Good\", 9: \"Excellent\", 10: \"Outstanding\"\n        }\n\n        # Track user preferences\n        self.preferences = self._load_preferences()\n\n    def _load_entries(self):\n        \"\"\"Load existing journal entries or return an empty list\"\"\"\n        if os.path.exists(self.journal_file):\n            try:\n                with open(self.journal_file, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                return []\n        return []\n\n    def _load_custom_prompts(self):\n        \"\"\"Load custom prompts or return an empty list\"\"\"\n        if os.path.exists(self.prompt_file):\n            try:\n                with open(self.prompt_file, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                return []\n        return []\n\n    def _load_preferences(self):\n        \"\"\"Load user preferences or set defaults\"\"\"\n        pref_file = os.path.join(self.journal_dir, \"preferences.json\")\n        defaults = {\n            \"auto_insights\": True,\n            \"daily_reminder\": False,\n            \"reminder_time\": \"20:00\",\n            \"favorite_prompts\": [],\n            \"theme\": \"standard\",\n            \"insight_frequency\": \"weekly\"\n        }\n\n        if os.path.exists(pref_file):\n            try:\n                with open(pref_file, 'r') as f:\n                    stored_prefs = json.load(f)\n                    # Update defaults with stored preferences\n                    defaults.update(stored_prefs)\n            except json.JSONDecodeError:\n                pass\n\n        return defaults\n\n    def _save_entries(self):\n        \"\"\"Save journal entries to file\"\"\"\n        with open(self.journal_file, 'w') as f:\n            json.dump(self.entries, f, indent=2)\n\n    def _save_custom_prompts(self):\n        \"\"\"Save custom prompts to file\"\"\"\n        with open(self.prompt_file, 'w') as f:\n            json.dump(self.custom_prompts, f, indent=2)\n\n    def _save_preferences(self):\n        \"\"\"Save user preferences to file\"\"\"\n        pref_file = os.path.join(self.journal_dir, \"preferences.json\")\n        with open(pref_file, 'w') as f:\n            json.dump(self.preferences, f, indent=2)\n\n    def display_menu(self):\n        \"\"\"Display the main menu and handle user choices\"\"\"\n        print(\"\\n======================================\")\n        print(\"=== Advanced Journal Assistant ===\")\n        print(\"======================================\")\n        print(\"1. Create new journal entry\")\n        print(\"2. View past entries\")\n        print(\"3. Get insights and analytics\")\n        print(\"4. Manage custom prompts\")\n        print(\"5. Set goals and intentions\")\n        print(\"6. Preferences\")\n        print(\"7. Export journal\")\n        print(\"8. Exit\")\n\n        try:\n            choice = input(\"\\nWhat would you like to do? (1-8): \")\n\n            menu_actions = {\n                \"1\": self.create_entry,\n                \"2\": self.view_entries,\n                \"3\": self.get_insights,\n                \"4\": self.manage_prompts,\n                \"5\": self.set_goals,\n                \"6\": self.set_preferences,\n                \"7\": self.export_journal,\n                \"8\": self.exit_app\n            }\n\n            # Execute the chosen action or show error\n            if choice in menu_actions:\n                menu_actions[choice]()\n            else:\n                print(\"Invalid choice. Please try again.\")\n                self.display_menu()\n\n        except KeyboardInterrupt:\n            self.exit_app()\n\n    def create_entry(self):\n        \"\"\"Create a new journal entry with structured and free-form components\"\"\"\n        print(\"\\n=== New Journal Entry ===\")\n\n        # Get date/time\n        today = datetime.datetime.now()\n        date_str = today.strftime(\"%Y-%m-%d\")\n        time_str = today.strftime(\"%H:%M\")\n\n        # Check if we already have an entry for today\n        existing_entries = [e for e in self.entries if e[\"date\"] == date_str]\n        if existing_entries:\n            print(f\"You already have {len(existing_entries)} entries for today.\")\n            add_another = input(\"Would you like to add another entry? (y/n): \").lower()\n            if add_another != 'y':\n                self.display_menu()\n                return\n\n        # Collect mood data\n        try:\n            mood = int(input(\"\\nHow would you rate your mood right now (1-10)? \"))\n            if not 1 &lt;= mood &lt;= 10:\n                print(\"Please enter a number between 1 and 10.\")\n                mood = 5  # Default to neutral if invalid\n            mood_label = self.mood_labels[mood]\n            print(f\"Mood: {mood}/10 - {mood_label}\")\n        except ValueError:\n            print(\"Invalid input. Setting mood to neutral (5/10).\")\n            mood = 5\n            mood_label = self.mood_labels[mood]\n\n        # Get energy level\n        try:\n            energy = int(input(\"\\nHow is your energy level (1-10)? \"))\n            if not 1 &lt;= energy &lt;= 10:\n                energy = 5  # Default if invalid\n        except ValueError:\n            energy = 5\n\n        # Get prompt for reflection\n        print(\"\\nChoose a prompt for reflection:\")\n        all_prompts = self.default_prompts + self.custom_prompts\n\n        # Show prompts\n        for i, prompt in enumerate(all_prompts, 1):\n            print(f\"{i}. {prompt}\")\n        print(f\"{len(all_prompts) + 1}. Create a custom prompt\")\n\n        try:\n            prompt_choice = int(input(\"\\nSelect a prompt (number): \"))\n            if 1 &lt;= prompt_choice &lt;= len(all_prompts):\n                selected_prompt = all_prompts[prompt_choice - 1]\n            else:\n                custom_prompt = input(\"Enter your custom prompt: \")\n                selected_prompt = custom_prompt\n                # Ask if they want to save this prompt for future use\n                save_prompt = input(\"Would you like to save this prompt for future use? (y/n): \").lower()\n                if save_prompt == 'y':\n                    self.custom_prompts.append(custom_prompt)\n                    self._save_custom_prompts()\n                    print(\"Custom prompt saved.\")\n        except (ValueError, IndexError):\n            # Default to first prompt if invalid\n            selected_prompt = all_prompts[0]\n            print(f\"Using default prompt: {selected_prompt}\")\n\n        # Display the selected prompt and get reflection\n        print(f\"\\n&gt; {selected_prompt}\")\n        reflection = input(\"Your reflection: \")\n\n        # Get activities\n        activities = input(\"\\nWhat activities did you do today? (comma-separated): \")\n        activity_list = [a.strip() for a in activities.split(\",\") if a.strip()]\n\n        # Get any tags the user wants to associate with this entry\n        tags = input(\"\\nAdd any tags to help categorize this entry (comma-separated): \")\n        tag_list = [t.strip() for t in tags.split(\",\") if t.strip()]\n\n        # Create the entry object\n        entry = {\n            \"date\": date_str,\n            \"time\": time_str,\n            \"mood\": mood,\n            \"mood_label\": mood_label,\n            \"energy\": energy,\n            \"prompt\": selected_prompt,\n            \"reflection\": reflection,\n            \"activities\": activity_list,\n            \"tags\": tag_list,\n            \"ai_insights\": None  # Will be filled in by AI\n        }\n\n        # Get AI reflection if user wants it\n        if self.preferences[\"auto_insights\"]:\n            print(\"\\nGenerating insights for your entry...\")\n            entry[\"ai_insights\"] = self._generate_entry_insight(entry)\n            print(\"\\n=== AI Reflection ===\")\n            print(entry[\"ai_insights\"])\n\n        # Add entry to the list and save\n        self.entries.append(entry)\n        self._save_entries()\n        print(\"\\nJournal entry saved successfully!\")\n\n        # Return to menu\n        input(\"\\nPress Enter to continue...\")\n        self.display_menu()\n\n    def view_entries(self):\n        \"\"\"View and search past journal entries\"\"\"\n        if not self.entries:\n            print(\"\\nNo journal entries found.\")\n            input(\"\\nPress Enter to continue...\")\n            self.display_menu()\n            return\n\n        print(\"\\n=== View Journal Entries ===\")\n        print(\"1. View recent entries\")\n        print(\"2. Search by date\")\n        print(\"3. Search by mood\")\n        print(\"4. Search by tag\")\n        print(\"5. Search by text\")\n        print(\"6. Return to main menu\")\n\n        choice = input(\"\\nWhat would you like to do? (1-6): \")\n\n        if choice == \"1\":\n            # Show recent entries\n            recent = self.entries[-10:]  # Last 10 entries\n            recent.reverse()  # Most recent first\n            self._display_entry_list(recent, \"Recent Entries\")\n\n        elif choice == \"2\":\n            # Search by date\n            date_query = input(\"\\nEnter date (YYYY-MM-DD) or month (YYYY-MM): \")\n            matching = [e for e in self.entries if e[\"date\"].startswith(date_query)]\n            self._display_entry_list(matching, f\"Entries for {date_query}\")\n\n        elif choice == \"3\":\n            # Search by mood\n            try:\n                mood_min = int(input(\"\\nEnter minimum mood (1-10): \"))\n                mood_max = int(input(\"Enter maximum mood (1-10): \"))\n                matching = [e for e in self.entries \n                           if mood_min &lt;= e[\"mood\"] &lt;= mood_max]\n                self._display_entry_list(matching, f\"Entries with mood {mood_min}-{mood_max}\")\n            except ValueError:\n                print(\"Invalid input. Please enter numbers for mood range.\")\n\n        elif choice == \"4\":\n            # Search by tag\n            tag = input(\"\\nEnter tag to search for: \").strip().lower()\n            matching = [e for e in self.entries \n                       if any(t.lower() == tag for t in e[\"tags\"])]\n            self._display_entry_list(matching, f\"Entries tagged with '{tag}'\")\n\n        elif choice == \"5\":\n            # Search by text\n            text = input(\"\\nEnter text to search for: \").strip().lower()\n            matching = [e for e in self.entries \n                       if text in e[\"reflection\"].lower() or \n                       text in e[\"prompt\"].lower() or\n                       any(text in a.lower() for a in e[\"activities\"])]\n            self._display_entry_list(matching, f\"Entries containing '{text}'\")\n\n        elif choice == \"6\":\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # After any search, go back to view menu\n        self.view_entries()\n\n    def _display_entry_list(self, entries, title):\n        \"\"\"Display a list of entries and allow user to select one to view in detail\"\"\"\n        if not entries:\n            print(f\"\\nNo entries found for {title}.\")\n            input(\"\\nPress Enter to continue...\")\n            return\n\n        print(f\"\\n=== {title} ===\")\n        for i, entry in enumerate(entries, 1):\n            date_str = entry[\"date\"]\n            mood = entry[\"mood\"]\n\n            # Get a preview of the reflection (first 40 chars)\n            preview = entry[\"reflection\"][:40] + \"...\" if len(entry[\"reflection\"]) &gt; 40 else entry[\"reflection\"]\n\n            print(f\"{i}. {date_str} - Mood: {mood}/10 - {preview}\")\n\n        print(f\"{len(entries) + 1}. Back\")\n\n        try:\n            choice = int(input(\"\\nSelect an entry to view (number): \"))\n            if 1 &lt;= choice &lt;= len(entries):\n                self._display_entry_detail(entries[choice - 1])\n            elif choice == len(entries) + 1:\n                return\n            else:\n                print(\"Invalid choice.\")\n        except ValueError:\n            print(\"Invalid input. Please enter a number.\")\n\n    def _display_entry_detail(self, entry):\n        \"\"\"Display details of a single entry\"\"\"\n        print(\"\\n\" + \"=\" * 50)\n        print(f\"Date: {entry['date']} at {entry['time']}\")\n        print(f\"Mood: {entry['mood']}/10 - {entry['mood_label']}\")\n        print(f\"Energy: {entry['energy']}/10\")\n        print(\"\\nPrompt:\")\n        print(f\"{entry['prompt']}\")\n        print(\"\\nReflection:\")\n        print(f\"{entry['reflection']}\")\n\n        if entry[\"activities\"]:\n            print(\"\\nActivities:\")\n            for activity in entry[\"activities\"]:\n                print(f\"- {activity}\")\n\n        if entry[\"tags\"]:\n            print(\"\\nTags:\")\n            print(\", \".join(entry[\"tags\"]))\n\n        if entry.get(\"ai_insights\"):\n            print(\"\\nAI Insights:\")\n            print(entry[\"ai_insights\"])\n\n        print(\"=\" * 50)\n\n        # Options after viewing an entry\n        print(\"\\n1. Edit this entry\")\n        print(\"2. Delete this entry\")\n        print(\"3. Generate AI insights for this entry\")\n        print(\"4. Back\")\n\n        choice = input(\"\\nWhat would you like to do? (1-4): \")\n\n        if choice == \"1\":\n            self._edit_entry(entry)\n        elif choice == \"2\":\n            self._delete_entry(entry)\n        elif choice == \"3\":\n            if not entry.get(\"ai_insights\"):\n                print(\"\\nGenerating insights...\")\n                entry[\"ai_insights\"] = self._generate_entry_insight(entry)\n                self._save_entries()\n            print(\"\\n=== AI Insights ===\")\n            print(entry[\"ai_insights\"])\n            input(\"\\nPress Enter to continue...\")\n        elif choice == \"4\":\n            return\n        else:\n            print(\"Invalid choice.\")\n            self._display_entry_detail(entry)\n\n    def _edit_entry(self, entry):\n        \"\"\"Edit an existing journal entry\"\"\"\n        print(\"\\n=== Edit Entry ===\")\n        print(\"What would you like to modify?\")\n        print(\"1. Mood rating\")\n        print(\"2. Energy rating\")\n        print(\"3. Reflection text\")\n        print(\"4. Activities\")\n        print(\"5. Tags\")\n        print(\"6. Cancel edit\")\n\n        choice = input(\"\\nEnter your choice (1-6): \")\n\n        if choice == \"1\":\n            try:\n                new_mood = int(input(\"Enter new mood rating (1-10): \"))\n                if 1 &lt;= new_mood &lt;= 10:\n                    entry[\"mood\"] = new_mood\n                    entry[\"mood_label\"] = self.mood_labels[new_mood]\n                    print(\"Mood updated.\")\n                else:\n                    print(\"Invalid mood rating. Must be between 1 and 10.\")\n            except ValueError:\n                print(\"Invalid input. Mood not changed.\")\n\n        elif choice == \"2\":\n            try:\n                new_energy = int(input(\"Enter new energy rating (1-10): \"))\n                if 1 &lt;= new_energy &lt;= 10:\n                    entry[\"energy\"] = new_energy\n                    print(\"Energy updated.\")\n                else:\n                    print(\"Invalid energy rating. Must be between 1 and 10.\")\n            except ValueError:\n                print(\"Invalid input. Energy not changed.\")\n\n        elif choice == \"3\":\n            print(f\"Current reflection: {entry['reflection']}\")\n            new_text = input(\"Enter new reflection (or press Enter to keep current): \")\n            if new_text:\n                entry[\"reflection\"] = new_text\n                print(\"Reflection updated.\")\n\n        elif choice == \"4\":\n            print(f\"Current activities: {', '.join(entry['activities'])}\")\n            new_activities = input(\"Enter new activities (comma-separated): \")\n            if new_activities:\n                entry[\"activities\"] = [a.strip() for a in new_activities.split(\",\") if a.strip()]\n                print(\"Activities updated.\")\n\n        elif choice == \"5\":\n            print(f\"Current tags: {', '.join(entry['tags'])}\")\n            new_tags = input(\"Enter new tags (comma-separated): \")\n            if new_tags:\n                entry[\"tags\"] = [t.strip() for t in new_tags.split(\",\") if t.strip()]\n                print(\"Tags updated.\")\n\n        elif choice == \"6\":\n            print(\"Edit canceled.\")\n            self._display_entry_detail(entry)\n            return\n\n        else:\n            print(\"Invalid choice.\")\n            self._edit_entry(entry)\n            return\n\n        # After any edit, regenerate insights if auto-insights is enabled\n        if self.preferences[\"auto_insights\"]:\n            print(\"Regenerating insights for updated entry...\")\n            entry[\"ai_insights\"] = self._generate_entry_insight(entry)\n\n        # Save changes\n        self._save_entries()\n        print(\"Entry updated successfully.\")\n\n        # Show the updated entry\n        self._display_entry_detail(entry)\n\n    def _delete_entry(self, entry):\n        \"\"\"Delete a journal entry\"\"\"\n        confirm = input(\"\\nAre you sure you want to delete this entry? (y/n): \").lower()\n        if confirm == 'y':\n            self.entries.remove(entry)\n            self._save_entries()\n            print(\"Entry deleted successfully.\")\n        else:\n            print(\"Deletion canceled.\")\n            self._display_entry_detail(entry)\n\n    def _generate_entry_insight(self, entry):\n        \"\"\"Generate AI insights for a journal entry\"\"\"\n        prompt = f\"\"\"\n        The user wrote a journal entry with the following details:\n        - Date: {entry['date']}\n        - Mood: {entry['mood']}/10 ({entry['mood_label']})\n        - Energy: {entry['energy']}/10\n        - Prompt: \"{entry['prompt']}\"\n        - Reflection: \"{entry['reflection']}\"\n        - Activities: {', '.join(entry['activities']) if entry['activities'] else 'None mentioned'}\n        - Tags: {', '.join(entry['tags']) if entry['tags'] else 'None'}\n\n        Please provide a thoughtful, empathetic reflection on this entry. Include:\n        1. An observation about their mood and energy\n        2. A meaningful insight about their reflection\n        3. A gentle question to deepen their self-awareness\n\n        Keep your response concise and supportive (150 words max).\n        \"\"\"\n\n        return get_response(prompt, \n                          system=\"You are an empathetic journaling assistant who helps users gain deeper insights from their reflections.\")\n\n    def get_insights(self):\n        \"\"\"Generate analytics and AI insights from journal entries\"\"\"\n        if len(self.entries) &lt; 3:\n            print(\"\\nYou need at least 3 journal entries to generate insights.\")\n            input(\"\\nPress Enter to continue...\")\n            self.display_menu()\n            return\n\n        print(\"\\n=== Journal Insights &amp; Analytics ===\")\n        print(\"1. Mood trends visualization\")\n        print(\"2. Activity impact analysis\")\n        print(\"3. Word cloud and themes\")\n        print(\"4. Weekly summary\")\n        print(\"5. Monthly review\")\n        print(\"6. Custom date range analysis\")\n        print(\"7. Return to main menu\")\n\n        choice = input(\"\\nWhat would you like to see? (1-7): \")\n\n        if choice == \"1\":\n            self._visualize_mood_trends()\n        elif choice == \"2\":\n            self._analyze_activity_impact()\n        elif choice == \"3\":\n            self._generate_word_cloud()\n        elif choice == \"4\":\n            self._generate_weekly_summary()\n        elif choice == \"5\":\n            self._generate_monthly_review()\n        elif choice == \"6\":\n            self._custom_date_analysis()\n        elif choice == \"7\":\n            self.display_menu()\n            return\n        else:\n            print(\"Invalid choice.\")\n\n        # Return to insights menu\n        input(\"\\nPress Enter to continue...\")\n        self.get_insights()\n\n    def _visualize_mood_trends(self):\n        \"\"\"Visualize mood trends over time\"\"\"\n        # Extract dates and moods\n        dates = [datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\") for e in self.entries]\n        moods = [e[\"mood\"] for e in self.entries]\n        energy = [e[\"energy\"] for e in self.entries]\n\n        # Create the visualization\n        plt.figure(figsize=(12, 6))\n        plt.plot(dates, moods, 'b-o', label='Mood')\n        plt.plot(dates, energy, 'r-o', label='Energy')\n        plt.axhline(y=5, color='g', linestyle='--', alpha=0.3, label='Neutral')\n\n        plt.title('Mood and Energy Trends')\n        plt.xlabel('Date')\n        plt.ylabel('Rating (1-10)')\n        plt.grid(True, alpha=0.3)\n        plt.legend()\n\n        # Format the x-axis to show dates nicely\n        plt.gcf().autofmt_xdate()\n\n        # Save the visualization\n        viz_path = os.path.join(self.visualization_dir, f\"mood_trends_{datetime.datetime.now().strftime('%Y%m%d')}.png\")\n        plt.savefig(viz_path)\n\n        print(f\"\\nMood trend visualization saved to: {viz_path}\")\n        print(\"\\nInsights about your mood trends:\")\n\n        # Calculate some basic statistics\n        avg_mood = sum(moods) / len(moods)\n        avg_energy = sum(energy) / len(energy)\n        mood_trend = \"improving\" if moods[-1] &gt; moods[0] else \"declining\" if moods[-1] &lt; moods[0] else \"stable\"\n\n        print(f\"- Your average mood is {avg_mood:.1f}/10\")\n        print(f\"- Your average energy level is {avg_energy:.1f}/10\")\n        print(f\"- Your overall mood trend appears to be {mood_trend}\")\n\n        # Generate AI insights on mood trends\n        if len(self.entries) &gt;= 5:  # Need enough data for meaningful trends\n            entries_text = \"\\n\".join([\n                f\"Date: {e['date']}, Mood: {e['mood']}/10, Energy: {e['energy']}/10, Activities: {', '.join(e['activities'])}\"\n                for e in self.entries[-10:]  # Last 10 entries\n            ])\n\n            prompt = f\"\"\"\n            Here are the user's recent journal entries with mood and energy ratings:\n\n            {entries_text}\n\n            Based on this data, provide:\n            1. Any patterns you notice in their mood and energy levels\n            2. Potential correlations between activities and mood\n            3. A gentle suggestion based on these patterns\n\n            Keep your response concise (150 words max).\n            \"\"\"\n\n            insights = get_response(prompt, \n                                  system=\"You are an analytical journaling assistant who helps identify patterns in mood, energy, and behavior.\")\n\n            print(\"\\nAI Analysis:\")\n            print(insights)\n\n    def _analyze_activity_impact(self):\n        \"\"\"Analyze how different activities impact mood\"\"\"\n        if not any(e.get(\"activities\") for e in self.entries):\n            print(\"\\nNot enough activity data found in your entries.\")\n            return\n\n        # Create a dictionary to track activities and associated moods\n        activity_moods = {}\n\n        # Collect data\n        for entry in self.entries:\n            mood = entry[\"mood\"]\n            for activity in entry.get(\"activities\", []):\n                activity = activity.lower().strip()\n                if activity:\n                    if activity not in activity_moods:\n                        activity_moods[activity] = []\n                    activity_moods[activity].append(mood)\n\n        # Filter to activities with at least 2 data points\n        activity_moods = {k: v for k, v in activity_moods.items() if len(v) &gt;= 2}\n\n        if not activity_moods:\n            print(\"\\nNot enough repeated activities found to analyze impact.\")\n            return\n\n        # Calculate average mood for each activity\n        activity_avg_moods = {activity: sum(moods)/len(moods) \n                             for activity, moods in activity_moods.items()}\n\n        # Sort activities by average mood (highest first)\n        sorted_activities = sorted(activity_avg_moods.items(), \n                                  key=lambda x: x[1], reverse=True)\n\n        # Display results\n        print(\"\\n=== Activity Impact Analysis ===\")\n        print(\"Activities sorted by average mood impact:\")\n\n        for activity, avg_mood in sorted_activities:\n            count = len(activity_moods[activity])\n            print(f\"- {activity.title()}: {avg_mood:.1f}/10 (mentioned {count} times)\")\n\n        # Visualize top activities\n        top_activities = sorted_activities[:min(8, len(sorted_activities))]\n\n        activities = [a[0].title() for a in top_activities]\n        avg_moods = [a[1] for a in top_activities]\n\n        plt.figure(figsize=(10, 6))\n        bars = plt.bar(activities, avg_moods, color='skyblue')\n\n        # Add value labels on top of bars\n        for bar in bars:\n            height = bar.get_height()\n            plt.text(bar.get_x() + bar.get_width()/2., height + 0.1,\n                    f'{height:.1f}', ha='center', va='bottom')\n\n        plt.title('Activities and Their Impact on Mood')\n        plt.xlabel('Activities')\n        plt.ylabel('Average Mood (1-10)')\n        plt.ylim(0, 10.5)  # Set y-axis limit with some padding\n        plt.grid(axis='y', alpha=0.3)\n\n        # Rotate x-axis labels for better readability\n        plt.xticks(rotation=45, ha='right')\n        plt.tight_layout()\n\n        # Save the visualization\n        viz_path = os.path.join(self.visualization_dir, f\"activity_impact_{datetime.datetime.now().strftime('%Y%m%d')}.png\")\n        plt.savefig(viz_path)\n\n        print(f\"\\nActivity impact visualization saved to: {viz_path}\")\n\n        # Generate AI insights\n        activities_text = \"\\n\".join([\n            f\"Activity: {activity}, Average Mood: {avg_mood:.1f}/10, Occurrences: {len(activity_moods[activity])}\"\n            for activity, avg_mood in sorted_activities\n        ])\n\n        prompt = f\"\"\"\n        Here's an analysis of how different activities affect the user's mood:\n\n        {activities_text}\n\n        Based on this data, provide:\n        1. Observations about which activities seem to have the most positive impact\n        2. Suggestions for which activities they might want to prioritize\n        3. A gentle question about their activity patterns\n\n        Keep your response concise (150 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an analytical journaling assistant who helps identify patterns between activities and well-being.\")\n\n        print(\"\\nAI Analysis:\")\n        print(insights)\n\n    def _generate_word_cloud(self):\n        \"\"\"Generate a word frequency analysis of journal entries\"\"\"\n        if not self.entries:\n            print(\"\\nNo journal entries found.\")\n            return\n\n        # Combine all reflections\n        all_text = \" \".join([e[\"reflection\"] for e in self.entries])\n\n        # Remove common stop words (simplified)\n        stop_words = [\"the\", \"and\", \"a\", \"to\", \"of\", \"in\", \"i\", \"it\", \"is\", \"that\", \n                     \"was\", \"for\", \"on\", \"you\", \"he\", \"be\", \"with\", \"as\", \"by\", \"at\", \n                     \"have\", \"are\", \"this\", \"but\", \"not\", \"from\", \"had\", \"has\", \"was\", \n                     \"were\", \"they\", \"will\", \"would\", \"could\", \"should\", \"did\", \"do\",\n                     \"does\", \"their\", \"there\", \"then\", \"than\", \"them\", \"these\", \"those\"]\n\n        # Extract words, convert to lowercase, and remove punctuation\n        words = re.findall(r'\\b[a-zA-Z]+\\b', all_text.lower())\n\n        # Filter out stop words\n        filtered_words = [word for word in words if word not in stop_words and len(word) &gt; 2]\n\n        # Count word frequencies\n        word_counts = Counter(filtered_words)\n\n        # Get the top 20 most frequent words\n        top_words = word_counts.most_common(20)\n\n        # Display results\n        print(\"\\n=== Word Frequency Analysis ===\")\n        print(\"Most common words in your journal:\")\n\n        for word, count in top_words:\n            print(f\"- {word}: {count} occurrences\")\n\n        # Visualize word frequencies\n        words = [w[0] for w in top_words]\n        counts = [w[1] for w in top_words]\n\n        plt.figure(figsize=(12, 6))\n        bars = plt.barh(words[::-1], counts[::-1], color='lightgreen')  # Reverse to show highest at top\n\n        # Add value labels\n        for bar in bars:\n            width = bar.get_width()\n            plt.text(width + 0.5, bar.get_y() + bar.get_height()/2., \n                    f'{width}', ha='left', va='center')\n\n        plt.title('Most Common Words in Journal Entries')\n        plt.xlabel('Frequency')\n        plt.tight_layout()\n\n        # Save the visualization\n        viz_path = os.path.join(self.visualization_dir, f\"word_frequency_{datetime.datetime.now().strftime('%Y%m%d')}.png\")\n        plt.savefig(viz_path)\n\n        print(f\"\\nWord frequency visualization saved to: {viz_path}\")\n\n        # Generate AI insights on themes\n        prompt = f\"\"\"\n        These are the most common words in the user's journal entries:\n\n        {', '.join([f\"{word} ({count})\" for word, count in top_words])}\n\n        Based on these words, please:\n        1. Identify potential themes or patterns in their journaling\n        2. Suggest areas for deeper reflection\n        3. Provide a gentle observation about what these themes might indicate\n\n        Keep your response concise (150 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an insightful journaling assistant who helps identify themes and patterns in journal entries.\")\n\n        print(\"\\nAI Theme Analysis:\")\n        print(insights)\n\n    def _generate_weekly_summary(self):\n        \"\"\"Generate a weekly summary of journal entries\"\"\"\n        # Get entries from the past 7 days\n        today = datetime.datetime.now().date()\n        week_ago = today - datetime.timedelta(days=7)\n\n        weekly_entries = [e for e in self.entries \n                         if datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\").date() &gt;= week_ago]\n\n        if len(weekly_entries) &lt; 2:\n            print(\"\\nNot enough entries in the past week for a meaningful summary.\")\n            return\n\n        # Compile weekly data\n        weekly_moods = [e[\"mood\"] for e in weekly_entries]\n        avg_mood = sum(weekly_moods) / len(weekly_moods)\n\n        weekly_energy = [e[\"energy\"] for e in weekly_entries]\n        avg_energy = sum(weekly_energy) / len(weekly_energy)\n\n        # Get all activities\n        all_activities = []\n        for entry in weekly_entries:\n            all_activities.extend(entry.get(\"activities\", []))\n\n        # Count activity frequencies\n        activity_counts = Counter(all_activities)\n        most_common = activity_counts.most_common(5)\n\n        # Display weekly summary\n        print(\"\\n=== Weekly Summary ===\")\n        print(f\"Period: {week_ago.strftime('%Y-%m-%d')} to {today.strftime('%Y-%m-%d')}\")\n        print(f\"Number of entries: {len(weekly_entries)}\")\n        print(f\"Average mood: {avg_mood:.1f}/10\")\n        print(f\"Average energy: {avg_energy:.1f}/10\")\n\n        if most_common:\n            print(\"\\nMost common activities:\")\n            for activity, count in most_common:\n                print(f\"- {activity}: {count} times\")\n\n        # Generate AI summary\n        entries_text = \"\\n\\n\".join([\n            f\"Date: {e['date']}\\nMood: {e['mood']}/10\\nEnergy: {e['energy']}/10\\n\"\n            f\"Activities: {', '.join(e.get('activities', []))}\\nReflection: {e['reflection']}\"\n            for e in weekly_entries\n        ])\n\n        prompt = f\"\"\"\n        Here's a summary of the user's journal entries for the past week:\n\n        {entries_text}\n\n        Please provide a weekly reflection that includes:\n        1. Notable patterns or trends in their mood and energy\n        2. Observations about activities and their potential impact\n        3. A gentle suggestion for the coming week\n        4. A thoughtful reflection question\n\n        Keep your response concise and supportive (200 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an empathetic journaling assistant who helps provide weekly summaries and insights.\")\n\n        print(\"\\nAI Weekly Reflection:\")\n        print(insights)\n\n    def _generate_monthly_review(self):\n        \"\"\"Generate a monthly review of journal entries\"\"\"\n        # Get entries from the current month\n        today = datetime.datetime.now()\n        first_day = datetime.datetime(today.year, today.month, 1)\n\n        # For previous month, use:\n        # prev_month = first_day - datetime.timedelta(days=1)\n        # first_day = datetime.datetime(prev_month.year, prev_month.month, 1)\n\n        monthly_entries = [e for e in self.entries \n                          if datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\") &gt;= first_day]\n\n        if len(monthly_entries) &lt; 3:\n            print(\"\\nNot enough entries this month for a meaningful review.\")\n            return\n\n        # Compile monthly data\n        monthly_moods = [e[\"mood\"] for e in monthly_entries]\n        avg_mood = sum(monthly_moods) / len(monthly_moods)\n        high_mood = max(monthly_moods)\n        low_mood = min(monthly_moods)\n\n        high_entry = next(e for e in monthly_entries if e[\"mood\"] == high_mood)\n        low_entry = next(e for e in monthly_entries if e[\"mood\"] == low_mood)\n\n        # Get all activities and tags\n        all_activities = []\n        all_tags = []\n        for entry in monthly_entries:\n            all_activities.extend(entry.get(\"activities\", []))\n            all_tags.extend(entry.get(\"tags\", []))\n\n        # Count frequencies\n        activity_counts = Counter(all_activities)\n        tag_counts = Counter(all_tags)\n\n        # Display monthly review\n        print(\"\\n=== Monthly Review ===\")\n        print(f\"Month: {first_day.strftime('%B %Y')}\")\n        print(f\"Number of entries: {len(monthly_entries)}\")\n        print(f\"Average mood: {avg_mood:.1f}/10\")\n        print(f\"Highest mood: {high_mood}/10 on {high_entry['date']}\")\n        print(f\"Lowest mood: {low_mood}/10 on {low_entry['date']}\")\n\n        if activity_counts:\n            print(\"\\nTop activities this month:\")\n            for activity, count in activity_counts.most_common(5):\n                print(f\"- {activity}: {count} times\")\n\n        if tag_counts:\n            print(\"\\nTop themes/tags this month:\")\n            for tag, count in tag_counts.most_common(5):\n                print(f\"- {tag}: {count} times\")\n\n        # Generate AI review\n        entries_summary = \"\\n\".join([\n            f\"Date: {e['date']}, Mood: {e['mood']}/10, Energy: {e['energy']}/10, \"\n            f\"Activities: {', '.join(e.get('activities', []))}, Tags: {', '.join(e.get('tags', []))}\"\n            for e in monthly_entries\n        ])\n\n        prompt = f\"\"\"\n        Here's a summary of the user's journal entries for {first_day.strftime('%B %Y')}:\n\n        {entries_summary}\n\n        Please provide a monthly review that includes:\n        1. Overall patterns in mood and energy\n        2. Key achievements or challenges that stood out\n        3. Activities that seemed most beneficial\n        4. Gentle suggestions for next month\n        5. A thoughtful reflection question\n\n        Keep your response supportive and actionable (250 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an insightful journaling assistant who helps provide monthly reviews and insights.\")\n\n        print(\"\\nAI Monthly Review:\")\n        print(insights)\n\n    def _custom_date_analysis(self):\n        \"\"\"Generate insights for a custom date range\"\"\"\n        print(\"\\n=== Custom Date Range Analysis ===\")\n\n        # Get start date\n        start_date_str = input(\"Enter start date (YYYY-MM-DD): \")\n        try:\n            start_date = datetime.datetime.strptime(start_date_str, \"%Y-%m-%d\").date()\n        except ValueError:\n            print(\"Invalid date format. Using 30 days ago as default.\")\n            start_date = datetime.datetime.now().date() - datetime.timedelta(days=30)\n\n        # Get end date\n        end_date_str = input(\"Enter end date (YYYY-MM-DD) or press Enter for today: \")\n        if end_date_str:\n            try:\n                end_date = datetime.datetime.strptime(end_date_str, \"%Y-%m-%d\").date()\n            except ValueError:\n                print(\"Invalid date format. Using today as default.\")\n                end_date = datetime.datetime.now().date()\n        else:\n            end_date = datetime.datetime.now().date()\n\n        # Validate date range\n        if start_date &gt; end_date:\n            print(\"Start date must be before end date. Swapping dates.\")\n            start_date, end_date = end_date, start_date\n\n        # Filter entries by date range\n        filtered_entries = [e for e in self.entries \n                           if start_date &lt;= datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\").date() &lt;= end_date]\n\n        if len(filtered_entries) &lt; 2:\n            print(f\"\\nNot enough entries between {start_date} and {end_date} for analysis.\")\n            return\n\n        # Display basic stats\n        moods = [e[\"mood\"] for e in filtered_entries]\n        avg_mood = sum(moods) / len(moods)\n\n        print(f\"\\nPeriod: {start_date} to {end_date}\")\n        print(f\"Number of entries: {len(filtered_entries)}\")\n        print(f\"Average mood: {avg_mood:.1f}/10\")\n\n        # Create mood trend visualization\n        dates = [datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\") for e in filtered_entries]\n        moods = [e[\"mood\"] for e in filtered_entries]\n        energy = [e[\"energy\"] for e in filtered_entries]\n\n        plt.figure(figsize=(12, 6))\n        plt.plot(dates, moods, 'b-o', label='Mood')\n        plt.plot(dates, energy, 'r-o', label='Energy')\n        plt.axhline(y=5, color='g', linestyle='--', alpha=0.3, label='Neutral')\n\n        plt.title(f'Mood and Energy Trends ({start_date} to {end_date})')\n        plt.xlabel('Date')\n        plt.ylabel('Rating (1-10)')\n        plt.grid(True, alpha=0.3)\n        plt.legend()\n\n        # Format the x-axis to show dates nicely\n        plt.gcf().autofmt_xdate()\n        plt.tight_layout()\n\n        # Save the visualization\n        viz_path = os.path.join(self.visualization_dir, \n                              f\"custom_trend_{start_date}_{end_date}.png\")\n        plt.savefig(viz_path)\n\n        print(f\"\\nCustom trend visualization saved to: {viz_path}\")\n\n        # Generate AI insights\n        entries_summary = \"\\n\".join([\n            f\"Date: {e['date']}, Mood: {e['mood']}/10, Energy: {e['energy']}/10, \"\n            f\"Activities: {', '.join(e.get('activities', []))}, Reflection: {e['reflection'][:100]}...\"\n            for e in filtered_entries\n        ])\n\n        prompt = f\"\"\"\n        Here's a summary of the user's journal entries from {start_date} to {end_date}:\n\n        {entries_summary}\n\n        Please provide a custom period analysis that includes:\n        1. Notable trends or patterns in mood and energy\n        2. Key themes or recurring topics\n        3. Activities that appeared to influence mood\n        4. A thoughtful observation about this period\n\n        Keep your response insightful and supportive (200 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an analytical journaling assistant who helps identify patterns across custom time periods.\")\n\n        print(\"\\nAI Period Analysis:\")\n        print(insights)\n\n    def manage_prompts(self):\n        \"\"\"Manage custom prompts\"\"\"\n        print(\"\\n=== Manage Custom Prompts ===\")\n        print(\"1. View all prompts\")\n        print(\"2. Add new prompt\")\n        print(\"3. Delete prompt\")\n        print(\"4. Return to main menu\")\n\n        choice = input(\"\\nWhat would you like to do? (1-4): \")\n\n        if choice == \"1\":\n            # View all prompts\n            print(\"\\n=== Available Prompts ===\")\n            print(\"Default prompts:\")\n            for i, prompt in enumerate(self.default_prompts, 1):\n                print(f\"{i}. {prompt}\")\n\n            if self.custom_prompts:\n                print(\"\\nCustom prompts:\")\n                for i, prompt in enumerate(self.custom_prompts, 1):\n                    print(f\"{i}. {prompt}\")\n            else:\n                print(\"\\nNo custom prompts yet.\")\n\n        elif choice == \"2\":\n            # Add new prompt\n            new_prompt = input(\"\\nEnter a new journal prompt: \")\n            if new_prompt:\n                self.custom_prompts.append(new_prompt)\n                self._save_custom_prompts()\n                print(\"Custom prompt added successfully!\")\n\n        elif choice == \"3\":\n            # Delete prompt\n            if not self.custom_prompts:\n                print(\"\\nNo custom prompts to delete.\")\n                self.manage_prompts()\n                return\n\n            print(\"\\nCustom prompts:\")\n            for i, prompt in enumerate(self.custom_prompts, 1):\n                print(f\"{i}. {prompt}\")\n\n            try:\n                idx = int(input(\"\\nEnter the number of the prompt to delete: \")) - 1\n                if 0 &lt;= idx &lt; len(self.custom_prompts):\n                    deleted = self.custom_prompts.pop(idx)\n                    self._save_custom_prompts()\n                    print(f\"Deleted prompt: {deleted}\")\n                else:\n                    print(\"Invalid prompt number.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        elif choice == \"4\":\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # Return to prompt management menu\n        self.manage_prompts()\n\n    def set_goals(self):\n        \"\"\"Set goals and intentions\"\"\"\n        print(\"\\n=== Goals and Intentions ===\")\n        print(\"1. View current goals\")\n        print(\"2. Add new goal\")\n        print(\"3. Update goal progress\")\n        print(\"4. Delete goal\")\n        print(\"5. Generate goal suggestions\")\n        print(\"6. Return to main menu\")\n\n        # Load goals from file\n        goals_file = os.path.join(self.journal_dir, \"goals.json\")\n        if os.path.exists(goals_file):\n            try:\n                with open(goals_file, 'r') as f:\n                    goals = json.load(f)\n            except json.JSONDecodeError:\n                goals = []\n        else:\n            goals = []\n\n        choice = input(\"\\nWhat would you like to do? (1-6): \")\n\n        if choice == \"1\":\n            # View current goals\n            if not goals:\n                print(\"\\nNo goals found.\")\n            else:\n                print(\"\\n=== Current Goals ===\")\n                for i, goal in enumerate(goals, 1):\n                    status = f\"{goal['progress']}% complete\" if 'progress' in goal else \"Not started\"\n                    target_date = goal.get('target_date', 'No target date')\n                    print(f\"{i}. {goal['description']} - {status} - Target: {target_date}\")\n\n                    if 'milestones' in goal and goal['milestones']:\n                        print(\"   Milestones:\")\n                        for m in goal['milestones']:\n                            check = \"\u2713\" if m.get('completed', False) else \"\u25cb\"\n                            print(f\"   {check} {m['description']}\")\n\n        elif choice == \"2\":\n            # Add new goal\n            print(\"\\n=== Add New Goal ===\")\n            description = input(\"Goal description: \")\n            if not description:\n                print(\"Goal description cannot be empty.\")\n                self.set_goals()\n                return\n\n            target_date = input(\"Target date (YYYY-MM-DD) or leave blank: \")\n            if target_date:\n                try:\n                    # Validate date format\n                    datetime.datetime.strptime(target_date, \"%Y-%m-%d\")\n                except ValueError:\n                    print(\"Invalid date format. Using no target date.\")\n                    target_date = \"\"\n\n            # Create goal object\n            goal = {\n                \"description\": description,\n                \"created_date\": datetime.datetime.now().strftime(\"%Y-%m-%d\"),\n                \"progress\": 0\n            }\n\n            if target_date:\n                goal[\"target_date\"] = target_date\n\n            # Ask for milestones\n            add_milestones = input(\"Would you like to add milestones? (y/n): \").lower()\n            if add_milestones == 'y':\n                milestones = []\n                while True:\n                    milestone = input(\"Enter milestone (or leave blank to finish): \")\n                    if not milestone:\n                        break\n                    milestones.append({\"description\": milestone, \"completed\": False})\n\n                if milestones:\n                    goal[\"milestones\"] = milestones\n\n            # Add goal to list and save\n            goals.append(goal)\n            with open(goals_file, 'w') as f:\n                json.dump(goals, f, indent=2)\n\n            print(\"Goal added successfully!\")\n\n        elif choice == \"3\":\n            # Update goal progress\n            if not goals:\n                print(\"\\nNo goals found.\")\n                self.set_goals()\n                return\n\n            print(\"\\n=== Update Goal Progress ===\")\n            for i, goal in enumerate(goals, 1):\n                status = f\"{goal['progress']}% complete\" if 'progress' in goal else \"Not started\"\n                print(f\"{i}. {goal['description']} - {status}\")\n\n            try:\n                idx = int(input(\"\\nEnter the number of the goal to update: \")) - 1\n                if 0 &lt;= idx &lt; len(goals):\n                    goal = goals[idx]\n\n                    print(f\"\\nUpdating goal: {goal['description']}\")\n\n                    # Update progress\n                    try:\n                        new_progress = int(input(f\"Enter new progress (0-100) [current: {goal.get('progress', 0)}%]: \"))\n                        if 0 &lt;= new_progress &lt;= 100:\n                            goal['progress'] = new_progress\n                        else:\n                            print(\"Progress must be between 0 and 100.\")\n                    except ValueError:\n                        print(\"Invalid input. Progress not updated.\")\n\n                    # Update milestones if they exist\n                    if 'milestones' in goal and goal['milestones']:\n                        print(\"\\nUpdate milestones:\")\n                        for i, milestone in enumerate(goal['milestones'], 1):\n                            status = \"Completed\" if milestone.get('completed', False) else \"Not completed\"\n                            print(f\"{i}. {milestone['description']} - {status}\")\n\n                            update = input(f\"Mark as {'not ' if milestone.get('completed', False) else ''}completed? (y/n): \").lower()\n                            if update == 'y':\n                                milestone['completed'] = not milestone.get('completed', False)\n\n                    # Save updated goals\n                    with open(goals_file, 'w') as f:\n                        json.dump(goals, f, indent=2)\n\n                    print(\"Goal updated successfully!\")\n                else:\n                    print(\"Invalid goal number.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        elif choice == \"4\":\n            # Delete goal\n            if not goals:\n                print(\"\\nNo goals found.\")\n                self.set_goals()\n                return\n\n            print(\"\\n=== Delete Goal ===\")\n            for i, goal in enumerate(goals, 1):\n                print(f\"{i}. {goal['description']}\")\n\n            try:\n                idx = int(input(\"\\nEnter the number of the goal to delete: \")) - 1\n                if 0 &lt;= idx &lt; len(goals):\n                    goal = goals.pop(idx)\n\n                    # Save updated goals\n                    with open(goals_file, 'w') as f:\n                        json.dump(goals, f, indent=2)\n\n                    print(f\"Goal '{goal['description']}' deleted successfully!\")\n                else:\n                    print(\"Invalid goal number.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        elif choice == \"5\":\n            # Generate goal suggestions\n            if not self.entries or len(self.entries) &lt; 5:\n                print(\"\\nNot enough journal entries to generate meaningful goal suggestions.\")\n                self.set_goals()\n                return\n\n            print(\"\\nGenerating goal suggestions based on your journal entries...\")\n\n            # Get recent entries\n            recent_entries = self.entries[-15:]  # Last 15 entries\n            entries_text = \"\\n\\n\".join([\n                f\"Date: {e['date']}\\nMood: {e['mood']}/10\\nActivities: {', '.join(e.get('activities', []))}\\n\"\n                f\"Tags: {', '.join(e.get('tags', []))}\\nReflection: {e['reflection']}\"\n                for e in recent_entries\n            ])\n\n            prompt = f\"\"\"\n            Here are some recent journal entries from the user:\n\n            {entries_text}\n\n            Based on these entries, suggest 3-5 meaningful goals or intentions that might help the user's wellbeing or personal growth. For each goal:\n            1. Provide a clear, actionable description\n            2. Explain briefly why this goal might be beneficial (based on patterns in their journal)\n            3. Suggest 2-3 possible milestones for the goal\n\n            Make the goals specific, measurable, and aligned with what seems to matter to the user.\n            \"\"\"\n\n            suggestions = get_response(prompt, \n                                     system=\"You are a supportive goal-setting assistant who helps users identify meaningful goals based on their journal patterns.\")\n\n            print(\"\\n=== Goal Suggestions ===\")\n            print(suggestions)\n\n        elif choice == \"6\":\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # Return to goals menu\n        self.set_goals()\n\n    def set_preferences(self):\n        \"\"\"Set user preferences\"\"\"\n        print(\"\\n=== Preferences ===\")\n        print(f\"1. Auto-generate insights: {self.preferences['auto_insights']}\")\n        print(f\"2. Daily reminder: {self.preferences['daily_reminder']}\")\n        print(f\"3. Reminder time: {self.preferences['reminder_time']}\")\n        print(f\"4. Theme: {self.preferences['theme']}\")\n        print(f\"5. Insight frequency: {self.preferences['insight_frequency']}\")\n        print(\"6. Return to main menu\")\n\n        choice = input(\"\\nWhat would you like to change? (1-6): \")\n\n        if choice == \"1\":\n            # Toggle auto-insights\n            self.preferences['auto_insights'] = not self.preferences['auto_insights']\n            print(f\"Auto-generate insights: {self.preferences['auto_insights']}\")\n\n        elif choice == \"2\":\n            # Toggle daily reminder\n            self.preferences['daily_reminder'] = not self.preferences['daily_reminder']\n            print(f\"Daily reminder: {self.preferences['daily_reminder']}\")\n\n        elif choice == \"3\":\n            # Set reminder time\n            time_str = input(\"Enter reminder time (HH:MM): \")\n            try:\n                # Validate time format\n                datetime.datetime.strptime(time_str, \"%H:%M\")\n                self.preferences['reminder_time'] = time_str\n                print(f\"Reminder time set to: {time_str}\")\n            except ValueError:\n                print(\"Invalid time format. Using previous setting.\")\n\n        elif choice == \"4\":\n            # Set theme\n            print(\"\\nAvailable themes:\")\n            themes = [\"standard\", \"dark\", \"light\", \"colorful\"]\n            for i, theme in enumerate(themes, 1):\n                print(f\"{i}. {theme}\")\n\n            try:\n                idx = int(input(\"\\nSelect theme number: \")) - 1\n                if 0 &lt;= idx &lt; len(themes):\n                    self.preferences['theme'] = themes[idx]\n                    print(f\"Theme set to: {themes[idx]}\")\n                else:\n                    print(\"Invalid theme number.\")\n            except ValueError:\n                print(\"Invalid input. Theme not changed.\")\n\n        elif choice == \"5\":\n            # Set insight frequency\n            print(\"\\nInsight frequency options:\")\n            frequencies = [\"daily\", \"weekly\", \"monthly\"]\n            for i, freq in enumerate(frequencies, 1):\n                print(f\"{i}. {freq}\")\n\n            try:\n                idx = int(input(\"\\nSelect frequency number: \")) - 1\n                if 0 &lt;= idx &lt; len(frequencies):\n                    self.preferences['insight_frequency'] = frequencies[idx]\n                    print(f\"Insight frequency set to: {frequencies[idx]}\")\n                else:\n                    print(\"Invalid frequency number.\")\n            except ValueError:\n                print(\"Invalid input. Frequency not changed.\")\n\n        elif choice == \"6\":\n            self._save_preferences()\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # Save preferences after any change\n        self._save_preferences()\n\n        # Return to preferences menu\n        self.set_preferences()\n\n    def export_journal(self):\n        \"\"\"Export journal to different formats\"\"\"\n        if not self.entries:\n            print(\"\\nNo journal entries to export.\")\n            input(\"\\nPress Enter to continue...\")\n            self.display_menu()\n            return\n\n        print(\"\\n=== Export Journal ===\")\n        print(\"1. Export as text file\")\n        print(\"2. Export as CSV\")\n        print(\"3. Export as PDF (plain)\")\n        print(\"4. Export with visualizations\")\n        print(\"5. Return to main menu\")\n\n        choice = input(\"\\nChoose export format (1-5): \")\n\n        if choice == \"1\":\n            # Export as text\n            export_path = os.path.join(self.journal_dir, f\"journal_export_{datetime.datetime.now().strftime('%Y%m%d')}.txt\")\n\n            with open(export_path, 'w') as f:\n                f.write(\"===== JOURNAL EXPORT =====\\n\\n\")\n\n                for entry in sorted(self.entries, key=lambda e: e[\"date\"]):\n                    f.write(f\"Date: {entry['date']} at {entry.get('time', '00:00')}\\n\")\n                    f.write(f\"Mood: {entry['mood']}/10 - {entry.get('mood_label', '')}\\n\")\n                    f.write(f\"Energy: {entry.get('energy', 'N/A')}/10\\n\\n\")\n                    f.write(f\"Prompt: {entry.get('prompt', 'No prompt')}\\n\\n\")\n                    f.write(f\"Reflection:\\n{entry['reflection']}\\n\\n\")\n\n                    if entry.get('activities'):\n                        f.write(f\"Activities: {', '.join(entry['activities'])}\\n\")\n\n                    if entry.get('tags'):\n                        f.write(f\"Tags: {', '.join(entry['tags'])}\\n\")\n\n                    f.write(\"\\n\" + \"=\" * 50 + \"\\n\\n\")\n\n            print(f\"\\nJournal exported to: {export_path}\")\n\n        elif choice == \"2\":\n            # Export as CSV\n            export_path = os.path.join(self.journal_dir, f\"journal_export_{datetime.datetime.now().strftime('%Y%m%d')}.csv\")\n\n            with open(export_path, 'w') as f:\n                # Write header\n                f.write(\"date,time,mood,energy,prompt,reflection,activities,tags\\n\")\n\n                # Write entries\n                for entry in self.entries:\n                    date = entry['date']\n                    time = entry.get('time', '')\n                    mood = entry['mood']\n                    energy = entry.get('energy', '')\n                    prompt = entry.get('prompt', '').replace('\"', '\"\"')\n                    reflection = entry['reflection'].replace('\"', '\"\"').replace('\\n', ' ')\n                    activities = \"|\".join(entry.get('activities', []))\n                    tags = \"|\".join(entry.get('tags', []))\n\n                    f.write(f'\"{date}\",\"{time}\",{mood},{energy},\"{prompt}\",\"{reflection}\",\"{activities}\",\"{tags}\"\\n')\n\n            print(f\"\\nJournal exported to: {export_path}\")\n\n        elif choice == \"3\" or choice == \"4\":\n            # Export as PDF (would require additional libraries like reportlab)\n            print(\"\\nPDF export would require additional libraries not included in this example.\")\n            print(\"In a full implementation, this would generate a formatted PDF document.\")\n\n        elif choice == \"5\":\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # Return to export menu\n        input(\"\\nPress Enter to continue...\")\n        self.export_journal()\n\n    def exit_app(self):\n        \"\"\"Exit the application\"\"\"\n        print(\"\\nThank you for using Advanced Journal Assistant. Goodbye!\")\n        exit()\n\ndef main():\n    \"\"\"Main function to run the application\"\"\"\n    journal = AdvancedJournalAssistant()\n    journal.display_menu()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"mini-projects/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Data Visualization Enhancements: Add interactive visualizations using libraries like Plotly or Bokeh</li> <li>Natural Language Processing: Implement sentiment analysis to automatically detect the emotional tone of entries</li> <li>Machine Learning Integration: Build a recommendation system that suggests activities based on past mood correlations</li> <li>Multiple Journaling Modes: Add specialized templates for gratitude journaling, goal tracking, habit formation, etc.</li> <li>Social Features: Add optional sharing of insights (anonymized) with trusted friends or mentors</li> <li>Integrations: Connect with other applications like calendar, fitness trackers, or meditation apps</li> <li>Mobile Compatibility: Create a companion mobile app for on-the-go journaling</li> <li>Voice Journaling: Add speech-to-text functionality for verbal journaling</li> <li>Export Options: Enhanced export formats including PDF with embedded visualizations, interactive web formats</li> <li>Cloud Sync: Add secure cloud synchronization for access across multiple devices</li> <li>Guided Journaling Sessions: AI-guided journaling sessions focused on specific topics or goals</li> </ul>"},{"location":"mini-projects/#bot-personality-menu-generator","title":"Bot Personality Menu Generator","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: Dictionaries, functions, menu systems</p>"},{"location":"mini-projects/#overview_1","title":"Overview","text":"<p>Create a flexible menu system that allows users to interact with multiple bot personalities on demand, practicing dictionary management, function mappings, and user interface design.</p>"},{"location":"mini-projects/#instructions_1","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef personality_menu():\n    print(\"=== Bot Personality Menu Generator ===\")\n    print(\"Interact with various bot personalities!\")\n    print(\"Type 'exit' at any time to quit.\\n\")\n\n    # Define different bot personalities\n    def friendly_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a friendly, helpful assistant who is always positive and encouraging. You use warm language and provide supportive responses.\"\n        )\n\n    def emoji_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are an emoji enthusiast who includes multiple relevant emojis in every response. Your tone is upbeat and playful. Make sure to use at least 3-5 emojis in each message.\"\n        )\n\n    def pirate_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a salty pirate captain from the Golden Age of Piracy. You speak with pirate slang (arr, matey, avast, etc.) and make frequent references to sailing, treasure, and the sea. Your responses are brief and colorful.\"\n        )\n\n    def teacher_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a patient, knowledgeable teacher who explains concepts clearly. You break down complex ideas into simple terms and use examples to illustrate points. Your tone is educational but never condescending.\"\n        )\n\n    def detective_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a sharp-witted detective with keen analytical skills. You approach every question like a mystery to solve, looking for clues and making deductions. Your tone is contemplative and slightly dramatic, similar to classic detective novels.\"\n        )\n\n    def poet_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a lyrical poet who often speaks in verse or uses metaphorical language. Your responses are thoughtful and artistic, with attention to the rhythm and beauty of language. Occasionally include short poems in your responses.\"\n        )\n\n    # Store bot functions in a dictionary for easy access\n    bots = {\n        \"1\": {\"name\": \"Friendly Assistant\", \"function\": friendly_bot, \"description\": \"Warm and supportive\"},\n        \"2\": {\"name\": \"Emoji Enthusiast\", \"function\": emoji_bot, \"description\": \"Playful with lots of emojis\"},\n        \"3\": {\"name\": \"Pirate Captain\", \"function\": pirate_bot, \"description\": \"Salty sea dog with nautical flair\"},\n        \"4\": {\"name\": \"Wise Teacher\", \"function\": teacher_bot, \"description\": \"Patient and educational\"},\n        \"5\": {\"name\": \"Detective\", \"function\": detective_bot, \"description\": \"Analytical problem-solver\"},\n        \"6\": {\"name\": \"Poet\", \"function\": poet_bot, \"description\": \"Lyrical and metaphorical\"}\n    }\n\n    # Function to display the menu\n    def show_menu():\n        print(\"\\n=== Available Bot Personalities ===\")\n        for key, bot_info in bots.items():\n            print(f\"{key}. {bot_info['name']} - {bot_info['description']}\")\n        print(\"7. Exit\")\n\n    # Main interaction loop\n    current_bot = None\n    current_bot_name = None\n\n    while True:\n        if current_bot is None:\n            show_menu()\n            choice = input(\"\\nSelect a bot personality (1-7): \")\n\n            # Exit condition\n            if choice == \"7\" or choice.lower() == \"exit\":\n                print(\"Thanks for using the Bot Personality Menu! Goodbye!\")\n                break\n\n            if choice in bots:\n                current_bot = bots[choice][\"function\"]\n                current_bot_name = bots[choice][\"name\"]\n                print(f\"\\nYou're now chatting with the {current_bot_name}!\")\n\n                # Welcome message from the selected bot\n                welcome = current_bot(\"Give a brief introduction of yourself.\")\n                print(f\"{current_bot_name}: {welcome}\")\n            else:\n                print(\"Invalid choice. Please select a number from 1-7.\")\n                continue\n\n        # Interaction with the current bot\n        user_input = input(\"\\nYou: \")\n\n        # Check for exit or menu commands\n        if user_input.lower() == \"exit\":\n            print(\"Thanks for using the Bot Personality Menu! Goodbye!\")\n            break\n        elif user_input.lower() == \"menu\":\n            current_bot = None\n            continue\n\n        # Get response from the current bot\n        response = current_bot(user_input)\n        print(f\"\\n{current_bot_name}: {response}\")\n\n        # Option to change bots\n        print(\"\\nType 'menu' to switch bots or 'exit' to quit\")\n\n# Run the personality menu\nif __name__ == \"__main__\":\n    personality_menu()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_1","title":"Extension Ideas","text":"<ul> <li>Allow users to create and save their own custom bot personalities</li> <li>Add a \"random\" option that selects a personality at random</li> <li>Create a rating system where users can score responses</li> <li>Implement a \"conversation history\" feature that remembers past interactions</li> <li>Create themed conversation scenarios for different bot personalities</li> </ul>"},{"location":"mini-projects/#build-your-own-personality-bot","title":"Build Your Own Personality Bot","text":"<p>Difficulty: Beginner Time: 30-45 minutes Learning Focus: Functions, system prompts, creative writing</p>"},{"location":"mini-projects/#overview_2","title":"Overview","text":"<p>Create a new bot personality that responds in a unique way \u2014 like a movie character, animal, celebrity, or completely invented creature. Students will learn how to craft system prompts that reflect specific voices or styles.</p>"},{"location":"mini-projects/#instructions_2","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\n# Example bot personality\ndef cat_bot(prompt):\n    return get_response(\n        prompt, \n        system=\"You are a lazy cat who answers everything with sass, yawns, or meows.\"\n    )\n\n# Create your own unique bot personality\ndef custom_bot(prompt):\n    return get_response(\n        prompt,\n        system=\"You are a [personality type] who [describes behavior/speaking style].\"\n    )\n\n# Test your bot with different prompts\ntest_prompts = [\n    \"What's the weather like today?\",\n    \"Explain quantum physics to me.\",\n    \"What should I do this weekend?\",\n    \"Tell me a joke.\"\n]\n\n# Choose which bot to use\nmy_bot = cat_bot  # Replace with your custom bot\n\n# Test with each prompt\nfor prompt in test_prompts:\n    print(f\"User: {prompt}\")\n    print(f\"Bot: {my_bot(prompt)}\")\n    print(\"-\" * 50)\n\n# You can also create a short conversation script\nconversation = [\n    \"Hello there!\",\n    \"What's your favorite food?\",\n    \"Tell me something interesting about yourself.\",\n    \"Goodbye!\"\n]\n\nprint(\"\\n=== Conversation with Bot ===\\n\")\nfor prompt in conversation:\n    print(f\"User: {prompt}\")\n    print(f\"Bot: {my_bot(prompt)}\")\n    print()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_2","title":"Extension Ideas","text":"<ul> <li>Create multiple personalities and compare how they respond to the same questions</li> <li>Hold a \"bot showcase\" where students introduce their bots to the class</li> <li>Design a bot personality based on a character from literature the class is studying</li> <li>Create a bot with a specific expertise or profession (scientist, chef, historian)</li> </ul>"},{"location":"mini-projects/#choose-your-own-adventure","title":"Choose Your Own Adventure","text":"<p>Difficulty: Intermediate Time: 60-90 minutes Learning Focus: State management, narrative design, user input handling</p>"},{"location":"mini-projects/#overview_3","title":"Overview","text":"<p>Create an interactive story where the bot generates narrative segments based on user choices.</p>"},{"location":"mini-projects/#instructions_3","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef adventure_game():\n    \"\"\"Interactive Choose Your Own Adventure game powered by an LLM\"\"\"\n    # Story state tracking\n    story_context = {\n        \"setting\": \"\",\n        \"character\": \"\",\n        \"inventory\": [],\n        \"goals\": [],\n        \"events\": []\n    }\n\n    print(\"=== Choose Your Own Adventure Generator ===\")\n    print(\"Let's create your custom adventure!\\n\")\n\n    # Get initial story parameters\n    setting_options = [\"fantasy kingdom\", \"space station\", \"haunted mansion\", \n                       \"prehistoric world\", \"cyberpunk city\", \"desert island\"]\n\n    print(\"Choose a setting:\")\n    for i, setting in enumerate(setting_options):\n        print(f\"{i+1}. {setting}\")\n\n    setting_choice = int(input(\"\\nSetting (1-6): \")) - 1\n    story_context[\"setting\"] = setting_options[setting_choice]\n\n    character_type = input(\"\\nWhat type of character do you want to play? \")\n    story_context[\"character\"] = character_type\n\n    goal = input(\"\\nWhat is your character's main goal? \")\n    story_context[\"goals\"].append(goal)\n\n    # Generate story intro\n    story_prompt = f\"\"\"\n    Create the introduction to an interactive adventure story with these details:\n    - Setting: {story_context['setting']}\n    - Main character: {story_context['character']}\n    - Character's goal: {story_context['goals'][0]}\n\n    End with exactly two choices the player can make.\n    Format the choices as:\n    CHOICE 1: (first option)\n    CHOICE 2: (second option)\n    \"\"\"\n\n    story_system = \"\"\"\n    You are a creative storyteller crafting an interactive adventure.\n    Create vivid descriptions and meaningful choices.\n    For each story segment, provide exactly two choices for the player.\n    \"\"\"\n\n    # Generate and print first segment\n    current_segment = get_response(story_prompt, system=story_system)\n    print(\"\\n=== Your Adventure Begins ===\\n\")\n\n    # Split segment from choices\n    parts = current_segment.split(\"CHOICE 1:\")\n    narrative = parts[0].strip()\n    choices = \"CHOICE 1:\" + parts[1]\n\n    print(narrative + \"\\n\")\n    print(choices)\n\n    # Story loop\n    turns = 0\n    max_turns = 5\n\n    while turns &lt; max_turns:\n        choice = input(\"\\nEnter 1 or 2 to choose: \")\n\n        if choice not in [\"1\", \"2\"]:\n            print(\"Please enter 1 or 2.\")\n            continue\n\n        # Add to story context\n        if choice == \"1\":\n            chosen_option = choices.split(\"CHOICE 1:\")[1].split(\"CHOICE 2:\")[0].strip()\n        else:\n            chosen_option = choices.split(\"CHOICE 2:\")[1].strip()\n\n        story_context[\"events\"].append(chosen_option)\n\n        # Generate next segment based on choice and story so far\n        context_summary = f\"\"\"\n        Setting: {story_context['setting']}\n        Character: {story_context['character']}\n        Goal: {story_context['goals'][0]}\n        Previous events: {' '.join(story_context['events'])}\n        \"\"\"\n\n        continuation_prompt = f\"\"\"\n        Continue the story based on these details:\n        {context_summary}\n\n        The player just chose: {chosen_option}\n\n        Continue the story from there and provide two new choices.\n        End with:\n        CHOICE 1: (first option)\n        CHOICE 2: (second option)\n        \"\"\"\n\n        # Generate next segment\n        next_segment = get_response(continuation_prompt, system=story_system)\n        print(\"\\n\" + \"=\"*50 + \"\\n\")\n\n        # Split segment from choices\n        parts = next_segment.split(\"CHOICE 1:\")\n        narrative = parts[0].strip()\n\n        # Check if we've reached the ending\n        if \"CHOICE 1:\" not in next_segment:\n            print(next_segment)\n            print(\"\\n=== The End ===\")\n            break\n\n        choices = \"CHOICE 1:\" + parts[1]\n\n        print(narrative + \"\\n\")\n        print(choices)\n\n        turns += 1\n\n        # Final turn\n        if turns &gt;= max_turns:\n            # Generate conclusion\n            conclusion_prompt = f\"\"\"\n            Create a satisfying conclusion to the story based on these details:\n            {context_summary}\n\n            The player just chose: {chosen_option}\n\n            Write a final paragraph that wraps up the adventure.\n            \"\"\"\n\n            conclusion = get_response(conclusion_prompt, system=story_system)\n\n            print(\"\\n\" + \"=\"*50 + \"\\n\")\n            print(conclusion)\n            print(\"\\n=== The End ===\")\n\n    print(\"\\nThanks for playing!\")\n\n# Run the adventure game\nif __name__ == \"__main__\":\n    adventure_game()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_3","title":"Extension Ideas","text":"<p>Add inventory management, character stats, or multiple endings based on decisions.</p>"},{"location":"mini-projects/#classroom-simulation-bot","title":"Classroom Simulation Bot","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: Functions, menu systems, multiple bot use</p>"},{"location":"mini-projects/#overview_4","title":"Overview","text":"<p>Create a classroom simulation where students can interact with different characters or experts on various topics, practicing both coding skills and exploring different perspectives.</p>"},{"location":"mini-projects/#instructions_4","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef classroom_simulation():\n    print(\"=== Virtual Classroom Simulation ===\")\n    print(\"Ask questions to different characters about any topic!\")\n    print(\"Type 'exit' at any time to quit.\\n\")\n\n    # Define different bot personalities\n    def teacher_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a knowledgeable, patient teacher who explains concepts clearly with examples. You encourage critical thinking and use analogies to simplify complex ideas. Keep explanations concise but thorough.\"\n        )\n\n    def hacker_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are an ethical hacker with expertise in cybersecurity. You explain technical concepts with a slightly rebellious attitude but always emphasize ethical practices and security. Never provide instructions for illegal activities. Use technical terminology but explain it.\"\n        )\n\n    def pirate_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a pirate captain from the Golden Age of Piracy. You speak with pirate slang and terminology (arr, matey, etc.). Despite your rough manner, you're surprisingly knowledgeable about navigation, history, and seafaring. Keep responses brief and entertaining.\"\n        )\n\n    def scientist_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a brilliant scientist who is excited about all fields of science. You explain scientific concepts with enthusiasm and wonder, citing relevant research and discoveries. You are factual and precise but can make complex ideas accessible.\"\n        )\n\n    # Display available characters\n    def show_menu():\n        print(\"\\n=== Available Characters ===\")\n        print(\"1. Teacher - Clear explanations and educational guidance\")\n        print(\"2. Hacker - Cybersecurity and tech knowledge with attitude\")\n        print(\"3. Pirate - Nautical expertise with a swashbuckling style\")\n        print(\"4. Scientist - Enthusiastic scientific explanations\")\n        print(\"5. Exit simulation\")\n\n    # Main interaction loop\n    while True:\n        show_menu()\n        choice = input(\"\\nChoose a character (1-5): \")\n\n        # Exit condition\n        if choice == \"5\" or choice.lower() == \"exit\":\n            print(\"Exiting the classroom simulation. Thanks for participating!\")\n            break\n\n        # Select the appropriate bot based on user choice\n        if choice == \"1\":\n            bot = teacher_bot\n            name = \"Teacher\"\n        elif choice == \"2\":\n            bot = hacker_bot\n            name = \"Hacker\"\n        elif choice == \"3\":\n            bot = pirate_bot\n            name = \"Pirate Captain\"\n        elif choice == \"4\":\n            bot = scientist_bot\n            name = \"Scientist\"\n        else:\n            print(\"Invalid choice. Please enter a number from 1-5.\")\n            continue\n\n        # Get the question from the user\n        question = input(f\"\\nWhat would you like to ask the {name}? \")\n\n        # Exit condition\n        if question.lower() == \"exit\":\n            print(\"Exiting the classroom simulation. Thanks for participating!\")\n            break\n\n        # Get the response from the selected bot\n        print(f\"\\n{name}:\")\n        response = bot(question)\n        print(response)\n\n        # Ask if they want to ask another question to the same character\n        while True:\n            another = input(f\"\\nWould you like to ask the {name} another question? (yes/no): \").lower()\n\n            if another == \"no\" or another == \"exit\":\n                break\n            elif another == \"yes\":\n                question = input(f\"\\nWhat's your next question for the {name}? \")\n\n                # Exit condition\n                if question.lower() == \"exit\":\n                    print(\"Exiting the classroom simulation. Thanks for participating!\")\n                    return\n\n                print(f\"\\n{name}:\")\n                response = bot(question)\n                print(response)\n            else:\n                print(\"Please answer 'yes' or 'no'.\")\n\n# Run the classroom simulation\nif __name__ == \"__main__\":\n    classroom_simulation()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_4","title":"Extension Ideas","text":"<ul> <li>Add more character types like historian, artist, or fictional character</li> <li>Create a debate mode where two characters discuss the same topic</li> <li>Add a quiz feature where characters test the user's knowledge</li> <li>Create a storyline or scenario that involves multiple characters</li> <li>Allow characters to \"remember\" previous interactions in the session</li> </ul>"},{"location":"mini-projects/#code-explainer-tool","title":"Code Explainer Tool","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: Code analysis, documentation</p>"},{"location":"mini-projects/#overview_5","title":"Overview","text":"<p>Create a tool that explains code snippets and helps users understand programming concepts.</p>"},{"location":"mini-projects/#instructions_5","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport sys\n\ndef code_explainer():\n    \"\"\"Tool to explain code and help with programming concepts\"\"\"\n    print(\"=== Code Explainer Tool ===\")\n    print(\"1. Explain a code snippet\")\n    print(\"2. Simplify complex code\")\n    print(\"3. Debug problematic code\")\n    print(\"4. Learn a programming concept\")\n\n    choice = input(\"\\nWhat would you like to do? \")\n\n    if choice == \"1\":\n        # Explain code\n        print(\"\\nPaste your code snippet below (type 'DONE' on a new line when finished):\")\n        code_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            code_lines.append(line)\n\n        code = \"\\n\".join(code_lines)\n\n        detail_level = input(\"\\nExplanation detail (brief/detailed/step-by-step): \")\n        audience = input(\"Target audience (beginner/intermediate/advanced): \")\n\n        system_prompt = f\"\"\"\n        You are an expert programming tutor specializing in code explanation.\n        You break down code in a way that's understandable to {audience} programmers.\n        You provide {detail_level} explanations that help users truly understand the code.\n        \"\"\"\n\n        explain_prompt = f\"\"\"\n        Explain this code:\n        ```\n        {code}\n        ```\n\n        Provide a {detail_level} explanation suitable for a {audience} programmer.\n        If possible, identify:\n        1. The programming language\n        2. What the code does\n        3. Key concepts it demonstrates\n        4. Any potential issues or improvements\n        \"\"\"\n\n        print(\"\\nAnalyzing code...\")\n        explanation = get_response(explain_prompt, system=system_prompt)\n\n        print(\"\\n=== Code Explanation ===\")\n        print(explanation)\n\n    elif choice == \"2\":\n        # Simplify complex code\n        print(\"\\nPaste the complex code below (type 'DONE' on a new line when finished):\")\n        code_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            code_lines.append(line)\n\n        code = \"\\n\".join(code_lines)\n\n        system_prompt = \"\"\"\n        You are an expert in code refactoring and simplification.\n        You take complex code and make it more readable while preserving functionality.\n        You explain your changes clearly so the user understands the improvements.\n        \"\"\"\n\n        simplify_prompt = f\"\"\"\n        Simplify this code to make it more readable and maintainable:\n        ```\n        {code}\n        ```\n\n        Provide:\n        1. A simplified version of the code\n        2. An explanation of what changes you made and why\n        3. How the simplified version improves upon the original\n        \"\"\"\n\n        print(\"\\nSimplifying code...\")\n        simplified = get_response(simplify_prompt, system=system_prompt)\n\n        print(\"\\n=== Simplified Code ===\")\n        print(simplified)\n\n    elif choice == \"3\":\n        # Debug code\n        print(\"\\nPaste the problematic code below (type 'DONE' on a new line when finished):\")\n        code_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            code_lines.append(line)\n\n        code = \"\\n\".join(code_lines)\n\n        error = input(\"\\nDescribe any error messages you're seeing: \")\n        expected = input(\"What did you expect the code to do? \")\n\n        system_prompt = \"\"\"\n        You are an expert debugging assistant who helps find and fix code issues.\n        You are an expert debugging assistant who helps find and fix code issues.\n        You carefully analyze code to identify bugs, logic errors, and other problems.\n        You explain issues clearly and provide working solutions.\n        \"\"\"\n\n        debug_prompt = f\"\"\"\n        Debug this code:\n        ```\n        {code}\n        ```\n\n        Error information: {error}\n        Expected behavior: {expected}\n\n        Provide:\n        1. Identification of the likely issue(s)\n        2. An explanation of what's causing the problem\n        3. A corrected version of the code\n        4. Testing suggestions to verify the fix\n        \"\"\"\n\n        print(\"\\nDebugging code...\")\n        debug_info = get_response(debug_prompt, system=system_prompt)\n\n        print(\"\\n=== Debugging Results ===\")\n        print(debug_info)\n\n    elif choice == \"4\":\n        # Learn programming concept\n        concept = input(\"\\nWhat programming concept would you like to learn about? \")\n        language = input(\"For which programming language? \")\n\n        system_prompt = \"\"\"\n        You are a programming educator who excels at explaining technical concepts clearly.\n        You use examples and analogies to make abstract ideas concrete and understandable.\n        You provide practical code examples to illustrate concepts.\n        \"\"\"\n\n        learn_prompt = f\"\"\"\n        Explain the programming concept of {concept} in {language}.\n\n        Include:\n        1. A clear definition of the concept\n        2. Why it's important and when to use it\n        3. At least 2 practical code examples in {language}\n        4. Common pitfalls or misconceptions\n        5. Best practices when using this concept\n        \"\"\"\n\n        print(f\"\\nResearching {concept} in {language}...\")\n        concept_explanation = get_response(learn_prompt, system=system_prompt)\n\n        print(f\"\\n=== {concept.title()} in {language.title()} ===\")\n        print(concept_explanation)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the code explainer\nif __name__ == \"__main__\":\n    code_explainer()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_5","title":"Extension Ideas","text":"<p>Add functionality to generate test cases or convert code between languages.</p>"},{"location":"mini-projects/#creative-writing-partner","title":"Creative Writing Partner","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: Narrative development, creative collaboration, editing</p>"},{"location":"mini-projects/#overview_6","title":"Overview","text":"<p>A collaborative writing tool that helps students develop stories, poems, or essays.</p>"},{"location":"mini-projects/#instructions_6","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef writing_partner():\n    \"\"\"Interactive creative writing assistant\"\"\"\n    print(\"=== Creative Writing Partner ===\")\n    print(\"1. Story development\")\n    print(\"2. Poetry assistant\")\n    print(\"3. Essay outliner\")\n    print(\"4. Character creator\")\n    print(\"5. Writing feedback\")\n\n    choice = input(\"\\nWhat would you like to do? \")\n\n    if choice == \"1\":\n        # Story development\n        print(\"\\n=== Story Development ===\")\n        genre = input(\"What genre is your story? \")\n        premise = input(\"What's the basic premise or idea? \")\n\n        system_prompt = \"\"\"\n        You are a creative writing coach who helps develop stories.\n        You ask thoughtful questions, offer suggestions, and help organize ideas.\n        You're supportive and encouraging while providing constructive guidance.\n        \"\"\"\n\n        story_prompt = f\"\"\"\n        Help the user develop a {genre} story with this premise:\n        \"{premise}\"\n\n        Provide:\n        1. Three potential directions the story could take\n        2. Key elements that would make this story engaging\n        3. Suggestions for main characters and their motivations\n        4. A potential outline for the beginning, middle, and end\n        5. Questions that would help the user further develop their idea\n        \"\"\"\n\n        print(\"\\nDeveloping story ideas...\")\n        story_ideas = get_response(story_prompt, system=system_prompt)\n\n        print(\"\\n\" + story_ideas)\n\n        # Follow-up questions\n        print(\"\\nWould you like help with a specific aspect of your story?\")\n        print(\"1. Develop a character\")\n        print(\"2. Create a setting\")\n        print(\"3. Generate a plot twist\")\n        print(\"4. Write an opening paragraph\")\n\n        follow_up = input(\"\\nChoose an option (1-4): \")\n\n        if follow_up == \"1\":\n            character_type = input(\"\\nWhat type of character (protagonist, villain, sidekick, etc.)? \")\n\n            character_prompt = f\"\"\"\n            Help create a compelling {character_type} for a {genre} story with this premise:\n            \"{premise}\"\n\n            Develop:\n            1. Name and brief physical description\n            2. Background/history\n            3. Personality traits and quirks\n            4. Motivations and goals\n            5. Internal and external conflicts\n            \"\"\"\n\n            character = get_response(character_prompt, system=system_prompt)\n            print(\"\\n=== Character Profile ===\")\n            print(character)\n\n        elif follow_up == \"2\":\n            setting_type = input(\"\\nWhat type of setting (time period, location, etc.)? \")\n\n            setting_prompt = f\"\"\"\n            Create a vivid setting for a {genre} story with this premise:\n            \"{premise}\"\n\n            The setting is: {setting_type}\n\n            Include:\n            1. Detailed sensory descriptions (sights, sounds, smells)\n            2. Unique features of this world/place\n            3. How the setting influences the story\n            4. Potential conflicts arising from the setting\n            \"\"\"\n\n            setting = get_response(setting_prompt, system=system_prompt)\n            print(\"\\n=== Setting Description ===\")\n            print(setting)\n\n        elif follow_up == \"3\":\n            twist_prompt = f\"\"\"\n            Generate three potential plot twists for a {genre} story with this premise:\n            \"{premise}\"\n\n            For each twist, explain:\n            1. What the twist is\n            2. When it might occur in the story\n            3. How it would change the direction of the narrative\n            4. Why it would be surprising but still logical within the story\n            \"\"\"\n\n            twists = get_response(twist_prompt, system=system_prompt)\n            print(\"\\n=== Plot Twist Ideas ===\")\n            print(twists)\n\n        elif follow_up == \"4\":\n            style = input(\"\\nDescribe the writing style you'd like to use: \")\n\n            opening_prompt = f\"\"\"\n            Write an engaging opening paragraph for a {genre} story with this premise:\n            \"{premise}\"\n\n            Using this writing style: {style}\n\n            The opening should:\n            1. Hook the reader's attention\n            2. Establish tone and atmosphere\n            3. Introduce either a character, setting, or conflict\n            4. Hint at the larger story to come\n            \"\"\"\n\n            opening = get_response(opening_prompt, system=system_prompt)\n            print(\"\\n=== Opening Paragraph ===\")\n            print(opening)\n\n    elif choice == \"2\":\n        # Poetry assistant\n        print(\"\\n=== Poetry Assistant ===\")\n        poetry_type = input(\"What type of poem (sonnet, haiku, free verse, etc.)? \")\n        theme = input(\"What theme or topic for your poem? \")\n\n        system_prompt = \"\"\"\n        You are a poetry writing coach who helps develop beautiful, meaningful poems.\n        You provide guidance on form, structure, language, and imagery.\n        You're artistic and thoughtful while remaining accessible and supportive.\n        \"\"\"\n\n        poetry_prompt = f\"\"\"\n        Help the user write a {poetry_type} about {theme}.\n\n        Provide:\n        1. A brief explanation of the {poetry_type} form and its characteristics\n        2. Suggested imagery, metaphors, or symbols related to {theme}\n        3. A list of evocative words related to the theme\n        4. An example first stanza or line to get started\n        5. Tips for writing effectively in this form\n        \"\"\"\n\n        print(\"\\nGenerating poetry guidance...\")\n        poetry_guidance = get_response(poetry_prompt, system=system_prompt)\n\n        print(\"\\n\" + poetry_guidance)\n\n        # User writes poem\n        print(\"\\nWrite your poem below (type 'DONE' on a new line when finished):\")\n        poem_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            poem_lines.append(line)\n\n        poem = \"\\n\".join(poem_lines)\n\n        # Feedback on poem\n        feedback_prompt = f\"\"\"\n        The user has written this {poetry_type} about {theme}:\n\n        {poem}\n\n        Provide constructive, supportive feedback, including:\n        1. What works well in the poem\n        2. Suggestions for strengthening imagery or language\n        3. Ideas for revision if appropriate\n        4. One or two specific lines that could be enhanced, with suggestions\n        \"\"\"\n\n        print(\"\\nAnalyzing your poem...\")\n        feedback = get_response(feedback_prompt, system=system_prompt)\n\n        print(\"\\n=== Poetry Feedback ===\")\n        print(feedback)\n\n    elif choice == \"3\":\n        # Essay outliner\n        print(\"\\n=== Essay Outliner ===\")\n        essay_type = input(\"What type of essay (argumentative, expository, etc.)? \")\n        topic = input(\"What's your essay topic? \")\n\n        system_prompt = \"\"\"\n        You are an academic writing coach who helps develop well-structured essays.\n        You help organize ideas, develop arguments, and create coherent outlines.\n        You provide guidance on thesis statements, evidence, and logical flow.\n        \"\"\"\n\n        essay_prompt = f\"\"\"\n        Help the user outline a {essay_type} essay on the topic:\n        \"{topic}\"\n\n        Provide:\n        1. Potential thesis statements or research questions\n        2. A suggested structure with main sections\n        3. Key points to cover in each section\n        4. Types of evidence or examples that could support each point\n        5. Ideas for a strong introduction and conclusion\n        \"\"\"\n\n        print(\"\\nDeveloping essay outline...\")\n        essay_outline = get_response(essay_prompt, system=system_prompt)\n\n        print(\"\\n\" + essay_outline)\n\n        # Thesis refinement\n        thesis = input(\"\\nBased on these suggestions, write your thesis statement: \")\n\n        refine_prompt = f\"\"\"\n        Analyze this thesis statement for a {essay_type} essay on {topic}:\n\n        \"{thesis}\"\n\n        Provide feedback on:\n        1. Clarity and specificity\n        2. Arguability (is it something that could be supported/contested?)\n        3. Scope (is it appropriately focused for an essay?)\n        4. Suggested revisions if needed\n        \"\"\"\n\n        print(\"\\nAnalyzing thesis statement...\")\n        thesis_feedback = get_response(refine_prompt, system=system_prompt)\n\n        print(\"\\n=== Thesis Feedback ===\")\n        print(thesis_feedback)\n\n    elif choice == \"4\":\n        # Character creator\n        print(\"\\n=== Character Creator ===\")\n        role = input(\"What role will this character play (protagonist, villain, etc.)? \")\n        story_type = input(\"What type of story is this character for? \")\n\n        system_prompt = \"\"\"\n        You are a character development coach who helps create deep, nuanced characters.\n        You ask insightful questions and provide suggestions for well-rounded character creation.\n        You focus on psychology, motivation, and authentic human behavior.\n        \"\"\"\n\n        character_prompt = f\"\"\"\n        Help the user create a compelling {role} for a {story_type}.\n\n        Provide:\n        1. Questions to consider about the character's background\n        2. Suggestions for interesting personality traits and quirks\n        3. Ideas for internal and external conflicts\n        4. Potential character arcs or growth journeys\n        5. Tips for making the character authentic and three-dimensional\n        \"\"\"\n\n        print(\"\\nGenerating character development ideas...\")\n        character_ideas = get_response(character_prompt, system=system_prompt)\n\n        print(\"\\n\" + character_ideas)\n\n        # Character profile\n        print(\"\\nBased on these ideas, let's create a character profile.\")\n        name = input(\"Character name: \")\n        traits = input(\"Three key personality traits: \")\n        background = input(\"Brief background: \")\n        goal = input(\"Main goal or motivation: \")\n\n        profile_prompt = f\"\"\"\n        Develop a complete character profile for {name}, a {role} in a {story_type}.\n\n        Use this information:\n        - Key traits: {traits}\n        - Background: {background}\n        - Goal/motivation: {goal}\n\n        Create a comprehensive profile including:\n        1. Physical description and appearance\n        2. Detailed personality analysis\n        3. Relationships with other potential characters\n        4. Internal contradictions or complexities\n        5. How they might respond in various situations\n        6. Character arc - how they might change throughout the story\n        \"\"\"\n\n        print(\"\\nCreating detailed character profile...\")\n        profile = get_response(profile_prompt, system=system_prompt)\n\n        print(\"\\n=== Character Profile: \" + name + \" ===\")\n        print(profile)\n\n    elif choice == \"5\":\n        # Writing feedback\n        print(\"\\n=== Writing Feedback ===\")\n        writing_type = input(\"What type of writing (story, poem, essay, etc.)? \")\n\n        print(\"\\nPaste your writing below (type 'DONE' on a new line when finished):\")\n        writing_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            writing_lines.append(line)\n\n        writing = \"\\n\".join(writing_lines)\n\n        focus_areas = input(\"\\nWhat aspects would you like feedback on (e.g., structure, characters, language)? \")\n\n        system_prompt = \"\"\"\n        You are a supportive writing coach who provides constructive feedback.\n        You balance positive observations with suggestions for improvement.\n        You're specific, actionable, and encouraging in your feedback.\n        \"\"\"\n\n        feedback_prompt = f\"\"\"\n        Provide constructive feedback on this {writing_type}:\n\n        {writing}\n\n        Focus on these areas: {focus_areas}\n\n        Include in your feedback:\n        1. Overall impression and strengths\n        2. Specific suggestions for improvement in the requested areas\n        3. Examples from the text with suggested revisions\n        4. Next steps for revision\n\n        Be supportive and constructive while providing honest feedback.\n        \"\"\"\n\n        print(\"\\nAnalyzing your writing...\")\n        feedback = get_response(feedback_prompt, system=system_prompt)\n\n        print(\"\\n=== Writing Feedback ===\")\n        print(feedback)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the writing partner\nif __name__ == \"__main__\":\n    writing_partner()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_6","title":"Extension Ideas","text":"<p>Add a collaborative storytelling mode where student and bot take turns adding to a story.</p>"},{"location":"mini-projects/#implementation-tips","title":"Implementation Tips","text":"<p>When using these mini-projects in a classroom setting:</p> <ol> <li>Scaffold appropriately: Start with simpler projects for beginners, then progress to more complex ones.</li> <li>Modify complexity: Adjust project requirements based on student skill level and available time.</li> <li>Pair programming: Have students work in pairs to encourage collaboration.</li> <li>Challenge extensions: Provide additional challenges for students who finish early.</li> <li>Focus on concepts: Emphasize the programming concepts being used rather than just creating a functioning bot.</li> <li>Ethical discussions: Use these projects as opportunities to discuss AI ethics, bias, and limitations.</li> </ol>"},{"location":"mini-projects/#assessment-ideas","title":"Assessment Ideas","text":"<ul> <li>Have students document their process in a digital portfolio</li> <li>Create a \"bot showcase\" where students present their creations</li> <li>Ask students to write reflections on what they learned</li> <li>Evaluate code structure, comments, and organization</li> <li>Have students peer-review each other's projects</li> </ul> <p>These examples are designed to be flexible starting points. Adjust and expand them to suit your specific educational needs and student skill levels.</p>"},{"location":"mini-projects/#data-visualization-dashboard","title":"Data Visualization Dashboard","text":"<p>Difficulty: Intermediate Time: 60-90 minutes Learning Focus: Data analysis, visualization, pandas, matplotlib</p>"},{"location":"mini-projects/#overview_7","title":"Overview","text":"<p>Create an interactive dashboard that allows users to visualize and explore data relationships through various chart types. Students will learn data manipulation with pandas and visualization with matplotlib.</p>"},{"location":"mini-projects/#instructions_7","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom io import BytesIO\nimport base64\nimport random\nimport os\nimport numpy as np\n\ndef data_dashboard():\n    \"\"\"Interactive data visualization dashboard for exploring datasets\"\"\"\n\n    # Sample dataset (students could replace with their own CSV)\n    sample_data = {\n        'Month': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        'Temperature': [12, 14, 16, 19, 22, 25, 27, 26, 23, 19, 15, 13],\n        'Rainfall': [50, 45, 35, 30, 25, 15, 10, 12, 20, 35, 40, 48],\n        'Visitors': [120, 135, 190, 240, 310, 430, 590, 560, 420, 320, 190, 150]\n    }\n\n    # Create a DataFrame from the sample data\n    df = pd.DataFrame(sample_data)\n\n    print(\"=== Data Visualization Dashboard ===\")\n    print(\"This dashboard allows you to explore relationships in data.\")\n\n    # Create directory for plots if it doesn't exist\n    plots_dir = \"dashboard_plots\"\n    os.makedirs(plots_dir, exist_ok=True)\n\n    while True:\n        print(\"\\nOptions:\")\n        print(\"1. View data summary\")\n        print(\"2. Line chart\")\n        print(\"3. Bar chart\")\n        print(\"4. Scatter plot\")\n        print(\"5. Get AI insights\")\n        print(\"6. Exit\")\n\n        choice = input(\"\\nSelect an option (1-6): \")\n\n        if choice == '1':\n            # Data summary\n            print(\"\\n=== Data Summary ===\")\n            print(f\"Dataset shape: {df.shape[0]} rows, {df.shape[1]} columns\")\n            print(\"\\nColumns:\")\n            for column in df.columns:\n                print(f\"- {column}\")\n\n            print(\"\\nSummary statistics:\")\n            print(df.describe())\n\n            print(\"\\nFirst few rows:\")\n            print(df.head())\n\n        elif choice == '2':\n            # Line chart\n            print(\"\\n=== Line Chart ===\")\n            print(\"Available columns:\")\n            for i, column in enumerate(df.columns[1:], 1):  # Skip 'Month' column\n                print(f\"{i}. {column}\")\n\n            column_idx = int(input(\"\\nSelect column to plot (1-3): \")) - 1\n            column_to_plot = df.columns[column_idx + 1]  # +1 to account for skipping 'Month'\n\n            plt.figure(figsize=(10, 6))\n            plt.plot(df['Month'], df[column_to_plot], marker='o', linewidth=2)\n            plt.title(f'{column_to_plot} by Month')\n            plt.xlabel('Month')\n            plt.ylabel(column_to_plot)\n            plt.grid(True, linestyle='--', alpha=0.7)\n\n            # Save plot to file\n            plot_filename = os.path.join(plots_dir, f\"line_{column_to_plot.lower()}.png\")\n            plt.savefig(plot_filename)\n            plt.close()\n\n            print(f\"\\nLine chart created and saved as {plot_filename}\")\n\n        elif choice == '3':\n            # Bar chart\n            print(\"\\n=== Bar Chart ===\")\n            print(\"Available columns:\")\n            for i, column in enumerate(df.columns[1:], 1):  # Skip 'Month' column\n                print(f\"{i}. {column}\")\n\n            column_idx = int(input(\"\\nSelect column to plot (1-3): \")) - 1\n            column_to_plot = df.columns[column_idx + 1]  # +1 to account for skipping 'Month'\n\n            plt.figure(figsize=(10, 6))\n            plt.bar(df['Month'], df[column_to_plot], color='skyblue', edgecolor='navy')\n            plt.title(f'{column_to_plot} by Month')\n            plt.xlabel('Month')\n            plt.ylabel(column_to_plot)\n            plt.grid(True, axis='y', linestyle='--', alpha=0.7)\n\n            # Save plot to file\n            plot_filename = os.path.join(plots_dir, f\"bar_{column_to_plot.lower()}.png\")\n            plt.savefig(plot_filename)\n            plt.close()\n\n            print(f\"\\nBar chart created and saved as {plot_filename}\")\n\n        elif choice == '4':\n            # Scatter plot\n            print(\"\\n=== Scatter Plot ===\")\n            print(\"Available columns for X-axis:\")\n            for i, column in enumerate(df.columns[1:], 1):  # Skip 'Month' column\n                print(f\"{i}. {column}\")\n\n            x_idx = int(input(\"\\nSelect X-axis column (1-3): \")) - 1\n            x_column = df.columns[x_idx + 1]  # +1 to account for skipping 'Month'\n\n            print(\"\\nAvailable columns for Y-axis:\")\n            for i, column in enumerate(df.columns[1:], 1):  # Skip 'Month' column\n                if column != x_column:  # Don't show the X column again\n                    print(f\"{i}. {column}\")\n\n            y_idx = int(input(\"\\nSelect Y-axis column (1-3): \")) - 1\n            y_column = df.columns[y_idx + 1]  # +1 to account for skipping 'Month'\n\n            plt.figure(figsize=(10, 6))\n            plt.scatter(df[x_column], df[y_column], color='purple', alpha=0.7, s=100)\n\n            # Add month labels to each point\n            for i, month in enumerate(df['Month']):\n                plt.annotate(month, (df[x_column][i], df[y_column][i]), \n                             xytext=(5, 5), textcoords='offset points')\n\n            plt.title(f'{y_column} vs {x_column}')\n            plt.xlabel(x_column)\n            plt.ylabel(y_column)\n            plt.grid(True, linestyle='--', alpha=0.7)\n\n            # Optional: Add trendline\n            plt.plot(np.unique(df[x_column]), \n                     np.poly1d(np.polyfit(df[x_column], df[y_column], 1))(np.unique(df[x_column])),\n                     color='red', linestyle='--', alpha=0.7)\n\n            # Save plot to file\n            plot_filename = os.path.join(plots_dir, f\"scatter_{x_column.lower()}_{y_column.lower()}.png\")\n            plt.savefig(plot_filename)\n            plt.close()\n\n            print(f\"\\nScatter plot created and saved as {plot_filename}\")\n\n        elif choice == '5':\n            # AI insights\n            print(\"\\n=== AI Data Insights ===\")\n\n            try:\n                # Prepare data summary for AI\n                data_description = f\"\"\"\n                Dataset with columns: {', '.join(df.columns)}\n                Summary statistics:\n                {df.describe().to_string()}\n\n                First few rows:\n                {df.head().to_string()}\n                \"\"\"\n\n                insight_prompt = f\"\"\"\n                Analyze this dataset and provide 3-5 key insights:\n                {data_description}\n\n                Focus on:\n                1. Patterns or trends over months\n                2. Correlations between variables\n                3. Anomalies or interesting data points\n                4. Suggestions for further analysis\n                \"\"\"\n\n                print(\"Generating AI insights...\")\n                insights = get_response(insight_prompt)\n\n                print(\"\\n=== AI Analysis Results ===\")\n                print(insights)\n\n            except Exception as e:\n                print(f\"Error getting AI insights: {e}\")\n                print(\"AI insight generation is not available.\")\n\n        elif choice == '6':\n            print(\"\\nExiting Dashboard. Goodbye!\")\n            break\n\n        else:\n            print(\"\\nInvalid choice. Please select a number between 1 and 6.\")\n\n# Run the dashboard\nif __name__ == \"__main__\":\n    data_dashboard()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_7","title":"Extension Ideas","text":"<ul> <li>Add more visualization types like pie charts, histograms, or heatmaps</li> <li>Implement data filtering options to explore subsets of the data</li> <li>Add the ability to load CSV files from disk</li> <li>Create a feature to export all visualizations as a report</li> <li>Implement interactive plots using libraries like Plotly</li> <li>Add clustering or other basic data analysis techniques</li> </ul>"},{"location":"mini-projects/#ai-persona-dialogue-simulator","title":"AI Persona Dialogue Simulator","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: Function calls, lists, creativity, dialogue simulation</p>"},{"location":"mini-projects/#overview_8","title":"Overview","text":"<p>Simulate interactive dialogues between multiple AI personas with different personalities or perspectives. This flexible tool enables both multi-participant panel discussions and focused one-on-one debates, allowing students to explore how different characters approach the same topics. The simulator can also be configured to run simulated interviews by selecting appropriate personas and question formats.</p> <p>Simulate an interview or debate between multiple bots with different personalities or perspectives, exploring how different characters might approach the same questions or topics.</p> <p>This project offers flexibility to run either panel discussions with multiple participants or focused one-on-one debates, allowing students to explore how different personas respond to the same topics.</p>"},{"location":"mini-projects/#instructions_8","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport time\n\ndef ai_persona_dialogue_simulator():\n    \"\"\"\n    Simulate a dialogue between multiple AI personas with different personalities,\n    exploring how different characters approach the same questions or topics.\n\n    This tool supports multiple dialogue formats:\n    1. Panel discussion - Multiple personas exchange views with less structure\n    2. Formal debate - Two personas engage in structured argument with multiple rounds\n    3. Interview - One persona can be set as an \"interviewer\" asking questions \n       of other personas serving as \"interviewees\"\n    \"\"\"\n    print(\"=== AI Persona Dialogue Simulator ===\")\n\n    # Define different bot personalities\n    # Each personality has a unique perspective that influences how they respond\n    bot_personalities = {\n        \"Professor\": \"You are a logical, analytical professor who values facts, research, and intellectual rigor. You speak formally and cite evidence for your claims. You believe in rational inquiry and skepticism.\",\n        \"Coach\": \"You are an inspirational coach who focuses on motivation, emotional intelligence, and personal growth. You believe in the power of passion, intuition, and human potential. You speak with enthusiasm and use motivational language.\",\n        \"Artist\": \"You are a creative artist who values beauty, expression, and innovation. You think metaphorically and appreciate the abstract and subjective. You believe in breaking rules to create something new. Your language is colorful and expressive.\",\n        \"Entrepreneur\": \"You are a practical entrepreneur focused on results, efficiency, and real-world applications. You value solutions that work and ideas that can be implemented. You speak directly and focus on action.\",\n        \"Dr. Logic\": \"You value logical reasoning and empirical evidence above all. You cite studies and statistics to support your points. You believe decisions should be made based on data, not emotions.\",\n        \"Empathetic Emma\": \"You believe emotional impact and human stories are most important. You consider how policies and ideas affect real people. You speak with compassion and emphasize the human element in every issue.\",\n        \"Traditional Tom\": \"You value tradition, stability, and time-tested approaches. You're skeptical of rapid change and new untested ideas. You believe in preserving what works and making careful, incremental improvements.\",\n        \"Interviewer\": \"You are a professional interviewer who asks insightful, probing questions. You're curious and neutral, aiming to bring out the most interesting perspectives from others. You follow up with clarifying questions when needed.\"\n    }\n\n    # List of debate/discussion topics\n    # These can be used for debates, panel discussions, or interview topics\n    dialogue_topics = [\n        \"What's more important: creativity or logic?\",\n        \"Is technology improving or harming society?\",\n        \"Should education focus more on facts or skills?\",\n        \"Is it better to be a specialist or a generalist?\",\n        \"Are humans naturally cooperative or competitive?\",\n        \"What's the best way to measure success in life?\",\n        \"Should we prioritize individual freedom or collective welfare?\",\n        \"Is artificial intelligence more likely to help or harm humanity?\",\n        \"Should governments regulate social media platforms?\"\n    ]\n\n    # Let user select a dialogue topic\n    # TODO: Add input validation to handle non-integer inputs\n    print(\"Choose a topic:\")\n    for i, question in enumerate(dialogue_topics, 1):\n        print(f\"{i}. {question}\")\n    print(f\"{len(dialogue_topics) + 1}. Custom topic (enter your own)\")\n\n    # Input validation could be added here to handle non-integer inputs\n    try:\n        choice = int(input(\"\\nEnter topic number: \"))\n        if choice &lt;= 0 or choice &gt; len(dialogue_topics) + 1:\n            print(\"Invalid choice. Using default topic #1.\")\n            choice = 1\n    except ValueError:\n        print(\"Invalid input. Using default topic #1.\")\n        choice = 1\n\n    if choice &lt;= len(dialogue_topics):\n        dialogue_topic = dialogue_topics[choice - 1]\n    else:\n        dialogue_topic = input(\"\\nEnter your custom topic: \")\n\n    # Choose dialogue format\n    # The format affects how the personas interact with each other\n    print(\"\\nChoose dialogue format:\")\n    print(\"1. Panel discussion (multiple personas participate in an open exchange)\")\n    print(\"2. One-on-one debate (two personas engage in structured argument)\")\n    print(\"3. Interview (one persona interviews the others)\")\n\n    # TODO: Add input validation for format choice\n    try:\n        format_choice = int(input(\"\\nEnter format number (1-3): \"))\n        if format_choice &lt; 1 or format_choice &gt; 3:\n            print(\"Invalid format. Using panel discussion (1).\")\n            format_choice = 1\n    except ValueError:\n        print(\"Invalid input. Using panel discussion (1).\")\n        format_choice = 1\n\n    # Select personas based on format\n    if format_choice == 1:\n        # Panel discussion - let user select multiple participants\n        # This mode simulates a roundtable where each persona responds to the previous one\n        print(\"\\nAvailable personalities:\")\n        for i, (name, perspective) in enumerate(bot_personalities.items(), 1):\n            print(f\"{i}. {name}: {perspective[:60]}...\")\n\n        # TODO: Add more robust input validation for selections\n        selections = input(\"\\nSelect personalities (comma-separated numbers, e.g., 1,3,4): \")\n        try:\n            selected_indices = [int(idx.strip()) - 1 for idx in selections.split(\",\")]\n            # Check if indices are valid\n            if any(idx &lt; 0 or idx &gt;= len(bot_personalities) for idx in selected_indices):\n                print(\"Some selections were invalid. Using first 3 personalities.\")\n                selected_indices = [0, 1, 2]\n        except ValueError:\n            print(\"Invalid input. Using first 3 personalities.\")\n            selected_indices = [0, 1, 2]\n\n        # Get the selected personalities\n        personalities = list(bot_personalities.items())\n        participants = {personalities[idx][0]: personalities[idx][1] for idx in selected_indices if 0 &lt;= idx &lt; len(personalities)}\n\n        # Panel discussions typically have fewer rounds with more participants\n        rounds = 1  \n\n    elif format_choice == 2:\n        # One-on-one debate - let user select exactly two participants\n        # This mode creates a structured back-and-forth exchange with multiple rounds\n        print(\"\\nChoose two debaters:\")\n        for i, (name, perspective) in enumerate(bot_personalities.items(), 1):\n            print(f\"{i}. {name}: {perspective[:60]}...\")\n\n        # TODO: Add input validation for debater selections\n        try:\n            choice1 = int(input(\"\\nSelect first debater (1-8): \")) - 1\n            choice2 = int(input(\"Select second debater (1-8): \")) - 1\n\n            if choice1 &lt; 0 or choice1 &gt;= len(bot_personalities) or choice2 &lt; 0 or choice2 &gt;= len(bot_personalities):\n                print(\"Invalid selection. Using Professor and Coach.\")\n                choice1, choice2 = 0, 1\n        except ValueError:\n            print(\"Invalid input. Using Professor and Coach.\")\n            choice1, choice2 = 0, 1\n\n        # Get the selected personalities\n        personalities = list(bot_personalities.items())\n        participants = {\n            personalities[choice1][0]: personalities[choice1][1],\n            personalities[choice2][0]: personalities[choice2][1]\n        }\n\n        # Set number of rounds for one-on-one debate\n        try:\n            rounds = int(input(\"\\nHow many response rounds? (1-5): \"))\n            rounds = min(max(1, rounds), 5)  # Ensure rounds is between 1 and 5\n        except ValueError:\n            print(\"Invalid input. Using 2 rounds.\")\n            rounds = 2\n\n    else:  # format_choice == 3\n        # Interview format - one interviewer, multiple interviewees\n        # This mode has one persona asking questions and others responding\n        print(\"\\nSelect the interviewer:\")\n        for i, (name, perspective) in enumerate(bot_personalities.items(), 1):\n            print(f\"{i}. {name}\")\n\n        # TODO: Add input validation for interviewer selection\n        try:\n            interviewer_idx = int(input(\"\\nSelect interviewer (1-8, recommend #8 'Interviewer'): \")) - 1\n            if interviewer_idx &lt; 0 or interviewer_idx &gt;= len(bot_personalities):\n                print(\"Invalid selection. Using 'Interviewer' persona.\")\n                # Find the Interviewer in the list\n                interviewer_idx = list(bot_personalities.keys()).index(\"Interviewer\") if \"Interviewer\" in bot_personalities else 0\n        except ValueError:\n            print(\"Invalid input. Using 'Interviewer' persona.\")\n            interviewer_idx = list(bot_personalities.keys()).index(\"Interviewer\") if \"Interviewer\" in bot_personalities else 0\n\n        print(\"\\nSelect interviewees:\")\n        personalities = list(bot_personalities.items())\n        interviewees = list(range(len(personalities)))\n        interviewees.remove(interviewer_idx)  # Remove interviewer from potential interviewees\n\n        for i, idx in enumerate(interviewees, 1):\n            name, perspective = personalities[idx]\n            print(f\"{i}. {name}: {perspective[:60]}...\")\n\n        # TODO: Add input validation for interviewee selections\n        selections = input(\"\\nSelect interviewees (comma-separated numbers): \")\n        try:\n            selected = [int(idx.strip()) - 1 for idx in selections.split(\",\")]\n            # Convert selected indices to actual personality indices\n            selected_indices = [interviewees[idx] for idx in selected if 0 &lt;= idx &lt; len(interviewees)]\n            if not selected_indices:\n                print(\"No valid selections. Using first two personalities.\")\n                selected_indices = interviewees[:2]\n        except ValueError:\n            print(\"Invalid input. Using first two personalities.\")\n            selected_indices = interviewees[:2]\n\n        # Add interviewer and interviewees to participants\n        participants = {personalities[interviewer_idx][0]: personalities[interviewer_idx][1]}\n        for idx in selected_indices:\n            participants[personalities[idx][0]] = personalities[idx][1]\n\n        # Set number of interview questions\n        try:\n            rounds = int(input(\"\\nHow many interview questions? (1-5): \"))\n            rounds = min(max(1, rounds), 5)  # Ensure rounds is between 1 and 5\n        except ValueError:\n            print(\"Invalid input. Using 3 questions.\")\n            rounds = 3\n\n    # Function to get response from a bot\n    def get_bot_response(prompt, perspective, name):\n        \"\"\"Generate a response from a persona based on their perspective.\"\"\"\n        system_prompt = f\"You are {name}. {perspective} Keep responses under 100 words to keep the dialogue flowing.\"\n        return get_response(prompt, system=system_prompt)\n\n    # Start the dialogue\n    participant_names = list(participants.keys())\n    print(f\"\\n=== Dialogue on: {dialogue_topic} ===\\n\")\n    time.sleep(1)\n\n    # Opening statements (except for interview format)\n    if format_choice != 3:  # Not interview format\n        print(\"=== Opening Statements ===\\n\")\n        statements = {}\n\n        for name, perspective in participants.items():\n            print(f\"{name}'s opening statement:\")\n            statement = get_bot_response(\n                f\"Give an opening statement on the topic of {dialogue_topic}\",\n                perspective,\n                name\n            )\n            statements[name] = statement\n            print(statement)\n            print()\n            time.sleep(1)\n\n    # Discussion rounds based on format\n    if format_choice == 1:\n        # Panel discussion - each persona responds to the previous speaker\n        # This creates a chain of responses where each builds on the last\n        print(\"\\n=== Panel Discussion ===\\n\")\n\n        previous_statement = statements[participant_names[-1]]\n        previous_name = participant_names[-1]\n\n        for round_num in range(rounds):\n            print(f\"--- Round {round_num + 1} ---\\n\")\n\n            for name in participant_names:\n                time.sleep(1)\n                print(f\"{name} responds to {previous_name}:\")\n                response = get_bot_response(\n                    f\"The topic is: {dialogue_topic}\\n{previous_name} said: '{previous_statement}'\\n\\nRespond to {previous_name}'s perspective with your own viewpoint.\",\n                    participants[name],\n                    name\n                )\n                print(response)\n                print()\n\n                previous_statement = response\n                previous_name = name\n\n    elif format_choice == 2:\n        # One-on-one debate - alternating responses with structured format\n        # This simulates a formal debate with clear turns and direct responses\n        print(\"\\n=== Debate Rounds ===\\n\")\n\n        debater1 = participant_names[0]\n        debater2 = participant_names[1]\n        current_statement = statements[debater2]\n\n        for round_num in range(rounds):\n            print(f\"--- Round {round_num + 1} ---\\n\")\n\n            # First debater responds\n            time.sleep(1)\n            print(f\"{debater1} responds:\")\n            response = get_bot_response(\n                f\"Respond to this statement on {dialogue_topic}: '{current_statement}'\",\n                participants[debater1],\n                debater1\n            )\n            print(response)\n            print()\n            current_statement = response\n\n            # Second debater responds\n            time.sleep(1)\n            print(f\"{debater2} responds:\")\n            response = get_bot_response(\n                f\"Respond to this statement on {dialogue_topic}: '{current_statement}'\",\n                participants[debater2],\n                debater2\n            )\n            print(response)\n            print()\n            current_statement = response\n\n    else:  # format_choice == 3\n        # Interview format - interviewer asks questions, interviewees respond\n        # This simulates a talk show or interview panel with one host\n        print(\"\\n=== Interview Session ===\\n\")\n\n        interviewer = participant_names[0]\n        interviewees = participant_names[1:]\n\n        # Opening question about the topic\n        print(f\"{interviewer} asks about {dialogue_topic}:\")\n        question = get_bot_response(\n            f\"As an interviewer, ask an insightful opening question about {dialogue_topic}\",\n            participants[interviewer],\n            interviewer\n        )\n        print(question)\n        print()\n\n        # Each interviewee responds to the opening question\n        for interviewee in interviewees:\n            time.sleep(1)\n            print(f\"{interviewee} responds:\")\n            response = get_bot_response(\n                f\"You're being interviewed. The interviewer asked: '{question}' regarding {dialogue_topic}. Respond with your perspective.\",\n                participants[interviewee],\n                interviewee\n            )\n            print(response)\n            print()\n\n        # Additional rounds of questions\n        for round_num in range(1, rounds):\n            time.sleep(1)\n            print(f\"--- Question {round_num + 1} ---\\n\")\n\n            # Interviewer asks a follow-up question\n            print(f\"{interviewer} asks:\")\n            question = get_bot_response(\n                f\"Based on the previous responses about {dialogue_topic}, ask a follow-up question that explores a different angle or aspect of the topic.\",\n                participants[interviewer],\n                interviewer\n            )\n            print(question)\n            print()\n\n            # Each interviewee responds to the new question\n            for interviewee in interviewees:\n                time.sleep(1)\n                print(f\"{interviewee} responds:\")\n                response = get_bot_response(\n                    f\"You're being interviewed. The interviewer asked: '{question}' regarding {dialogue_topic}. Respond with your perspective.\",\n                    participants[interviewee],\n                    interviewee\n                )\n                print(response)\n                print()\n\n    # Closing statements (except for interview format which has a special closing)\n    if format_choice != 3:\n        print(\"=== Closing Statements ===\\n\")\n        closing_statements = {}\n\n        for name, perspective in participants.items():\n            time.sleep(1)\n            print(f\"{name}'s closing remarks:\")\n            closing = get_bot_response(\n                f\"Give a brief closing statement summarizing your position on {dialogue_topic}\",\n                perspective,\n                name\n            )\n            closing_statements[name] = closing\n            print(closing)\n            print()\n    else:\n        # Special closing for interview format\n        print(\"=== Interview Wrap-up ===\\n\")\n        closing_statements = {}\n\n        # Interviewer provides a wrap-up\n        time.sleep(1)\n        print(f\"{interviewer}'s wrap-up:\")\n        interviewer_closing = get_bot_response(\n            f\"Provide a thoughtful wrap-up to the interview about {dialogue_topic}, thanking your guests and highlighting key insights.\",\n            participants[interviewer],\n            interviewer\n        )\n        closing_statements[interviewer] = interviewer_closing\n        print(interviewer_closing)\n        print()\n\n        # Each interviewee gives a brief final thought\n        for interviewee in interviewees:\n            time.sleep(1)\n            print(f\"{interviewee}'s final thought:\")\n            closing = get_bot_response(\n                f\"The interview about {dialogue_topic} is ending. Share a brief, impactful final thought in 1-2 sentences.\",\n                participants[interviewee],\n                interviewee\n            )\n            closing_statements[interviewee] = closing\n            print(closing)\n            print()\n\n    # Moderator summary\n    print(\"\\n=== Summary ===\\n\")\n\n    summary_prompt = f\"Summarize the dialogue on '{dialogue_topic}' between the following participants:\\n\\n\"\n\n    for name, perspective in participants.items():\n        summary_prompt += f\"{name}'s perspective: {perspective}\\n\"\n        if name in closing_statements:\n            summary_prompt += f\"{name}'s closing: {closing_statements[name]}\\n\\n\"\n\n    if format_choice == 1:\n        summary_type = \"panel discussion\"\n    elif format_choice == 2:\n        summary_type = \"debate\"\n    else:\n        summary_type = \"interview\"\n\n    summary_prompt += f\"Provide a neutral, balanced summary of this {summary_type}, highlighting the key differences in their approaches and the strengths of each perspective.\"\n\n    moderator = get_response(\n        summary_prompt,\n        system=\"You are a neutral, insightful moderator who can identify the merits of different viewpoints. Provide a balanced summary.\"\n    )\n\n    print(moderator)\n\n# Run the dialogue simulator\nif __name__ == \"__main__\":\n    ai_persona_dialogue_simulator()\n</code></pre>"},{"location":"mini-projects/#using-the-simulator-for-interviews","title":"Using the Simulator for Interviews","text":"<p>To use this simulator specifically for interview scenarios:</p> <ol> <li> <p>Select Format #3 (Interview) - This configures one persona to act as the interviewer and others as interviewees</p> </li> <li> <p>Choose the Interviewer - Select the \"Interviewer\" persona (option #8) for best results, though any persona can serve as an interviewer</p> </li> <li> <p>Select Interviewees - Choose which personas will be interviewed on the selected topic</p> </li> <li> <p>Set Number of Questions - Determine how many rounds of questions the interviewer will ask</p> </li> <li> <p>Interview Structure:</p> </li> <li>The interviewer begins with an opening question about the topic</li> <li>Each interviewee responds from their unique perspective</li> <li>The interviewer asks follow-up questions in subsequent rounds</li> <li>The session concludes with a wrap-up from the interviewer and final thoughts from interviewees</li> </ol> <p>This interview format is particularly useful for: - Exploring multiple perspectives on controversial topics - Demonstrating how different personality types respond to the same questions - Simulating talk show or panel interview dynamics - Teaching questioning techniques and response patterns</p>"},{"location":"mini-projects/#extension-ideas_8","title":"Extension Ideas","text":"<ul> <li>Add a feature for the user to join as an additional participant</li> <li>Create specialized formats for specific topics (ethics, technology, etc.)</li> <li>Implement a scoring system where users rate which perspective they found most compelling</li> <li>Add follow-up questions that challenge each persona's perspective</li> <li>Create a \"change my mind\" feature where personas try to persuade on a controversial topic</li> <li>Allow students to create their own custom persona profiles</li> <li>Add a feature to visualize the dialogue flow and connections between arguments</li> <li>Implement a fact-checker persona that evaluates claims made during discussions</li> <li>Create a mode where personas can switch perspectives mid-dialogue to show flexibility in thinking</li> <li>Add the ability to save transcripts for later analysis or comparison</li> </ul>"},{"location":"mini-projects/#emotional-support-bot","title":"Emotional Support Bot","text":"<p>Difficulty: Beginner-Intermediate Time: 30-45 minutes Learning Focus: Selection, text analysis, branching logic</p>"},{"location":"mini-projects/#overview_9","title":"Overview","text":"<p>Create a bot that responds differently based on the user's emotional state, providing tailored support, advice, or encouragement depending on the mood expressed.</p>"},{"location":"mini-projects/#instructions_9","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef emotional_support_bot():\n    print(\"=== Emotional Support Bot ===\")\n    print(\"This bot will respond differently based on how you're feeling.\")\n    print(\"Type 'exit' at any time to quit.\\n\")\n\n    # Define different bot personalities for different moods\n    def therapist_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a compassionate and empathetic therapist. Provide supportive, thoughtful responses that validate the user's feelings. Offer gentle guidance and perspective without being pushy. Keep responses brief and focused on emotional support.\"\n        )\n\n    def coach_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are an energetic and motivational coach. Be enthusiastic, positive, and encouraging. Help channel the user's good energy into productive actions or goals. Keep responses upbeat and action-oriented.\"\n        )\n\n    def chill_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a calm, relaxed friend. Your responses are low-pressure and soothing. Suggest restful activities and ways to recharge. Keep responses brief and gentle.\"\n        )\n\n    # Main interaction loop\n    while True:\n        # Ask how the user is feeling\n        mood = input(\"\\nHow are you feeling today? (happy, sad, tired, anxious, exit): \").lower()\n\n        # Exit condition\n        if mood == \"exit\":\n            print(\"Take care! Remember I'm here whenever you need to talk.\")\n            break\n\n        # Get more details about their state\n        if mood in [\"happy\", \"sad\", \"tired\", \"anxious\"]:\n            details = input(f\"Tell me more about why you're feeling {mood}: \")\n\n            # Select appropriate bot based on mood\n            if mood == \"sad\" or mood == \"anxious\":\n                response = therapist_bot(f\"I'm feeling {mood}. {details}\")\n            elif mood == \"happy\":\n                response = coach_bot(f\"I'm feeling {mood}! {details}\")\n            elif mood == \"tired\":\n                response = chill_bot(f\"I'm feeling {mood}. {details}\")\n\n            print(\"\\nBot's response:\")\n            print(response)\n\n            # Follow-up question based on mood\n            if mood in [\"sad\", \"anxious\"]:\n                follow_up = input(\"\\nWould you like some suggestions to help you feel better? (yes/no): \")\n                if follow_up.lower() == \"yes\":\n                    suggestions = get_response(\n                        f\"The user is feeling {mood} because: {details}. Provide 3 specific, helpful suggestions to improve their mood.\",\n                        system=\"You are a supportive counselor offering practical, actionable advice. Format your response as a numbered list.\"\n                    )\n                    print(\"\\nHere are some suggestions:\")\n                    print(suggestions)\n            elif mood == \"happy\":\n                follow_up = input(\"\\nWould you like ideas to make the most of your good mood? (yes/no): \")\n                if follow_up.lower() == \"yes\":\n                    ideas = get_response(\n                        f\"The user is feeling {mood} because: {details}. Suggest 3 ways to channel this positive energy productively.\",\n                        system=\"You are an enthusiastic coach offering creative ways to use positive energy. Format your response as a numbered list.\"\n                    )\n                    print(\"\\nHere are some ideas:\")\n                    print(ideas)\n            elif mood == \"tired\":\n                follow_up = input(\"\\nWould you like some relaxation or energy tips? (relax/energy): \")\n                if follow_up.lower() == \"relax\":\n                    tips = get_response(\n                        \"Suggest 3 calming activities for someone who is tired and wants to relax.\",\n                        system=\"You are a wellness coach specializing in restful activities. Format your response as a numbered list.\"\n                    )\n                    print(\"\\nRelaxation suggestions:\")\n                    print(tips)\n                elif follow_up.lower() == \"energy\":\n                    tips = get_response(\n                        \"Suggest 3 gentle ways to boost energy when feeling tired without causing stress.\",\n                        system=\"You are a wellness coach specializing in natural energy boosters. Format your response as a numbered list.\"\n                    )\n                    print(\"\\nEnergy-boosting suggestions:\")\n                    print(tips)\n        else:\n            print(\"I don't recognize that mood. Please try again with happy, sad, tired, or anxious.\")\n\n# Run the emotional support bot\nif __name__ == \"__main__\":\n    emotional_support_bot()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_9","title":"Extension Ideas","text":"<ul> <li>Add more emotional states and corresponding bot personalities</li> <li>Create a mood tracking feature that remembers past interactions</li> <li>Implement sentiment analysis to detect mood from user's free text input</li> <li>Create a guided meditation or breathing exercise option</li> <li>Allow users to rate how helpful the responses were to improve the bot</li> </ul>"},{"location":"mini-projects/#historical-figure-chat","title":"Historical Figure Chat","text":"<p>Difficulty: Beginner-Intermediate Time: 30-45 minutes Learning Focus: Historical research, character perspective, dialogue</p>"},{"location":"mini-projects/#overview_10","title":"Overview","text":"<p>Chat with simulated historical figures to learn about their lives, achievements, and time periods.</p>"},{"location":"mini-projects/#instructions_10","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport random\n\ndef historical_figure_chat():\n    \"\"\"Chat with simulated historical figures\"\"\"\n    # Available historical figures\n    figures = {\n        \"Albert Einstein\": \"physicist who developed the theory of relativity\",\n        \"Marie Curie\": \"physicist and chemist who conducted pioneering research on radioactivity\",\n        \"Leonardo da Vinci\": \"Renaissance polymath known for art and inventions\",\n        \"Ada Lovelace\": \"mathematician and writer, known for work on Babbage's Analytical Engine\",\n        \"Martin Luther King Jr.\": \"civil rights leader and advocate for nonviolent resistance\",\n        \"Cleopatra\": \"last active ruler of the Ptolemaic Kingdom of Egypt\",\n        \"Mahatma Gandhi\": \"leader of India's nonviolent independence movement\",\n        \"Confucius\": \"Chinese philosopher and politician of the Spring and Autumn period\",\n        \"Frida Kahlo\": \"Mexican painter known for her portraits and works inspired by nature\",\n        \"Nelson Mandela\": \"revolutionary and political leader who served as President of South Africa\"\n    }\n\n    print(\"=== Historical Figure Chat ===\")\n    print(\"Available historical figures:\")\n\n    figure_list = list(figures.keys())\n    for i, figure in enumerate(figure_list):\n        print(f\"{i+1}. {figure} - {figures[figure]}\")\n\n    figure_choice = int(input(\"\\nSelect a figure (1-10): \")) - 1\n    figure = figure_list[figure_choice]\n\n    system_prompt = f\"\"\"\n    You are {figure}, {figures[figure]}.\n    Respond as if you are this historical figure, with appropriate knowledge, perspective, and speaking style.\n    Your knowledge is limited to what was known during your lifetime and your own experiences.\n    If asked about events after your lifetime, you should acknowledge you wouldn't know about them.\n    Maintain the personality, values, and worldview of {figure} based on historical accounts.\n    \"\"\"\n\n    print(f\"\\n=== Conversation with {figure} ===\")\n    print(f\"You are now chatting with {figure}. Type 'exit' to end.\")\n\n    # Welcome message\n    greetings = [\n        f\"Greetings! I am {figure}. What would you like to discuss?\",\n        f\"Hello there! {figure} at your service. How may I assist you?\",\n        f\"Welcome! You're speaking with {figure}. What's on your mind?\",\n        f\"Ah, a visitor! I am {figure}. What would you like to know?\",\n        f\"Good day! It's {figure} here. What shall we talk about?\"\n    ]\n\n    print(\"\\n\" + random.choice(greetings))\n\n    # Chat loop\n    while True:\n        user_input = input(\"\\nYou: \")\n\n        if user_input.lower() == \"exit\":\n            print(f\"\\n{figure}: Farewell! It was a pleasure speaking with you.\")\n            break\n\n        response = get_response(user_input, system=system_prompt)\n        print(f\"\\n{figure}: {response}\")\n\n# Run the historical figure chat\nif __name__ == \"__main__\":\n    historical_figure_chat()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_10","title":"Extension Ideas","text":"<p>Add a \"time travel interview\" mode where students can interview multiple figures about the same topic or event.</p>"},{"location":"mini-projects/#image-gallery-creator","title":"Image Gallery Creator","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: File handling, HTML generation, metadata management, API integration</p>"},{"location":"mini-projects/#overview_11","title":"Overview","text":"<p>Create a tool that generates an HTML gallery from a collection of images. The tool manages image metadata, generates descriptions (optionally with AI assistance), and creates a responsive web gallery to showcase the images.</p>"},{"location":"mini-projects/#instructions_11","title":"Instructions","text":"<pre><code>import os\nimport json\nfrom chatcraft import get_response\nfrom datetime import datetime\n\ndef create_image_gallery():\n    \"\"\"\n    Creates an HTML image gallery from a collection of images.\n    Students can add their own images to the 'gallery_images' folder.\n    \"\"\"\n\n    print(\"=== Image Gallery Creator ===\")\n\n    # Create necessary directories\n    image_dir = \"gallery_images\"\n    output_dir = \"gallery_output\"\n    os.makedirs(image_dir, exist_ok=True)\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Check if there are images to process\n    image_files = [f for f in os.listdir(image_dir) \n                  if f.lower().endswith(('.jpg', '.jpeg', '.png', '.gif'))]\n\n    if not image_files:\n        print(f\"No images found in '{image_dir}' folder.\")\n        print(f\"Please add some image files (JPG, PNG, GIF) to the '{image_dir}' folder.\")\n        return\n\n    print(f\"Found {len(image_files)} images.\")\n\n    # Load existing metadata or create new\n    metadata_file = os.path.join(output_dir, \"gallery_metadata.json\")\n    if os.path.exists(metadata_file):\n        with open(metadata_file, 'r') as f:\n            try:\n                gallery_data = json.load(f)\n            except json.JSONDecodeError:\n                gallery_data = {\"title\": \"My Image Gallery\", \"images\": []}\n    else:\n        gallery_data = {\"title\": \"My Image Gallery\", \"images\": []}\n\n    # Update gallery title\n    gallery_title = input(f\"Gallery title [{gallery_data['title']}]: \")\n    if gallery_title:\n        gallery_data[\"title\"] = gallery_title\n\n    # Process each image\n    existing_images = {img[\"filename\"]: img for img in gallery_data[\"images\"]}\n\n    for image_file in image_files:\n        if image_file in existing_images:\n            # Image already has metadata\n            print(f\"\\nImage {image_file} already has metadata:\")\n            print(f\"Title: {existing_images[image_file]['title']}\")\n            print(f\"Description: {existing_images[image_file]['description']}\")\n\n            update = input(\"Update this image's information? (y/n): \").lower() == 'y'\n            if not update:\n                continue\n\n        print(f\"\\nProcessing: {image_file}\")\n\n        # Get metadata for this image\n        default_title = os.path.splitext(image_file)[0].replace('_', ' ').title()\n        title = input(f\"Image title [{default_title}]: \") or default_title\n\n        description = input(\"Image description: \")\n\n        # Optionally generate description using AI\n        if not description:\n            generate_ai = input(\"Generate description with AI? (y/n): \").lower() == 'y'\n            if generate_ai:\n                try:\n                    prompt = f\"Generate a brief, interesting description for an image named '{image_file}'. Create something imaginative based on the filename, without stating that you're guessing or that you haven't seen the image.\"\n                    description = get_response(prompt)\n                    print(f\"AI-generated description: {description}\")\n                    use_desc = input(\"Use this description? (y/n): \").lower() == 'y'\n                    if not use_desc:\n                        description = input(\"Enter alternative description: \")\n                except Exception as e:\n                    print(f\"Error generating AI description: {e}\")\n                    description = input(\"Enter description manually: \")\n\n        # Add or update metadata\n        image_data = {\n            \"filename\": image_file,\n            \"title\": title,\n            \"description\": description,\n            \"date_added\": datetime.now().strftime(\"%Y-%m-%d\")\n        }\n\n        if image_file in existing_images:\n            # Update existing entry\n            for i, img in enumerate(gallery_data[\"images\"]):\n                if img[\"filename\"] == image_file:\n                    gallery_data[\"images\"][i] = image_data\n                    break\n        else:\n            # Add new entry\n            gallery_data[\"images\"].append(image_data)\n\n    # Save updated metadata\n    with open(metadata_file, 'w') as f:\n        json.dump(gallery_data, f, indent=2)\n\n    print(\"\\nGenerating HTML gallery...\")\n\n    # Generate HTML gallery\n    html_output = f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;{gallery_data['title']}&lt;/title&gt;\n    &lt;style&gt;\n        body {{\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }}\n        h1 {{\n            text-align: center;\n            color: #333;\n        }}\n        .gallery {{\n            display: grid;\n            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n            grid-gap: 20px;\n            max-width: 1200px;\n            margin: 0 auto;\n        }}\n        .gallery-item {{\n            border-radius: 5px;\n            overflow: hidden;\n            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);\n            background-color: white;\n            transition: transform 0.3s;\n        }}\n        .gallery-item:hover {{\n            transform: translateY(-5px);\n        }}\n        .gallery-image {{\n            width: 100%;\n            height: 200px;\n            object-fit: cover;\n        }}\n        .gallery-content {{\n            padding: 15px;\n        }}\n        .gallery-title {{\n            margin-top: 0;\n            color: #333;\n        }}\n        .gallery-description {{\n            color: #666;\n            font-size: 0.9em;\n        }}\n        .gallery-date {{\n            color: #999;\n            font-size: 0.8em;\n            text-align: right;\n            margin-top: 10px;\n        }}\n        footer {{\n            text-align: center;\n            margin-top: 30px;\n            color: #999;\n            font-size: 0.8em;\n        }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{gallery_data['title']}&lt;/h1&gt;\n\n    &lt;div class=\"gallery\"&gt;\n\"\"\"\n\n    # Add each image to the gallery\n    for img in gallery_data[\"images\"]:\n        html_output += f\"\"\"        &lt;div class=\"gallery-item\"&gt;\n            &lt;img src=\"../{image_dir}/{img['filename']}\" alt=\"{img['title']}\" class=\"gallery-image\"&gt;\n            &lt;div class=\"gallery-content\"&gt;\n                &lt;h3 class=\"gallery-title\"&gt;{img['title']}&lt;/h3&gt;\n                &lt;p class=\"gallery-description\"&gt;{img['description']}&lt;/p&gt;\n                &lt;p class=\"gallery-date\"&gt;Added: {img['date_added']}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\"\"\"\n\n    # Complete the HTML\n    html_output += \"\"\"    &lt;/div&gt;\n\n    &lt;footer&gt;\n        &lt;p&gt;Created with Image Gallery Creator&lt;/p&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n    # Save the HTML file\n    html_file = os.path.join(output_dir, \"index.html\")\n    with open(html_file, 'w') as f:\n        f.write(html_output)\n\n    print(f\"\\nGallery created successfully!\")\n    print(f\"HTML file saved to: {html_file}\")\n    print(f\"Open this file in a web browser to view your gallery.\")\n\n    # Optional: Open the gallery in the default browser\n    try_open = input(\"\\nOpen gallery in browser? (y/n): \").lower() == 'y'\n    if try_open:\n        try:\n            import webbrowser\n            webbrowser.open('file://' + os.path.abspath(html_file))\n        except Exception as e:\n            print(f\"Could not open browser: {e}\")\n\n# Run the gallery creator\nif __name__ == \"__main__\":\n    create_image_gallery()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_11","title":"Extension Ideas","text":"<ul> <li>Add image filtering by tags or categories</li> <li>Implement image resizing and thumbnail generation</li> <li>Create a lightbox effect for viewing full-size images</li> <li>Add EXIF data extraction to display camera information</li> <li>Implement a theme selector with different gallery styles</li> <li>Create a server-side component to host the gallery online</li> </ul>"},{"location":"mini-projects/#journal-or-reflection-bot","title":"Journal or Reflection Bot","text":"<p>Difficulty: Beginner-Intermediate Time: 30-45 minutes Learning Focus: Lists, memory, summarization</p>"},{"location":"mini-projects/#overview_12","title":"Overview","text":"<p>Create a digital journaling assistant that helps users reflect on their experiences, identify patterns in their thoughts, and provide meaningful insights or feedback on their entries.</p>"},{"location":"mini-projects/#instructions_12","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport datetime\nimport os\n\ndef reflection_journal():\n    print(\"=== Personal Reflection Journal ===\")\n    print(\"Use this bot to keep track of your thoughts and receive insights.\")\n    print(\"Type 'exit' at any time to quit.\\n\")\n\n    # Create a list to store journal entries\n    memory = []\n\n    # Create a simple file-based storage system\n    journal_file = \"journal_entries.txt\"\n\n    # Load previous entries if file exists\n    if os.path.exists(journal_file):\n        try:\n            with open(journal_file, 'r') as f:\n                previous_entries = f.read().strip()\n                if previous_entries:\n                    print(\"Found previous journal entries.\")\n                    restore = input(\"Would you like to include them in today's reflection? (yes/no): \").lower()\n                    if restore == \"yes\":\n                        memory.append(previous_entries)\n                        print(\"Previous entries loaded.\")\n        except Exception as e:\n            print(f\"Error loading previous entries: {e}\")\n\n    # Main journaling loop\n    num_entries = int(input(\"How many things would you like to reflect on today? (1-5): \"))\n    num_entries = min(max(1, num_entries), 5)  # Ensure between 1 and 5\n\n    for i in range(num_entries):\n        print(f\"\\n--- Entry {i+1}/{num_entries} ---\")\n\n        # Prompt options\n        prompts = [\n            \"What's something that happened today that you'd like to reflect on?\",\n            \"What's something you learned today?\",\n            \"What's something you're grateful for today?\",\n            \"What's something that challenged you today?\",\n            \"What's something you're looking forward to?\"\n        ]\n\n        # Let user choose a prompt or write their own\n        print(\"Choose a prompt or create your own:\")\n        for j, prompt in enumerate(prompts, 1):\n            print(f\"{j}. {prompt}\")\n        print(f\"{len(prompts) + 1}. Write my own prompt\")\n\n        prompt_choice = input(\"\\nEnter choice (1-6): \")\n\n        # Exit condition\n        if prompt_choice.lower() == \"exit\":\n            break\n\n        # Get the prompt\n        try:\n            choice_num = int(prompt_choice)\n            if 1 &lt;= choice_num &lt;= len(prompts):\n                selected_prompt = prompts[choice_num - 1]\n            else:\n                selected_prompt = input(\"Enter your custom prompt: \")\n        except ValueError:\n            selected_prompt = prompts[0]  # Default to first prompt if invalid input\n\n        # Get the journal entry\n        print(f\"\\n{selected_prompt}\")\n        entry = input(\"&gt; \")\n\n        # Exit condition\n        if entry.lower() == \"exit\":\n            break\n\n        # Record the timestamp and add to memory\n        timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M\")\n        full_entry = f\"[{timestamp}] {selected_prompt}\\n{entry}\"\n        memory.append(full_entry)\n\n        # Give immediate reflection\n        if i &lt; num_entries - 1:  # Only for entries except the last one\n            reflection = get_response(\n                f\"The user wrote this journal entry: {entry}\\n\\nGive a brief, thoughtful response that might help them reflect deeper.\",\n                system=\"You are a supportive journaling assistant. Respond with 1-2 sentences that are empathetic and thought-provoking, but not advice-giving.\"\n            )\n            print(\"\\nReflection:\")\n            print(reflection)\n\n    # If we have entries, save them and provide insights\n    if memory:\n        # Save entries to file\n        try:\n            with open(journal_file, 'a') as f:\n                for entry in memory:\n                    f.write(entry + \"\\n\\n\")\n            print(\"\\nJournal entries saved.\")\n        except Exception as e:\n            print(f\"Error saving entries: {e}\")\n\n        # Combine all entries for analysis\n        all_entries = \"\\n\\n\".join(memory)\n\n        # Generate insights\n        print(\"\\n=== Journal Insights ===\")\n        insights = get_response(\n            f\"Here are the user's journal entries:\\n\\n{all_entries}\\n\\nProvide thoughtful insights about these reflections.\",\n            system=\"You are an insightful journaling assistant. Analyze these entries for patterns, themes, or notable elements. Provide 3-4 helpful observations that might help the user understand their thoughts better. Be supportive and thoughtful.\"\n        )\n\n        print(insights)\n\n        # Offer a follow-up question\n        print(\"\\n=== Reflection Question ===\")\n        question = get_response(\n            f\"Based on these journal entries:\\n\\n{all_entries}\\n\\nProvide one thoughtful question that would help the user reflect more deeply.\",\n            system=\"You are a reflective journaling coach. Create one open-ended, thought-provoking question that will help the user explore their thoughts more deeply. The question should be specific to the content of their entries.\"\n        )\n\n        print(question)\n    else:\n        print(\"No journal entries were recorded.\")\n\n# Run the reflection journal\nif __name__ == \"__main__\":\n    reflection_journal()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_12","title":"Extension Ideas","text":"<ul> <li>Add mood tracking to each entry</li> <li>Create visualizations of common themes or topics over time</li> <li>Add a guided meditation option based on journal content</li> <li>Implement a goal-setting feature that references past entries</li> <li>Create specialized journaling templates for different purposes (gratitude, productivity, etc.)</li> </ul>"},{"location":"mini-projects/#knowledge-quiz-bot","title":"Knowledge Quiz Bot","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: Lists, loops, conditionals, scoring systems</p>"},{"location":"mini-projects/#overview_13","title":"Overview","text":"<p>Build a bot that quizzes the user on a topic and tracks their score.</p>"},{"location":"mini-projects/#instructions_13","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport random\n\ndef generate_questions(topic, number_of_questions=5):\n    \"\"\"Generate quiz questions about a specific topic\"\"\"\n    system_prompt = f\"\"\"\n    Create {number_of_questions} multiple-choice quiz questions about {topic}.\n    For each question, provide:\n    1. The question\n    2. Four possible answers labeled A, B, C, D\n    3. The correct answer letter\n    Format exactly as follows for each question:\n    QUESTION: (the question)\n    A. (option A)\n    B. (option B)\n    C. (option C)\n    D. (option D)\n    CORRECT: (correct letter)\n    \"\"\"\n\n    response = get_response(f\"Generate quiz questions about {topic}\", system=system_prompt)\n    questions = []\n\n    # Parse the response into a structured format\n    sections = response.split(\"QUESTION: \")\n    for section in sections[1:]:  # Skip first empty section\n        question_parts = section.strip().split(\"CORRECT: \")\n        options_text = question_parts[0]\n        correct_answer = question_parts[1].strip()[0]  # Just take the letter\n\n        # Split the question from options\n        question_lines = options_text.split(\"\\n\")\n        question = question_lines[0].strip()\n        options = question_lines[1:5]\n\n        questions.append({\n            \"question\": question,\n            \"options\": options,\n            \"correct\": correct_answer\n        })\n\n    return questions\n\ndef run_quiz():\n    \"\"\"Run an interactive quiz\"\"\"\n    print(\"Welcome to the Quiz Bot!\")\n    topic = input(\"What topic would you like to be quizzed on? \")\n\n    print(f\"\\nGenerating quiz questions about {topic}...\")\n    questions = generate_questions(topic)\n\n    score = 0\n\n    for i, q in enumerate(questions):\n        print(f\"\\nQuestion {i+1}: {q['question']}\")\n        for option in q['options']:\n            print(option)\n\n        user_answer = input(\"\\nYour answer (A, B, C, or D): \").strip().upper()\n\n        if user_answer == q['correct']:\n            print(\"Correct! \u2705\")\n            score += 1\n        else:\n            print(f\"Incorrect. The correct answer was {q['correct']}. \u274c\")\n\n    print(f\"\\nQuiz complete! Your score: {score}/{len(questions)}\")\n    percentage = (score / len(questions)) * 100\n\n    # Get feedback based on score\n    feedback_prompt = f\"The user scored {percentage}% on a quiz about {topic}. Give them a short, encouraging message based on their score.\"\n    feedback = get_response(feedback_prompt)\n    print(f\"\\n{feedback}\")\n\n# Run the quiz\nif __name__ == \"__main__\":\n    run_quiz()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_13","title":"Extension Ideas","text":"<p>Add difficulty levels, timing, or topic categories.</p>"},{"location":"mini-projects/#language-translation-helper","title":"Language Translation Helper","text":"<p>Difficulty: Beginner Time: 30-45 minutes Learning Focus: Multilingual communication, cultural context</p>"},{"location":"mini-projects/#overview_14","title":"Overview","text":"<p>Create a tool that helps translate text between languages and explains cultural context.</p>"},{"location":"mini-projects/#instructions_14","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef translation_helper():\n    \"\"\"Tool to translate text and explain cultural context\"\"\"\n    # Available languages\n    languages = [\n        \"Spanish\", \"French\", \"German\", \"Italian\", \"Portuguese\", \n        \"Japanese\", \"Chinese\", \"Russian\", \"Arabic\", \"Hindi\"\n    ]\n\n    print(\"=== Language Translation Helper ===\")\n    print(\"1. Translate text\")\n    print(\"2. Learn useful phrases\")\n    print(\"3. Understand cultural context\")\n\n    choice = input(\"\\nWhat would you like to do? \")\n\n    if choice == \"1\":\n        # Translate text\n        print(\"\\nAvailable languages:\")\n        for i, lang in enumerate(languages):\n            print(f\"{i+1}. {lang}\")\n\n        source_lang = input(\"\\nFrom which language (or English)? \")\n        target_idx = int(input(\"Translate to which language (number)? \")) - 1\n        target_lang = languages[target_idx]\n\n        text = input(\"\\nEnter the text to translate: \")\n\n        system_prompt = f\"\"\"\n        You are a helpful translator between {source_lang} and {target_lang}.\n        Provide accurate translations while preserving meaning and tone.\n        For longer texts, include both a translation and a brief summary of the content.\n        \"\"\"\n\n        translate_prompt = f\"\"\"\n        Translate this {source_lang} text to {target_lang}:\n\n        \"{text}\"\n\n        Provide:\n        1. The translation\n        2. Pronunciation help (if applicable)\n        3. Any idiomatic expressions or culturally specific references explained\n        \"\"\"\n\n        print(f\"\\nTranslating from {source_lang} to {target_lang}...\")\n        translation = get_response(translate_prompt, system=system_prompt)\n\n        print(\"\\n=== Translation Results ===\")\n        print(translation)\n\n    elif choice == \"2\":\n        # Learn useful phrases\n        print(\"\\nAvailable languages:\")\n        for i, lang in enumerate(languages):\n            print(f\"{i+1}. {lang}\")\n\n        lang_idx = int(input(\"\\nWhich language (number)? \")) - 1\n        language = languages[lang_idx]\n\n        situation = input(\"\\nWhat situation do you need phrases for (e.g., restaurant, shopping, emergency)? \")\n\n        system_prompt = f\"\"\"\n        You are a helpful language guide who provides useful {language} phrases for travelers.\n        You provide accurate phrases, pronunciation guides, and cultural context.\n        \"\"\"\n\n        phrases_prompt = f\"\"\"\n        Provide useful {language} phrases for {situation} situations.\n\n        Include:\n        1. At least 5 essential phrases with English translations\n        2. Pronunciation guide for each phrase\n        3. Any cultural considerations to be aware of\n        4. When and how to use each phrase appropriately\n        \"\"\"\n\n        print(f\"\\nFinding useful {language} phrases for {situation}...\")\n        phrases = get_response(phrases_prompt, system=system_prompt)\n\n        print(f\"\\n=== Useful {language} Phrases for {situation.title()} ===\")\n        print(phrases)\n\n    elif choice == \"3\":\n        # Cultural context\n        print(\"\\nAvailable cultures/regions:\")\n        cultures = [lang + \"-speaking regions\" for lang in languages]\n        cultures.extend([\"Latin America\", \"Middle East\", \"Southeast Asia\", \"Nordic countries\"])\n\n        for i, culture in enumerate(cultures):\n            print(f\"{i+1}. {culture}\")\n\n        culture_idx = int(input(\"\\nWhich culture/region (number)? \")) - 1\n        culture = cultures[culture_idx]\n\n        aspect = input(\"\\nWhat cultural aspect are you interested in (e.g., greetings, dining, business, gestures)? \")\n\n        system_prompt = \"\"\"\n        You are a cultural consultant who helps people understand and respect different cultures.\n        You provide accurate, nuanced information about cultural practices, values, and etiquette.\n        \"\"\"\n\n        culture_prompt = f\"\"\"\n        Explain important aspects of {aspect} in {culture}.\n\n        Include:\n        1. Key cultural norms and expectations\n        2. Do's and don'ts to be aware of\n        3. How practices might differ from Western/American norms\n        4. Any regional variations to be aware of\n        5. Historical or social context that helps explain these practices\n        \"\"\"\n\n        print(f\"\\nResearching {aspect} in {culture}...\")\n        cultural_info = get_response(culture_prompt, system=system_prompt)\n\n        print(f\"\\n=== {aspect.title()} in {culture} ===\")\n        print(cultural_info)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the translation helper\nif __name__ == \"__main__\":\n    translation_helper()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_14","title":"Extension Ideas","text":"<p>Add a conversation practice mode where students can simulate dialogues in another language.</p>"},{"location":"mini-projects/#mood-journal-assistant","title":"Mood Journal Assistant","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: File I/O, date handling, text analysis</p>"},{"location":"mini-projects/#overview_15","title":"Overview","text":"<p>Create a journaling assistant that helps users track moods and reflect on patterns.</p>"},{"location":"mini-projects/#instructions_15","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport datetime\nimport os\nimport json\n\ndef mood_journal():\n    \"\"\"Interactive mood journaling assistant\"\"\"\n    journal_dir = os.path.expanduser(\"~/.mood_journal\")\n    os.makedirs(journal_dir, exist_ok=True)\n\n    journal_file = os.path.join(journal_dir, \"journal_entries.json\")\n\n    # Load existing entries\n    if os.path.exists(journal_file):\n        with open(journal_file, 'r') as f:\n            try:\n                entries = json.load(f)\n            except json.JSONDecodeError:\n                entries = []\n    else:\n        entries = []\n\n    # Get today's date\n    today = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n\n    print(\"=== Mood Journal Assistant ===\")\n    print(\"1. Add a new entry\")\n    print(\"2. View past entries\")\n    print(\"3. Get insights\")\n\n    choice = input(\"\\nWhat would you like to do? \")\n\n    if choice == \"1\":\n        # Add new entry\n        mood = input(\"\\nHow would you rate your mood today (1-10)? \")\n        activities = input(\"What activities did you do today? \")\n        thoughts = input(\"Share any thoughts or reflections: \")\n\n        entry = {\n            \"date\": today,\n            \"mood\": mood,\n            \"activities\": activities,\n            \"thoughts\": thoughts\n        }\n\n        entries.append(entry)\n\n        # Save updated entries\n        with open(journal_file, 'w') as f:\n            json.dump(entries, f, indent=2)\n\n        # Get AI reflection\n        reflection_prompt = f\"\"\"\n        The user rated their mood as {mood}/10 today.\n        They did these activities: {activities}\n        Their thoughts: {thoughts}\n\n        Provide a thoughtful, supportive reflection on their entry.\n        \"\"\"\n\n        reflection = get_response(reflection_prompt, \n                                 system=\"You are a supportive, empathetic journaling assistant.\")\n        print(\"\\n=== Reflection ===\")\n        print(reflection)\n\n    elif choice == \"2\":\n        # View past entries\n        if not entries:\n            print(\"No entries found.\")\n            return\n\n        print(\"\\n=== Past Entries ===\")\n        for i, entry in enumerate(reversed(entries[-10:])):  # Show last 10 entries\n            print(f\"{i+1}. {entry['date']} - Mood: {entry['mood']}/10\")\n\n        entry_choice = input(\"\\nWhich entry would you like to view? (number) \")\n        try:\n            idx = int(entry_choice) - 1\n            entry = list(reversed(entries[-10:]))[idx]\n            print(f\"\\nDate: {entry['date']}\")\n            print(f\"Mood: {entry['mood']}/10\")\n            print(f\"Activities: {entry['activities']}\")\n            print(f\"Thoughts: {entry['thoughts']}\")\n        except (ValueError, IndexError):\n            print(\"Invalid entry number.\")\n\n    elif choice == \"3\":\n        # Get insights\n        if len(entries) &lt; 3:\n            print(\"Need more entries to generate insights (at least 3).\")\n            return\n\n        # Create a summary of recent entries\n        recent_entries = entries[-7:]  # Last 7 entries\n        entries_text = \"\"\n\n        for entry in recent_entries:\n            entries_text += f\"Date: {entry['date']}, Mood: {entry['mood']}/10\\n\"\n            entries_text += f\"Activities: {entry['activities']}\\n\"\n            entries_text += f\"Thoughts: {entry['thoughts']}\\n\\n\"\n\n        insight_prompt = f\"\"\"\n        Here are the user's recent journal entries:\n\n        {entries_text}\n\n        Based on these entries, provide:\n        1. Any patterns you notice in their mood\n        2. Activities that seem to correlate with higher moods\n        3. Gentle suggestions that might help improve their wellbeing\n        4. A positive affirmation\n        \"\"\"\n\n        insights = get_response(insight_prompt, \n                               system=\"You are an insightful, supportive journaling assistant who helps identify patterns in mood and behavior.\")\n        print(\"\\n=== Mood Insights ===\")\n        print(insights)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the journal\nif __name__ == \"__main__\":\n    mood_journal()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_15","title":"Extension Ideas","text":"<p>Add mood tracking visualizations or goal-setting features.</p>"},{"location":"mini-projects/#pdf-question-answering-chatbot","title":"PDF Question Answering Chatbot","text":"<p>Difficulty: Intermediate-Advanced Time: 60-90 minutes Learning Focus: Document processing, natural language understanding, information retrieval</p>"},{"location":"mini-projects/#overview_16","title":"Overview","text":"<p>Create a chatbot that can answer questions from a PDF document. This project teaches students how to extract and process text from PDFs and use AI to retrieve relevant information based on user queries.</p>"},{"location":"mini-projects/#instructions_16","title":"Instructions","text":"<pre><code>import os\nimport sys\nimport fitz  # PyMuPDF\nfrom chatcraft import get_response\n\nclass PDFChatbot:\n    \"\"\"A chatbot that can answer questions about PDF documents.\"\"\"\n\n    def __init__(self):\n        self.pdf_file = None\n        self.pdf_text = \"\"\n        self.context_size = 5000  # Max context size to send to the AI\n\n    def load_pdf(self, file_path):\n        \"\"\"Load and extract text from a PDF file.\"\"\"\n        try:\n            if not os.path.exists(file_path):\n                print(f\"Error: File '{file_path}' not found.\")\n                return False\n\n            self.pdf_file = file_path\n\n            # Open the PDF\n            doc = fitz.open(file_path)\n\n            # Extract text from all pages\n            full_text = []\n            for page_num in range(len(doc)):\n                page = doc.load_page(page_num)\n                full_text.append(page.get_text())\n\n            self.pdf_text = \"\\n\".join(full_text)\n\n            # Print document stats\n            print(f\"\\nDocument loaded: {os.path.basename(file_path)}\")\n            print(f\"Number of pages: {len(doc)}\")\n            print(f\"Total characters: {len(self.pdf_text)}\")\n\n            # Print a preview\n            preview_length = min(200, len(self.pdf_text))\n            print(f\"\\nPreview:\\n{self.pdf_text[:preview_length]}...\")\n\n            return True\n\n        except Exception as e:\n            print(f\"Error loading PDF: {e}\")\n            return False\n\n    def summarize_document(self):\n        \"\"\"Generate a summary of the document.\"\"\"\n        if not self.pdf_text:\n            print(\"Error: No document loaded. Please load a PDF first.\")\n            return\n\n        print(\"\\nGenerating document summary...\")\n\n        # Create a prompt for the AI\n        prompt = f\"\"\"\n        Please provide a concise summary of the following document:\n\n        {self.pdf_text[:5000]}  # Send only the first part if the document is large\n\n        Include:\n        1. Main topics and themes\n        2. Key points or arguments\n        3. Important entities mentioned\n        4. Document structure overview\n\n        Keep the summary under 300 words.\n        \"\"\"\n\n        try:\n            summary = get_response(prompt)\n            print(\"\\n=== Document Summary ===\")\n            print(summary)\n        except Exception as e:\n            print(f\"Error generating summary: {e}\")\n\n    def answer_question(self, question):\n        \"\"\"Answer a question about the document.\"\"\"\n        if not self.pdf_text:\n            print(\"Error: No document loaded. Please load a PDF first.\")\n            return\n\n        if not question:\n            print(\"Error: No question provided.\")\n            return\n\n        print(f\"\\nAnswering: {question}\")\n\n        # Create a prompt for the AI\n        prompt = f\"\"\"\n        Document text:\n        {self.pdf_text[:self.context_size]}\n\n        Question: {question}\n\n        Please answer the question based only on the information provided in the document.\n        If the answer cannot be found in the document, state that clearly.\n        Provide page numbers or sections if you can determine them from the context.\n        \"\"\"\n\n        try:\n            answer = get_response(prompt)\n            print(\"\\n=== Answer ===\")\n            print(answer)\n        except Exception as e:\n            print(f\"Error generating answer: {e}\")\n\n    def extract_key_information(self):\n        \"\"\"Extract key information from the document.\"\"\"\n        if not self.pdf_text:\n            print(\"Error: No document loaded. Please load a PDF first.\")\n            return\n\n        print(\"\\nExtracting key information...\")\n\n        # Create a prompt for the AI\n        prompt = f\"\"\"\n        Please extract and organize key information from this document:\n\n        {self.pdf_text[:self.context_size]}\n\n        Extract the following (if present):\n        1. Dates and deadlines\n        2. Names and organizations\n        3. Numerical data or statistics\n        4. Definitions or technical terms\n        5. Action items or requirements\n\n        Format the information in clear categories with brief explanations.\n        \"\"\"\n\n        try:\n            key_info = get_response(prompt)\n            print(\"\\n=== Key Information ===\")\n            print(key_info)\n        except Exception as e:\n            print(f\"Error extracting information: {e}\")\n\n    def find_related_topics(self, topic):\n        \"\"\"Find information related to a specific topic in the document.\"\"\"\n        if not self.pdf_text:\n            print(\"Error: No document loaded. Please load a PDF first.\")\n            return\n\n        if not topic:\n            print(\"Error: No topic provided.\")\n            return\n\n        print(f\"\\nFinding information related to: {topic}\")\n\n        # Create a prompt for the AI\n        prompt = f\"\"\"\n        Document text:\n        {self.pdf_text[:self.context_size]}\n\n        Please find and extract all information related to the topic \"{topic}\" from the document.\n        Include any definitions, explanations, examples, or references related to this topic.\n        Organize the information in a structured way and indicate where in the document it appears if possible.\n        If the topic is not mentioned in the document, please state that clearly.\n        \"\"\"\n\n        try:\n            related_info = get_response(prompt)\n            print(f\"\\n=== Information Related to '{topic}' ===\")\n            print(related_info)\n        except Exception as e:\n            print(f\"Error finding related information: {e}\")\n\n    def run(self):\n        \"\"\"Run the PDF chatbot interface.\"\"\"\n        print(\"=== PDF Question Answering Chatbot ===\")\n        print(\"This chatbot can answer questions about PDF documents.\")\n\n        while True:\n            print(\"\\nOptions:\")\n            print(\"1. Load a PDF document\")\n            print(\"2. Get document summary\")\n            print(\"3. Ask a question\")\n            print(\"4. Extract key information\")\n            print(\"5. Find related topics\")\n            print(\"6. Exit\")\n\n            choice = input(\"\\nSelect an option (1-6): \")\n\n            if choice == '1':\n                # Load PDF\n                file_path = input(\"\\nEnter the path to a PDF file: \")\n                self.load_pdf(file_path)\n\n            elif choice == '2':\n                # Summarize document\n                self.summarize_document()\n\n            elif choice == '3':\n                # Ask a question\n                if not self.pdf_text:\n                    print(\"Please load a PDF document first (option 1).\")\n                    continue\n\n                question = input(\"\\nEnter your question about the document: \")\n                self.answer_question(question)\n\n            elif choice == '4':\n                # Extract key information\n                self.extract_key_information()\n\n            elif choice == '5':\n                # Find related topics\n                if not self.pdf_text:\n                    print(\"Please load a PDF document first (option 1).\")\n                    continue\n\n                topic = input(\"\\nEnter a topic to find in the document: \")\n                self.find_related_topics(topic)\n\n            elif choice == '6':\n                # Exit\n                print(\"\\nExiting PDF Chatbot. Goodbye!\")\n                break\n\n            else:\n                print(\"Invalid choice. Please select a number between 1 and 6.\")\n\n# Run the chatbot\nif __name__ == \"__main__\":\n    chatbot = PDFChatbot()\n    chatbot.run()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_16","title":"Extension Ideas","text":"<ul> <li>Add support for multiple document formats (DOCX, TXT, etc.)</li> <li>Implement semantic search to find specific information more efficiently</li> <li>Create a feature to compare information across multiple documents</li> <li>Add a citation generator for referencing document content</li> <li>Build a web interface using Flask or Streamlit</li> <li>Implement document chunking for handling very large documents</li> </ul>"},{"location":"mini-projects/#implementation-tips_1","title":"Implementation Tips","text":"<p>When using these advanced mini-projects in a classroom setting:</p> <ol> <li>Scaffold appropriately: Start with simpler projects for beginners, then progress to more complex ones.</li> <li>Modify complexity: Adjust project requirements based on student skill level and available time.</li> <li>Pair programming: Have students work in pairs to encourage collaboration.</li> <li>Challenge extensions: Provide additional challenges for students who finish early.</li> <li>Focus on concepts: Emphasize the programming concepts being used rather than just creating a functioning application.</li> <li>Ethical discussions: Use these projects as opportunities to discuss AI ethics, bias, and limitations.</li> </ol>"},{"location":"mini-projects/#assessment-ideas_1","title":"Assessment Ideas","text":"<ul> <li>Have students document their process in a digital portfolio</li> <li>Create a \"project showcase\" where students present their creations</li> <li>Ask students to write reflections on what they learned</li> <li>Evaluate code structure, comments, and organization</li> <li>Have students peer-review each other's projects</li> </ul> <p>These examples are designed to be flexible starting points. Adjust and expand them to suit your specific educational needs and student skill levels.</p>"},{"location":"mini-projects/#personality-bot-creator","title":"Personality Bot Creator","text":"<p>Difficulty: Beginner Time: 30-45 minutes Learning Focus: Functions, creativity, system prompts</p>"},{"location":"mini-projects/#overview_17","title":"Overview","text":"<p>Students create and interact with a bot that has a unique personality of their design. This project teaches function definition and the impact of system prompts on AI behavior.</p>"},{"location":"mini-projects/#instructions_17","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\n# Example personalities students can create:\ndef superhero_bot(prompt):\n    return get_response(\n        prompt,\n        system=\"You are a confident superhero who always thinks positively and believes any problem can be solved. You occasionally reference your superpowers and heroic deeds.\",\n        personality=\"superhero\"\n    )\n\ndef grumpy_cat_bot(prompt):\n    return get_response(\n        prompt,\n        system=\"You are a perpetually unimpressed cat. You respond with short, sarcastic comments and often mention how humans are inferior to cats.\",\n        personality=\"grumpy\"\n    )\n\ndef chef_bot(prompt):\n    return get_response(\n        prompt,\n        system=\"You are an enthusiastic chef who relates everything to cooking. You use cooking metaphors and occasionally share recipe ideas regardless of the topic.\",\n        personality=\"chef\"\n    )\n\n# Test your bot with various prompts\ntest_prompts = [\n    \"How's the weather today?\",\n    \"Can you help me with my homework?\",\n    \"What's the meaning of life?\",\n    \"Tell me about yourself.\"\n]\n\n# Choose which bot to use\nmy_bot = superhero_bot  # Change to your custom bot\n\n# Test it with each prompt\nfor prompt in test_prompts:\n    print(f\"Prompt: {prompt}\")\n    print(f\"Response: {my_bot(prompt)}\")\n    print(\"-\" * 50)\n</code></pre>"},{"location":"mini-projects/#extension-ideas_17","title":"Extension Ideas","text":"<p>Create a menu system that lets the user choose which personality to talk to.</p>"},{"location":"mini-projects/#smart-to-do-list","title":"Smart To-Do List","text":"<p>Difficulty: Intermediate Time: 60-75 minutes Learning Focus: Data structures, file I/O, date handling, AI assistance</p>"},{"location":"mini-projects/#overview_18","title":"Overview","text":"<p>Build a smart to-do list application that helps users organize tasks with categories, priorities, and due dates. The application provides AI-assisted recommendations for task management and organization.</p>"},{"location":"mini-projects/#instructions_18","title":"Instructions","text":"<pre><code>import os\nimport json\nfrom datetime import datetime, timedelta\nfrom chatcraft import get_response\n\nclass SmartTodoList:\n    \"\"\"\n    A smart to-do list that can categorize tasks, set priorities, \n    track due dates, and provide AI-assisted task management.\n    \"\"\"\n\n    def __init__(self):\n        self.tasks = []\n        self.categories = [\"Work\", \"School\", \"Personal\", \"Shopping\", \"Health\", \"Other\"]\n        self.priorities = [\"High\", \"Medium\", \"Low\"]\n        self.data_dir = \"todo_data\"\n        self.data_file = os.path.join(self.data_dir, \"tasks.json\")\n\n        # Create data directory if it doesn't exist\n        os.makedirs(self.data_dir, exist_ok=True)\n\n        # Load existing tasks if available\n        self.load_tasks()\n\n    def load_tasks(self):\n        \"\"\"Load tasks from the data file.\"\"\"\n        if os.path.exists(self.data_file):\n            try:\n                with open(self.data_file, 'r') as f:\n                    self.tasks = json.load(f)\n                print(f\"Loaded {len(self.tasks)} tasks from {self.data_file}\")\n            except json.JSONDecodeError:\n                print(\"Error reading tasks file. Starting with empty task list.\")\n                self.tasks = []\n        else:\n            print(\"No existing tasks file found. Starting with empty task list.\")\n            self.tasks = []\n\n    def save_tasks(self):\n        \"\"\"Save tasks to the data file.\"\"\"\n        with open(self.data_file, 'w') as f:\n            json.dump(self.tasks, f, indent=2)\n        print(f\"Saved {len(self.tasks)} tasks to {self.data_file}\")\n\n    def add_task(self):\n        \"\"\"Add a new task to the list.\"\"\"\n        print(\"\\n=== Add New Task ===\")\n\n        # Get task details\n        title = input(\"Task title: \")\n\n        # Select category\n        print(\"\\nCategories:\")\n        for i, category in enumerate(self.categories, 1):\n            print(f\"{i}. {category}\")\n\n        category_choice = input(f\"Select category (1-{len(self.categories)}): \")\n        try:\n            category_idx = int(category_choice) - 1\n            category = self.categories[category_idx]\n        except (ValueError, IndexError):\n            print(\"Invalid category selection. Using 'Other'.\")\n            category = \"Other\"\n\n        # Select priority\n        print(\"\\nPriorities:\")\n        for i, priority in enumerate(self.priorities, 1):\n            print(f\"{i}. {priority}\")\n\n        priority_choice = input(f\"Select priority (1-{len(self.priorities)}): \")\n        try:\n            priority_idx = int(priority_choice) - 1\n            priority = self.priorities[priority_idx]\n        except (ValueError, IndexError):\n            print(\"Invalid priority selection. Using 'Medium'.\")\n            priority = \"Medium\"\n\n        # Set due date\n        due_date = None\n        has_due_date = input(\"\\nDoes this task have a due date? (y/n): \").lower() == 'y'\n\n        if has_due_date:\n            date_format = \"%Y-%m-%d\"\n            date_input = input(\"Enter due date (YYYY-MM-DD) or relative (e.g., 'tomorrow', '3 days'): \")\n\n            try:\n                # Parse relative dates\n                if date_input.lower() == 'today':\n                    due_date = datetime.now().strftime(date_format)\n                elif date_input.lower() == 'tomorrow':\n                    due_date = (datetime.now() + timedelta(days=1)).strftime(date_format)\n                elif 'days' in date_input.lower():\n                    # Parse \"X days\" format\n                    try:\n                        days = int(date_input.split()[0])\n                        due_date = (datetime.now() + timedelta(days=days)).strftime(date_format)\n                    except (ValueError, IndexError):\n                        print(\"Could not parse relative date. Please enter a specific date.\")\n                else:\n                    # Try to parse as YYYY-MM-DD\n                    due_date = datetime.strptime(date_input, date_format).strftime(date_format)\n            except ValueError:\n                print(\"Invalid date format. Due date will not be set.\")\n\n        # Add notes\n        notes = input(\"\\nAdd any notes (optional): \")\n\n        # Create task object\n        task = {\n            \"id\": len(self.tasks) + 1,\n            \"title\": title,\n            \"category\": category,\n            \"priority\": priority,\n            \"due_date\": due_date,\n            \"notes\": notes,\n            \"completed\": False,\n            \"created_at\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        }\n\n        # Add to task list\n        self.tasks.append(task)\n        print(f\"\\nTask '{title}' added successfully!\")\n\n        # Save updated tasks\n        self.save_tasks()\n\n    def view_tasks(self, show_completed=False):\n        \"\"\"Display tasks based on filters.\"\"\"\n        if not self.tasks:\n            print(\"\\nNo tasks found.\")\n            return\n\n        filtered_tasks = [t for t in self.tasks if t[\"completed\"] == show_completed]\n\n        if not filtered_tasks:\n            status = \"completed\" if show_completed else \"pending\"\n            print(f\"\\nNo {status} tasks found.\")\n            return\n\n        # Sort tasks: first by due date (None at the end), then by priority\n        def sort_key(task):\n            # Priority order: High, Medium, Low\n            priority_order = {\"High\": 0, \"Medium\": 1, \"Low\": 2}\n\n            # Sort by due date first (None/null dates come last)\n            if task[\"due_date\"]:\n                return (0, task[\"due_date\"], priority_order.get(task[\"priority\"], 1))\n            else:\n                return (1, \"9999-99-99\", priority_order.get(task[\"priority\"], 1))\n\n        sorted_tasks = sorted(filtered_tasks, key=sort_key)\n\n        # Display tasks\n        status = \"Completed\" if show_completed else \"Pending\"\n        print(f\"\\n=== {status} Tasks ===\")\n\n        for i, task in enumerate(sorted_tasks, 1):\n            due_str = f\"Due: {task['due_date']}\" if task['due_date'] else \"No due date\"\n\n            # Add warning for tasks due today or overdue\n            warning = \"\"\n            if task['due_date']:\n                try:\n                    due_date = datetime.strptime(task['due_date'], \"%Y-%m-%d\").date()\n                    today = datetime.now().date()\n\n                    if due_date &lt; today and not task['completed']:\n                        warning = \" [OVERDUE!]\"\n                    elif due_date == today and not task['completed']:\n                        warning = \" [DUE TODAY!]\"\n                except ValueError:\n                    pass\n\n            print(f\"{i}. [{task['priority']}] {task['title']}{warning} - {due_str} ({task['category']})\")\n\n        # Return the sorted tasks for selection\n        return sorted_tasks\n\n    def toggle_task_status(self):\n        \"\"\"Mark a task as completed or pending.\"\"\"\n        print(\"\\n=== Toggle Task Status ===\")\n\n        # Show pending tasks first\n        pending_tasks = self.view_tasks(show_completed=False)\n\n        if pending_tasks:\n            # Show completed tasks\n            print(\"\\n=== Completed Tasks ===\")\n            completed_tasks = self.view_tasks(show_completed=True)\n\n            # Ask which list to toggle from\n            toggle_from = input(\"\\nToggle task from (p)ending or (c)ompleted list? \").lower()\n\n            if toggle_from == 'p' and pending_tasks:\n                task_list = pending_tasks\n                current_status = False\n            elif toggle_from == 'c' and completed_tasks:\n                task_list = completed_tasks\n                current_status = True\n            else:\n                print(\"Invalid selection or no tasks in that category.\")\n                return\n\n            # Get task number\n            task_num = input(f\"Enter task number to toggle (1-{len(task_list)}): \")\n            try:\n                idx = int(task_num) - 1\n                selected_task = task_list[idx]\n\n                # Find this task in the main task list and toggle its status\n                for task in self.tasks:\n                    if task[\"id\"] == selected_task[\"id\"]:\n                        task[\"completed\"] = not current_status\n                        status = \"completed\" if task[\"completed\"] else \"pending\"\n                        print(f\"\\nTask '{task['title']}' marked as {status}.\")\n                        break\n\n                # Save updated tasks\n                self.save_tasks()\n\n            except (ValueError, IndexError):\n                print(\"Invalid task number.\")\n\n    def edit_task(self):\n        \"\"\"Edit an existing task.\"\"\"\n        print(\"\\n=== Edit Task ===\")\n\n        # Show all tasks for selection\n        print(\"\\nAll Tasks:\")\n        all_tasks = self.tasks.copy()\n\n        # Sort tasks by completion status, then by other criteria\n        def sort_key(task):\n            return (task[\"completed\"], task.get(\"due_date\", \"9999-99-99\"), task[\"priority\"])\n\n        sorted_tasks = sorted(all_tasks, key=sort_key)\n\n        for i, task in enumerate(sorted_tasks, 1):\n            status = \"\u2713\" if task[\"completed\"] else \"\u2610\"\n            due_str = f\"Due: {task['due_date']}\" if task['due_date'] else \"No due date\"\n            print(f\"{i}. {status} [{task['priority']}] {task['title']} - {due_str} ({task['category']})\")\n\n        # Get task to edit\n        task_num = input(f\"\\nEnter task number to edit (1-{len(sorted_tasks)}): \")\n        try:\n            idx = int(task_num) - 1\n            selected_task = sorted_tasks[idx]\n\n            print(f\"\\nEditing task: {selected_task['title']}\")\n\n            # Get updated values\n            title = input(f\"Title [{selected_task['title']}]: \") or selected_task['title']\n\n            # Select category\n            print(\"\\nCategories:\")\n            for i, category in enumerate(self.categories, 1):\n                print(f\"{i}. {category}\")\n\n            category_choice = input(f\"Select category [current: {selected_task['category']}]: \")\n            if category_choice:\n                try:\n                    category_idx = int(category_choice) - 1\n                    category = self.categories[category_idx]\n                except (ValueError, IndexError):\n                    print(\"Invalid category selection. Keeping current category.\")\n                    category = selected_task['category']\n            else:\n                category = selected_task['category']\n\n            # Select priority\n            print(\"\\nPriorities:\")\n            for i, priority in enumerate(self.priorities, 1):\n                print(f\"{i}. {priority}\")\n\n            priority_choice = input(f\"Select priority [current: {selected_task['priority']}]: \")\n            if priority_choice:\n                try:\n                    priority_idx = int(priority_choice) - 1\n                    priority = self.priorities[priority_idx]\n                except (ValueError, IndexError):\n                    print(\"Invalid priority selection. Keeping current priority.\")\n                    priority = selected_task['priority']\n            else:\n                priority = selected_task['priority']\n\n            # Update due date\n            current_due = selected_task['due_date'] or \"None\"\n            due_choice = input(f\"Update due date? Current: {current_due} (y/n): \").lower()\n\n            if due_choice == 'y':\n                date_format = \"%Y-%m-%d\"\n                date_input = input(\"Enter due date (YYYY-MM-DD) or relative (e.g., 'tomorrow', '3 days'): \")\n\n                try:\n                    # Parse relative dates\n                    if date_input.lower() == 'today':\n                        due_date = datetime.now().strftime(date_format)\n                    elif date_input.lower() == 'tomorrow':\n                        due_date = (datetime.now() + timedelta(days=1)).strftime(date_format)\n                    elif 'days' in date_input.lower():\n                        # Parse \"X days\" format\n                        try:\n                            days = int(date_input.split()[0])\n                            due_date = (datetime.now() + timedelta(days=days)).strftime(date_format)\n                        except (ValueError, IndexError):\n                            print(\"Could not parse relative date. Keeping current due date.\")\n                            due_date = selected_task['due_date']\n                    elif date_input.lower() in ('none', 'remove', 'clear'):\n                        due_date = None\n                    else:\n                        # Try to parse as YYYY-MM-DD\n                        due_date = datetime.strptime(date_input, date_format).strftime(date_format)\n                except ValueError:\n                    print(\"Invalid date format. Keeping current due date.\")\n                    due_date = selected_task['due_date']\n            else:\n                due_date = selected_task['due_date']\n\n            # Update notes\n            current_notes = selected_task['notes'] or \"None\"\n            notes_choice = input(f\"Update notes? Current: {current_notes} (y/n): \").lower()\n\n            if notes_choice == 'y':\n                notes = input(\"Enter new notes: \")\n            else:\n                notes = selected_task['notes']\n\n            # Find this task in the main task list and update it\n            for task in self.tasks:\n                if task[\"id\"] == selected_task[\"id\"]:\n                    task[\"title\"] = title\n                    task[\"category\"] = category\n                    task[\"priority\"] = priority\n                    task[\"due_date\"] = due_date\n                    task[\"notes\"] = notes\n                    print(f\"\\nTask '{title}' updated successfully!\")\n                    break\n\n            # Save updated tasks\n            self.save_tasks()\n\n        except (ValueError, IndexError):\n            print(\"Invalid task number.\")\n\n    def delete_task(self):\n        \"\"\"Delete a task from the list.\"\"\"\n        print(\"\\n=== Delete Task ===\")\n\n        # Show all tasks for selection\n        print(\"\\nAll Tasks:\")\n        all_tasks = self.tasks.copy()\n\n        # Sort tasks by completion status, then by other criteria\n        def sort_key(task):\n            return (task[\"completed\"], task.get(\"due_date\", \"9999-99-99\"), task[\"priority\"])\n\n        sorted_tasks = sorted(all_tasks, key=sort_key)\n\n        for i, task in enumerate(sorted_tasks, 1):\n            status = \"\u2713\" if task[\"completed\"] else \"\u2610\"\n            due_str = f\"Due: {task['due_date']}\" if task['due_date'] else \"No due date\"\n            print(f\"{i}. {status} [{task['priority']}] {task['title']} - {due_str} ({task['category']})\")\n\n        # Get task to delete\n        task_num = input(f\"\\nEnter task number to delete (1-{len(sorted_tasks)}): \")\n        try:\n            idx = int(task_num) - 1\n            selected_task = sorted_tasks[idx]\n\n            # Confirm deletion\n            confirm = input(f\"Are you sure you want to delete '{selected_task['title']}'? (y/n): \").lower()\n\n            if confirm == 'y':\n                # Remove task from list\n                self.tasks = [t for t in self.tasks if t[\"id\"] != selected_task[\"id\"]]\n                print(f\"\\nTask '{selected_task['title']}' deleted successfully!\")\n\n                # Save updated tasks\n                self.save_tasks()\n            else:\n                print(\"Deletion cancelled.\")\n\n        except (ValueError, IndexError):\n            print(\"Invalid task number.\")\n\n    def get_ai_recommendations(self):\n        \"\"\"Get AI-assisted recommendations for task management.\"\"\"\n        if not self.tasks:\n            print(\"\\nNo tasks found. Please add some tasks first.\")\n            return\n\n        print(\"\\n=== AI Task Management Recommendations ===\")\n        print(\"Analyzing your tasks...\")\n\n        try:\n            # Prepare task data for AI\n            today = datetime.now().date()\n\n            # Count tasks by category\n            category_counts = {}\n            for task in self.tasks:\n                cat = task[\"category\"]\n                if cat in category_counts:\n                    category_counts[cat] += 1\n                else:\n                    category_counts[cat] = 1\n\n            # Count overdue tasks\n            overdue_tasks = []\n            for task in self.tasks:\n                if task[\"due_date\"] and not task[\"completed\"]:\n                    try:\n                        due_date = datetime.strptime(task[\"due_date\"], \"%Y-%m-%d\").date()\n                        if due_date &lt; today:\n                            overdue_tasks.append({\n                                \"title\": task[\"title\"],\n                                \"due_date\": task[\"due_date\"],\n                                \"days_overdue\": (today - due_date).days,\n                                \"priority\": task[\"priority\"]\n                            })\n                    except ValueError:\n                        pass\n\n            # Get tasks due today\n            today_tasks = []\n            for task in self.tasks:\n                if task[\"due_date\"] and not task[\"completed\"]:\n                    try:\n                        due_date = datetime.strptime(task[\"due_date\"], \"%Y-%m-%d\").date()\n                        if due_date == today:\n                            today_tasks.append({\n                                \"title\": task[\"title\"],\n                                \"priority\": task[\"priority\"],\n                                \"category\": task[\"category\"]\n                            })\n                    except ValueError:\n                        pass\n\n            # Get high priority tasks\n            high_priority = []\n            for task in self.tasks:\n                if task[\"priority\"] == \"High\" and not task[\"completed\"]:\n                    high_priority.append({\n                        \"title\": task[\"title\"],\n                        \"due_date\": task[\"due_date\"],\n                        \"category\": task[\"category\"]\n                    })\n\n            # Create prompt for AI\n            prompt = f\"\"\"\n            Based on the following task data, please provide helpful task management recommendations:\n\n            Task summary:\n            - Total tasks: {len(self.tasks)}\n            - Completed tasks: {sum(1 for t in self.tasks if t[\"completed\"])}\n            - Pending tasks: {sum(1 for t in self.tasks if not t[\"completed\"])}\n\n            Category breakdown: {category_counts}\n\n            Overdue tasks ({len(overdue_tasks)}):\n            {overdue_tasks if overdue_tasks else \"None\"}\n\n            Tasks due today ({len(today_tasks)}):\n            {today_tasks if today_tasks else \"None\"}\n\n            High priority pending tasks ({len(high_priority)}):\n            {high_priority if high_priority else \"None\"}\n\n            Please provide:\n            1. A prioritized action plan for the next 24 hours\n            2. Task management tips based on the current workload\n            3. Suggestions for which tasks to focus on first\n\n            Keep your response friendly, practical and under 300 words.\n            \"\"\"\n\n            # Get AI recommendations\n            recommendations = get_response(prompt)\n            print(\"\\n\" + recommendations)\n\n        except Exception as e:\n            print(f\"Error getting AI recommendations: {e}\")\n            print(\"Unable to generate AI recommendations at this time.\")\n\n    def run(self):\n        \"\"\"Run the main to-do list interface.\"\"\"\n        print(\"=== Smart To-Do List ===\")\n\n        while True:\n            print(\"\\nOptions:\")\n            print(\"1. Add new task\")\n            print(\"2. View pending tasks\")\n            print(\"3. View completed tasks\")\n            print(\"4. Toggle task status\")\n            print(\"5. Edit task\")\n            print(\"6. Delete task\")\n            print(\"7. Get AI recommendations\")\n            print(\"8. Exit\")\n\n            choice = input(\"\\nSelect an option (1-8): \")\n\n            if choice == '1':\n                self.add_task()\n            elif choice == '2':\n                self.view_tasks(show_completed=False)\n            elif choice == '3':\n                self.view_tasks(show_completed=True)\n            elif choice == '4':\n                self.toggle_task_status()\n            elif choice == '5':\n                self.edit_task()\n            elif choice == '6':\n                self.delete_task()\n            elif choice == '7':\n                self.get_ai_recommendations()\n            elif choice == '8':\n                print(\"\\nExiting Smart To-Do List. Goodbye!\")\n                break\n            else:\n                print(\"Invalid choice. Please select a number between 1 and 8.\")\n\n# Run the to-do list\nif __name__ == \"__main__\":\n    todo_list = SmartTodoList()\n    todo_list.run()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_18","title":"Extension Ideas","text":"<ul> <li>Add recurring tasks (daily, weekly, monthly)</li> <li>Implement task dependencies (tasks that require other tasks to be completed first)</li> <li>Create a calendar view to visualize task distribution</li> <li>Add a Pomodoro timer feature for focused work sessions</li> <li>Implement task sharing or collaboration features</li> <li>Create a mobile-friendly web interface using a framework like Flask</li> </ul>"},{"location":"mini-projects/#subject-expert-tutor","title":"Subject Expert Tutor","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: Domain-specific prompting, educational dialogue</p>"},{"location":"mini-projects/#overview_19","title":"Overview","text":"<p>Create a specialized tutor bot for a specific subject area that can explain concepts and quiz the user.</p>"},{"location":"mini-projects/#instructions_19","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport time\n\ndef tutor_bot():\n    \"\"\"Interactive subject tutor that explains concepts and offers practice questions\"\"\"\n    # Available subjects\n    subjects = {\n        \"math\": \"You are a patient math tutor who explains concepts step-by-step. You use analogies to make abstract ideas concrete.\",\n        \"science\": \"You are an enthusiastic science educator who relates scientific concepts to everyday experiences. You're excited about discovery and experimentation.\",\n        \"history\": \"You are a storytelling history tutor who makes historical events come alive through narrative. You emphasize cause and effect in historical developments.\",\n        \"literature\": \"You are a thoughtful literature guide who helps students analyze texts. You ask probing questions that deepen understanding of themes and characters.\",\n        \"programming\": \"You are a coding mentor who explains programming concepts with clear examples. You break down problems into manageable steps.\"\n    }\n\n    print(\"=== Subject Expert Tutor ===\")\n    print(\"Available subjects:\")\n    for i, subject in enumerate(subjects.keys()):\n        print(f\"{i+1}. {subject.title()}\")\n\n    subject_choice = int(input(\"\\nSelect a subject (1-5): \")) - 1\n    subject = list(subjects.keys())[subject_choice]\n    system_prompt = subjects[subject]\n\n    print(f\"\\n=== {subject.title()} Tutor ===\")\n    print(\"1. Ask a specific question\")\n    print(\"2. Learn a new concept\")\n    print(\"3. Take a practice quiz\")\n\n    mode = input(\"\\nWhat would you like to do? \")\n\n    if mode == \"1\":\n        # Ask specific question\n        question = input(\"\\nWhat's your question about \" + subject + \"? \")\n\n        print(\"\\nThinking...\")\n        answer = get_response(question, system=system_prompt)\n\n        print(\"\\n\" + answer)\n\n    elif mode == \"2\":\n        # Learn new concept\n        topic = input(f\"\\nWhat {subject} concept would you like to learn about? \")\n\n        learn_prompt = f\"\"\"\n        Explain the concept of {topic} in {subject} in a way that's easy to understand.\n        Include:\n        1. A simple definition\n        2. Why it's important\n        3. A real-world example or application\n        4. Any key formulas or principles (if applicable)\n        \"\"\"\n\n        print(\"\\nResearching this topic...\")\n        explanation = get_response(learn_prompt, system=system_prompt)\n\n        print(\"\\n\" + explanation)\n\n        # Check understanding\n        check_prompt = f\"Create a quick check-for-understanding question about {topic} in {subject}.\"\n        check_question = get_response(check_prompt, system=system_prompt)\n\n        print(\"\\n=== Check Your Understanding ===\")\n        print(check_question)\n\n        user_answer = input(\"\\nYour answer: \")\n\n        feedback_prompt = f\"\"\"\n        The user is learning about {topic} in {subject}.\n        I asked them: {check_question}\n        They answered: {user_answer}\n\n        Provide constructive feedback on their answer. If they're on the right track,\n        acknowledge that while adding any missing information. If they're incorrect, \n        gently correct them and re-explain the concept briefly.\n        \"\"\"\n\n        feedback = get_response(feedback_prompt, system=system_prompt)\n        print(\"\\n\" + feedback)\n\n    elif mode == \"3\":\n        # Practice quiz\n        difficulty = input(\"\\nChoose difficulty (easy/medium/hard): \").lower()\n        num_questions = 3\n\n        quiz_prompt = f\"\"\"\n        Create a {difficulty} {subject} quiz with {num_questions} questions.\n        For each question:\n        1. Ask a {difficulty}-level question about {subject}\n        2. Provide 4 possible answers labeled A, B, C, D\n        3. Indicate the correct answer\n\n        Format each question exactly like this:\n        Q: (question text)\n        A: (option A)\n        B: (option B)\n        C: (option C)\n        D: (option D)\n        Correct: (correct letter)\n        \"\"\"\n\n        print(f\"\\nGenerating a {difficulty} {subject} quiz...\")\n        quiz = get_response(quiz_prompt, system=system_prompt)\n\n        # Parse and present quiz\n        questions = []\n        sections = quiz.split(\"Q: \")\n\n        for section in sections[1:]:\n            question_parts = section.split(\"Correct: \")\n            question_text = question_parts[0].strip()\n            correct_answer = question_parts[1].strip()[0]  # Just take the first letter\n\n            questions.append({\n                \"text\": question_text,\n                \"correct\": correct_answer\n            })\n\n        # Administer quiz\n        score = 0\n        for i, q in enumerate(questions):\n            print(f\"\\nQuestion {i+1}:\")\n            print(q[\"text\"])\n\n            user_answer = input(\"\\nYour answer (A/B/C/D): \").strip().upper()\n\n            if user_answer == q[\"correct\"]:\n                print(\"\u2713 Correct!\")\n                score += 1\n            else:\n                print(f\"\u2717 Incorrect. The correct answer was {q['correct']}.\")\n\n                # Get explanation\n                explain_prompt = f\"\"\"\n                The question was: {q['text']}\n                The correct answer is {q['correct']}.\n                Explain why this is the correct answer in a helpful way.\n                \"\"\"\n\n                explanation = get_response(explain_prompt, system=system_prompt)\n                print(\"\\nExplanation:\")\n                print(explanation)\n\n            # Small pause between questions\n            if i &lt; len(questions) - 1:\n                time.sleep(1)\n\n        # Final score and feedback\n        print(f\"\\nQuiz complete! You scored {score}/{len(questions)}.\")\n\n        feedback_prompt = f\"\"\"\n        The user just completed a {difficulty} {subject} quiz and scored {score}/{len(questions)}.\n        Provide some encouraging feedback and suggest what they might want to study next.\n        \"\"\"\n\n        feedback = get_response(feedback_prompt, system=system_prompt)\n        print(\"\\n\" + feedback)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the tutor bot\nif __name__ == \"__main__\":\n    tutor_bot()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_19","title":"Extension Ideas","text":"<p>Add a spaced repetition system that tracks concepts users struggle with and revisits them.</p>"},{"location":"mini-projects/#text-adventure-game-engine","title":"Text Adventure Game Engine","text":"<p>Difficulty: Advanced Time: 90-120 minutes Learning Focus: Object-oriented programming, game design, file I/O, AI interaction</p>"},{"location":"mini-projects/#overview_20","title":"Overview","text":"<p>Create a text adventure game engine that allows students to build interactive stories with rooms, items, and characters. The engine supports saving/loading games and provides AI-powered hints to guide players.</p>"},{"location":"mini-projects/#instructions_20","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport json\nimport os\n\nclass Room:\n    \"\"\"A location in the game world with description and connections to other rooms.\"\"\"\n    def __init__(self, name, description, exits=None, items=None):\n        self.name = name\n        self.description = description\n        self.exits = exits or {}  # Dictionary mapping direction -&gt; room name\n        self.items = items or []  # List of item names\n\n    def add_exit(self, direction, room_name):\n        \"\"\"Add an exit from this room.\"\"\"\n        self.exits[direction] = room_name\n\n    def add_item(self, item):\n        \"\"\"Add an item to this room.\"\"\"\n        self.items.append(item)\n\n    def remove_item(self, item):\n        \"\"\"Remove an item from this room.\"\"\"\n        if item in self.items:\n            self.items.remove(item)\n            return True\n        return False\n\n    def get_details(self):\n        \"\"\"Get a formatted description of the room including exits and items.\"\"\"\n        details = f\"{self.name}\\n\"\n        details += f\"{'-' * len(self.name)}\\n\"\n        details += f\"{self.description}\\n\"\n\n        if self.exits:\n            details += \"\\nExits:\"\n            for direction, room in self.exits.items():\n                details += f\" {direction}\"\n\n        if self.items:\n            details += \"\\n\\nYou can see:\"\n            for item in self.items:\n                details += f\"\\n- {item}\"\n\n        return details\n\n    def to_dict(self):\n        \"\"\"Convert room to dictionary for saving.\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"exits\": self.exits,\n            \"items\": self.items\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create room from dictionary data.\"\"\"\n        return cls(\n            data[\"name\"],\n            data[\"description\"],\n            data.get(\"exits\", {}),\n            data.get(\"items\", [])\n        )\n\n\nclass Player:\n    \"\"\"The player character with inventory and current location.\"\"\"\n    def __init__(self, name, current_room=\"Starting Room\"):\n        self.name = name\n        self.current_room = current_room\n        self.inventory = []\n        self.game_flags = {}  # For tracking game state, quests, etc.\n\n    def move(self, direction, world):\n        \"\"\"Try to move in a direction. Return success/failure message.\"\"\"\n        current_room = world.get_room(self.current_room)\n\n        if direction in current_room.exits:\n            self.current_room = current_room.exits[direction]\n            return f\"You move {direction}.\"\n        else:\n            return f\"You can't go {direction} from here.\"\n\n    def take(self, item_name, world):\n        \"\"\"Try to take an item from the current room.\"\"\"\n        current_room = world.get_room(self.current_room)\n\n        for item in current_room.items:\n            if item.lower() == item_name.lower():\n                current_room.remove_item(item)\n                self.inventory.append(item)\n                return f\"You take the {item}.\"\n\n        return f\"There is no {item_name} here.\"\n\n    def drop(self, item_name, world):\n        \"\"\"Try to drop an item from inventory into the current room.\"\"\"\n        current_room = world.get_room(self.current_room)\n\n        for item in self.inventory:\n            if item.lower() == item_name.lower():\n                self.inventory.remove(item)\n                current_room.add_item(item)\n                return f\"You drop the {item}.\"\n\n        return f\"You don't have a {item_name}.\"\n\n    def check_inventory(self):\n        \"\"\"Check what items the player is carrying.\"\"\"\n        if not self.inventory:\n            return \"Your inventory is empty.\"\n\n        result = \"You are carrying:\"\n        for item in self.inventory:\n            result += f\"\\n- {item}\"\n        return result\n\n    def to_dict(self):\n        \"\"\"Convert player to dictionary for saving.\"\"\"\n        return {\n            \"name\": self.name,\n            \"current_room\": self.current_room,\n            \"inventory\": self.inventory,\n            \"game_flags\": self.game_flags\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create player from dictionary data.\"\"\"\n        player = cls(data[\"name\"], data[\"current_room\"])\n        player.inventory = data.get(\"inventory\", [])\n        player.game_flags = data.get(\"game_flags\", {})\n        return player\n\n\nclass World:\n    \"\"\"The game world containing all rooms and game state.\"\"\"\n    def __init__(self, title=\"Adventure Game\"):\n        self.title = title\n        self.rooms = {}  # Dictionary mapping room name -&gt; Room object\n\n    def add_room(self, room):\n        \"\"\"Add a room to the world.\"\"\"\n        self.rooms[room.name] = room\n\n    def get_room(self, room_name):\n        \"\"\"Get a room by name.\"\"\"\n        return self.rooms.get(room_name)\n\n    def to_dict(self):\n        \"\"\"Convert world to dictionary for saving.\"\"\"\n        return {\n            \"title\": self.title,\n            \"rooms\": {name: room.to_dict() for name, room in self.rooms.items()}\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create world from dictionary data.\"\"\"\n        world = cls(data[\"title\"])\n        for name, room_data in data[\"rooms\"].items():\n            world.add_room(Room.from_dict(room_data))\n        return world\n\n\nclass GameEngine:\n    \"\"\"Main game engine for running the adventure.\"\"\"\n    def __init__(self, player, world):\n        self.player = player\n        self.world = world\n        self.running = False\n        self.commands = {\n            \"go\": self.cmd_go,\n            \"look\": self.cmd_look,\n            \"take\": self.cmd_take,\n            \"drop\": self.cmd_drop,\n            \"inventory\": self.cmd_inventory,\n            \"help\": self.cmd_help,\n            \"quit\": self.cmd_quit\n        }\n        self.save_dir = \"game_saves\"\n        os.makedirs(self.save_dir, exist_ok=True)\n\n    def cmd_go(self, args):\n        \"\"\"Handle movement command.\"\"\"\n        if not args:\n            return \"Go where? Try 'go north', 'go south', etc.\"\n\n        direction = args[0].lower()\n        return self.player.move(direction, self.world)\n\n    def cmd_look(self, args):\n        \"\"\"Look around the current room.\"\"\"\n        current_room = self.world.get_room(self.player.current_room)\n        return current_room.get_details()\n\n    def cmd_take(self, args):\n        \"\"\"Take an item from the room.\"\"\"\n        if not args:\n            return \"Take what? Try 'take [item name]'.\"\n\n        item_name = \" \".join(args)\n        return self.player.take(item_name, self.world)\n\n    def cmd_drop(self, args):\n        \"\"\"Drop an item from inventory.\"\"\"\n        if not args:\n            return \"Drop what? Try 'drop [item name]'.\"\n\n        item_name = \" \".join(args)\n        return self.player.drop(item_name, self.world)\n\n    def cmd_inventory(self, args):\n        \"\"\"Check inventory.\"\"\"\n        return self.player.check_inventory()\n\n    def cmd_help(self, args):\n        \"\"\"Show help information.\"\"\"\n        help_text = \"Available commands:\\n\"\n        help_text += \"- go [direction]: Move in a direction (north, south, east, west)\\n\"\n        help_text += \"- look: Examine your surroundings\\n\"\n        help_text += \"- take [item]: Take an item from the room\\n\"\n        help_text += \"- drop [item]: Drop an item from your inventory\\n\"\n        help_text += \"- inventory: Check what you're carrying\\n\"\n        help_text += \"- help: Show this help text\\n\"\n        help_text += \"- quit: Exit the game\\n\"\n        help_text += \"- hint: Get a helpful hint (AI-powered)\\n\"\n        help_text += \"- save [name]: Save your progress\\n\"\n        return help_text\n\n    def cmd_quit(self, args):\n        \"\"\"Quit the game.\"\"\"\n        self.running = False\n        return \"Thanks for playing!\"\n\n    def save_game(self, filename):\n        \"\"\"Save the current game state.\"\"\"\n        game_data = {\n            \"world\": self.world.to_dict(),\n            \"player\": self.player.to_dict()\n        }\n\n        filepath = os.path.join(self.save_dir, f\"{filename}.json\")\n        with open(filepath, 'w') as f:\n            json.dump(game_data, f, indent=2)\n\n        return f\"Game saved as '{filename}'\"\n\n    @classmethod\n    def load_game(cls, filename):\n        \"\"\"Load a game from a save file.\"\"\"\n        filepath = os.path.join(\"game_saves\", f\"{filename}.json\")\n\n        with open(filepath, 'r') as f:\n            game_data = json.load(f)\n\n        world = World.from_dict(game_data[\"world\"])\n        player = Player.from_dict(game_data[\"player\"])\n\n        return cls(player, world)\n\n    def process_input(self, user_input):\n        \"\"\"Process user input and return the result.\"\"\"\n        words = user_input.lower().split()\n\n        if not words:\n            return \"Please enter a command.\"\n\n        command = words[0]\n        args = words[1:] if len(words) &gt; 1 else []\n\n        if command in self.commands:\n            return self.commands[command](args)\n        else:\n            return f\"I don't understand '{command}'. Try 'help' for a list of commands.\"\n\n    def run(self):\n        \"\"\"Run the main game loop.\"\"\"\n        self.running = True\n\n        print(f\"Welcome to {self.world.title}!\")\n        print(f\"You are {self.player.name}, an adventurer seeking fortune and glory.\")\n        print(\"Type 'help' for a list of commands.\")\n\n        # Show the initial room\n        current_room = self.world.get_room(self.player.current_room)\n        print(\"\\n\" + current_room.get_details())\n\n        while self.running:\n            user_input = input(\"\\n&gt; \").strip()\n\n            # Special case for save command\n            if user_input.startswith(\"save \"):\n                save_name = user_input[5:].strip()\n                if save_name:\n                    print(self.save_game(save_name))\n                else:\n                    print(\"Please specify a save name: 'save [name]'\")\n                continue\n\n            # Special case for AI hint\n            if user_input.lower() == \"hint\":\n                try:\n                    current_room = self.world.get_room(self.player.current_room)\n                    inventory_str = \", \".join(self.player.inventory) if self.player.inventory else \"nothing\"\n\n                    hint_prompt = f\"\"\"\n                    In this text adventure game:\n                    - The player is in: {current_room.name}\n                    - Room description: {current_room.description}\n                    - Available exits: {', '.join(current_room.exits.keys()) if current_room.exits else 'none'}\n                    - Items in room: {', '.join(current_room.items) if current_room.items else 'none'}\n                    - Player is carrying: {inventory_str}\n\n                    Based on this situation, provide a gentle hint about what the player might try next.\n                    Keep it vague enough to not spoil puzzles but helpful enough to guide them.\n                    \"\"\"\n\n                    print(\"Thinking of a hint...\")\n                    hint = get_response(hint_prompt)\n                    print(f\"\\nHint: {hint}\")\n\n                except Exception as e:\n                    print(f\"Sorry, I couldn't come up with a hint right now: {e}\")\n\n                continue\n\n            result = self.process_input(user_input)\n            print(result)\n\n\ndef create_default_world():\n    \"\"\"Create a simple default world for demonstration.\"\"\"\n    world = World(\"The Forgotten Caverns\")\n\n    # Create rooms\n    entrance = Room(\n        \"Cave Entrance\",\n        \"You stand at the entrance to a mysterious cave. Sunlight filters in from above, casting eerie shadows on the walls.\"\n    )\n\n    main_passage = Room(\n        \"Main Passage\",\n        \"A narrow passage stretches deeper into the cave. Water drips from the ceiling, creating small puddles on the ground.\"\n    )\n\n    chamber = Room(\n        \"Crystal Chamber\",\n        \"This large chamber is filled with glowing crystals of various colors, illuminating the space with an otherworldly light.\"\n    )\n\n    side_tunnel = Room(\n        \"Side Tunnel\",\n        \"A tight tunnel branches off from the main passage. The air feels stale here.\"\n    )\n\n    underground_pool = Room(\n        \"Underground Pool\",\n        \"A still, dark pool of water fills most of this chamber. The surface reflects the subtle glow from the ceiling.\"\n    )\n\n    # Connect rooms\n    entrance.add_exit(\"north\", \"Main Passage\")\n\n    main_passage.add_exit(\"south\", \"Cave Entrance\")\n    main_passage.add_exit(\"north\", \"Crystal Chamber\")\n    main_passage.add_exit(\"east\", \"Side Tunnel\")\n\n    chamber.add_exit(\"south\", \"Main Passage\")\n    chamber.add_exit(\"west\", \"Underground Pool\")\n\n    side_tunnel.add_exit(\"west\", \"Main Passage\")\n\n    underground_pool.add_exit(\"east\", \"Crystal Chamber\")\n\n    # Add items\n    entrance.add_item(\"torch\")\n    entrance.add_item(\"rope\")\n\n    main_passage.add_item(\"rusty key\")\n\n    chamber.add_item(\"glowing crystal\")\n\n    underground_pool.add_item(\"ancient coin\")\n\n    # Add rooms to world\n    world.add_room(entrance)\n    world.add_room(main_passage)\n    world.add_room(chamber)\n    world.add_room(side_tunnel)\n    world.add_room(underground_pool)\n\n    return world\n\n\ndef play_adventure_game():\n    \"\"\"Start a new adventure game or load a saved one.\"\"\"\n    print(\"=== Text Adventure Game Engine ===\")\n    print(\"1. Start new game\")\n    print(\"2. Load saved game\")\n\n    choice = input(\"\\nSelect an option: \")\n\n    if choice == \"1\":\n        player_name = input(\"\\nWhat is your name, adventurer? \")\n        player = Player(player_name, \"Cave Entrance\")\n        world = create_default_world()\n        game = GameEngine(player, world)\n        game.run()\n\n    elif choice == \"2\":\n        # Check for save files\n        save_dir = \"game_saves\"\n        if not os.path.exists(save_dir) or not os.listdir(save_dir):\n            print(\"No save files found. Starting a new game...\")\n            player_name = input(\"\\nWhat is your name, adventurer? \")\n            player = Player(player_name, \"Cave Entrance\")\n            world = create_default_world()\n            game = GameEngine(player, world)\n        else:\n            # List save files\n            save_files = [f[:-5] for f in os.listdir(save_dir) if f.endswith(\".json\")]\n            print(\"\\nAvailable save files:\")\n            for i, save in enumerate(save_files, 1):\n                print(f\"{i}. {save}\")\n\n            save_idx = int(input(\"\\nSelect a save file (number): \")) - 1\n            if 0 &lt;= save_idx &lt; len(save_files):\n                try:\n                    game = GameEngine.load_game(save_files[save_idx])\n                    print(f\"Loaded save: {save_files[save_idx]}\")\n                except Exception as e:\n                    print(f\"Error loading save: {e}\")\n                    return\n            else:\n                print(\"Invalid selection. Starting a new game...\")\n                player_name = input(\"\\nWhat is your name, adventurer? \")\n                player = Player(player_name, \"Cave Entrance\")\n                world = create_default_world()\n                game = GameEngine(player, world)\n\n        game.run()\n\n    else:\n        print(\"Invalid choice. Exiting.\")\n\n\n# Run the game\nif __name__ == \"__main__\":\n    play_adventure_game()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_20","title":"Extension Ideas","text":"<ul> <li>Add more room types with special properties (e.g., dark rooms that require a light source)</li> <li>Implement NPCs (non-player characters) that the player can talk to</li> <li>Add simple puzzles that require specific items to solve</li> <li>Create a quest system with objectives and rewards</li> <li>Design a combat system for encounters with enemies</li> <li>Build a web-based interface using a framework like Flask</li> </ul>"},{"location":"mini-projects/#trivia-or-quiz-bot","title":"Trivia or Quiz Bot","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: Loops, conditionals, lists</p>"},{"location":"mini-projects/#overview_21","title":"Overview","text":"<p>Build an interactive quiz bot that asks questions, tracks the user's score, provides feedback, and offers hints when needed.</p>"},{"location":"mini-projects/#instructions_21","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport random\n\ndef create_quiz_bot():\n    # Define your quiz questions as (question, answer) tuples\n    questions = [\n        (\"What's 2 + 2?\", \"4\"),\n        (\"What is the capital of France?\", \"paris\"),\n        (\"What's the keyword for loops in Python?\", \"for\"),\n        (\"What year did the first iPhone release?\", \"2007\"),\n        (\"Who wrote 'Romeo and Juliet'?\", \"shakespeare\"),\n    ]\n\n    # Randomize questions\n    random.shuffle(questions)\n\n    # Initialize score\n    score = 0\n    total = len(questions)\n\n    # Introduction\n    print(\"Welcome to the Quiz Bot!\")\n    print(f\"I'll ask you {total} questions. Let's see how you do!\\n\")\n\n    # Loop through questions\n    for i, (question, answer) in enumerate(questions):\n        print(f\"Question {i+1}/{total}: {question}\")\n\n        # Get user's answer\n        user_answer = input(\"Your answer: \").strip().lower()\n\n        # Check if correct\n        if user_answer == answer.lower():\n            score += 1\n            print(\"Correct! \u2705\")\n\n            # Get enthusiastic feedback from the bot\n            feedback = get_response(\n                f\"The user correctly answered '{question}' with '{answer}'. Give a short, enthusiastic response.\",\n                system=\"You are an encouraging quiz host who keeps responses to one short sentence.\"\n            )\n            print(feedback)\n        else:\n            print(f\"Sorry, that's incorrect. \u274c The answer is: {answer}\")\n\n            # Get encouraging feedback from the bot\n            feedback = get_response(\n                f\"The user incorrectly answered '{question}' with '{user_answer}' instead of '{answer}'. Give a short, encouraging response.\",\n                system=\"You are a supportive quiz host who gives gentle encouragement in one sentence.\"\n            )\n            print(feedback)\n\n        print(\"-\" * 50)\n\n    # Calculate percentage\n    percentage = (score / total) * 100\n\n    # Final results\n    print(f\"\\nQuiz complete! Your score: {score}/{total} ({percentage:.1f}%)\")\n\n    # Get final feedback based on score\n    if percentage &gt;= 80:\n        result = \"excellent\"\n    elif percentage &gt;= 60:\n        result = \"good\"\n    else:\n        result = \"needs improvement\"\n\n    final_feedback = get_response(\n        f\"The user scored {percentage:.1f}% ({score}/{total}) on the quiz, which is {result}. Give them feedback and encouragement.\",\n        system=\"You are a supportive teacher giving a short, personalized assessment.\"\n    )\n\n    print(\"\\nBot's feedback:\")\n    print(final_feedback)\n\n# Run the quiz\nif __name__ == \"__main__\":\n    create_quiz_bot()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_21","title":"Extension Ideas","text":"<ul> <li>Add difficulty levels where harder questions are worth more points</li> <li>Include a hint system where users can ask for clues but lose points</li> <li>Make a specialized quiz for a specific subject the students are studying</li> <li>Add a timer element where users have to answer within a time limit</li> <li>Let students create their own question banks to quiz each other</li> </ul>"},{"location":"mini-projects/#weather-dashboard","title":"Weather Dashboard","text":"<p>Difficulty: Intermediate-Advanced Time: 60-90 minutes Learning Focus: API integration, data visualization, environmental data analysis</p>"},{"location":"mini-projects/#overview_22","title":"Overview","text":"<p>Create a weather dashboard that fetches real-time weather data and forecasts from an API, then visualizes it with charts and provides AI-powered weather advice based on conditions.</p>"},{"location":"mini-projects/#instructions_22","title":"Instructions","text":"<pre><code>import requests\nimport matplotlib.pyplot as plt\nimport os\nfrom datetime import datetime, timedelta\nfrom chatcraft import get_response\n\nclass WeatherDashboard:\n    \"\"\"\n    A simple weather dashboard that retrieves and displays weather data.\n    Students will need to sign up for a free API key from OpenWeatherMap.\n    \"\"\"\n\n    def __init__(self):\n        self.api_key = None\n        self.base_url = \"https://api.openweathermap.org/data/2.5/\"\n        self.output_dir = \"weather_dashboard\"\n        os.makedirs(self.output_dir, exist_ok=True)\n\n    def setup(self):\n        \"\"\"Set up the dashboard with the API key.\"\"\"\n        print(\"=== Weather Dashboard Setup ===\")\n\n        # Check for existing API key\n        key_file = os.path.join(self.output_dir, \"api_key.txt\")\n        if os.path.exists(key_file):\n            with open(key_file, 'r') as f:\n                self.api_key = f.read().strip()\n            print(\"API key loaded from file.\")\n\n        # If no API key, prompt for one\n        if not self.api_key:\n            print(\"\\nYou need an OpenWeatherMap API key to use this dashboard.\")\n            print(\"Get a free API key at: https://openweathermap.org/api\")\n            self.api_key = input(\"Enter your API key: \").strip()\n\n            # Save API key for future use\n            save_key = input(\"Save this API key for future use? (y/n): \").lower() == 'y'\n            if save_key:\n                with open(key_file, 'w') as f:\n                    f.write(self.api_key)\n                print(\"API key saved.\")\n\n    def get_current_weather(self, location):\n        \"\"\"Get current weather for a location.\"\"\"\n        url = f\"{self.base_url}weather\"\n        params = {\n            'q': location,\n            'appid': self.api_key,\n            'units': 'metric'  # Use metric by default\n        }\n\n        try:\n            response = requests.get(url, params=params)\n            response.raise_for_status()  # Raise exception for HTTP errors\n            return response.json()\n        except requests.exceptions.HTTPError as http_err:\n            if response.status_code == 404:\n                print(f\"Location '{location}' not found. Please check the spelling.\")\n            else:\n                print(f\"HTTP error: {http_err}\")\n            return None\n        except Exception as err:\n            print(f\"Error: {err}\")\n            return None\n\n    def get_forecast(self, location, days=5):\n        \"\"\"Get weather forecast for a location.\"\"\"\n        url = f\"{self.base_url}forecast\"\n        params = {\n            'q': location,\n            'appid': self.api_key,\n            'units': 'metric',\n            'cnt': days * 8  # API returns data in 3-hour steps, 8 per day\n        }\n\n        try:\n            response = requests.get(url, params=params)\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.HTTPError as http_err:\n            if response.status_code == 404:\n                print(f\"Location '{location}' not found. Please check the spelling.\")\n            else:\n                print(f\"HTTP error: {http_err}\")\n            return None\n        except Exception as err:\n            print(f\"Error: {err}\")\n            return None\n\n    def display_current_weather(self, data):\n        \"\"\"Display current weather conditions.\"\"\"\n        if not data:\n            return\n\n        try:\n            city = data['name']\n            country = data['sys']['country']\n            temp = data['main']['temp']\n            feels_like = data['main']['feels_like']\n            humidity = data['main']['humidity']\n            pressure = data['main']['pressure']\n            weather_desc = data['weather'][0]['description']\n            wind_speed = data['wind']['speed']\n            clouds = data['clouds']['all']\n\n            # Convert Unix timestamp to readable format\n            sunrise = datetime.fromtimestamp(data['sys']['sunrise']).strftime('%H:%M')\n            sunset = datetime.fromtimestamp(data['sys']['sunset']).strftime('%H:%M')\n\n            print(\"\\n=== Current Weather Conditions ===\")\n            print(f\"Location: {city}, {country}\")\n            print(f\"Weather: {weather_desc.title()}\")\n            print(f\"Temperature: {temp}\u00b0C (Feels like: {feels_like}\u00b0C)\")\n            print(f\"Humidity: {humidity}%\")\n            print(f\"Pressure: {pressure} hPa\")\n            print(f\"Wind Speed: {wind_speed} m/s\")\n            print(f\"Cloud Cover: {clouds}%\")\n            print(f\"Sunrise: {sunrise}\")\n            print(f\"Sunset: {sunset}\")\n\n        except KeyError as e:\n            print(f\"Error parsing weather data: {e}\")\n\n    def plot_forecast(self, data, location):\n        \"\"\"Create forecast plots and save them.\"\"\"\n        if not data:\n            return\n\n        try:\n            # Extract forecast data\n            timestamps = []\n            temps = []\n            humidity = []\n            descriptions = []\n\n            for item in data['list']:\n                dt = datetime.fromtimestamp(item['dt'])\n                timestamps.append(dt)\n                temps.append(item['main']['temp'])\n                humidity.append(item['main']['humidity'])\n                descriptions.append(item['weather'][0]['description'])\n\n            # Create temperature forecast plot\n            plt.figure(figsize=(12, 6))\n            plt.plot(timestamps, temps, marker='o', color='#FF5733', linewidth=2)\n            plt.xlabel('Date &amp; Time')\n            plt.ylabel('Temperature (\u00b0C)')\n            plt.title(f'Temperature Forecast for {location}')\n            plt.grid(True, linestyle='--', alpha=0.7)\n            plt.xticks(rotation=45)\n            plt.tight_layout()\n\n            # Save the plot\n            temp_plot_file = os.path.join(self.output_dir, f\"{location.replace(',', '_')}_temp_forecast.png\")\n            plt.savefig(temp_plot_file)\n            plt.close()\n\n            # Create humidity forecast plot\n            plt.figure(figsize=(12, 6))\n            plt.plot(timestamps, humidity, marker='s', color='#3498DB', linewidth=2)\n            plt.xlabel('Date &amp; Time')\n            plt.ylabel('Humidity (%)')\n            plt.title(f'Humidity Forecast for {location}')\n            plt.grid(True, linestyle='--', alpha=0.7)\n            plt.xticks(rotation=45)\n            plt.tight_layout()\n\n            # Save the plot\n            humidity_plot_file = os.path.join(self.output_dir, f\"{location.replace(',', '_')}_humidity_forecast.png\")\n            plt.savefig(humidity_plot_file)\n            plt.close()\n\n            print(f\"\\nForecast plots saved to:\\n- {temp_plot_file}\\n- {humidity_plot_file}\")\n\n            return temp_plot_file, humidity_plot_file\n\n        except KeyError as e:\n            print(f\"Error parsing forecast data: {e}\")\n            return None, None\n\n    def get_weather_summary(self, current_data, forecast_data, location):\n        \"\"\"Generate a summary of the weather conditions and forecast.\"\"\"\n        if not current_data or not forecast_data:\n            return \"Unable to generate weather summary due to missing data.\"\n\n        try:\n            # Extract key information\n            current_temp = current_data['main']['temp']\n            current_desc = current_data['weather'][0]['description']\n\n            # Get min/max for the next few days\n            daily_temps = {}\n            for item in forecast_data['list']:\n                dt = datetime.fromtimestamp(item['dt'])\n                date_str = dt.strftime('%Y-%m-%d')\n\n                if date_str not in daily_temps:\n                    daily_temps[date_str] = {'temps': [], 'descs': []}\n\n                daily_temps[date_str]['temps'].append(item['main']['temp'])\n                daily_temps[date_str]['descs'].append(item['weather'][0]['description'])\n\n            # Create summary with key info\n            summary = f\"Weather Summary for {location}:\\n\\n\"\n            summary += f\"Current Conditions: {current_desc.title()} at {current_temp}\u00b0C\\n\\n\"\n            summary += \"Forecast:\\n\"\n\n            for date_str, data in daily_temps.items():\n                if data['temps']:  # Make sure we have data\n                    min_temp = min(data['temps'])\n                    max_temp = max(data['temps'])\n\n                    # Get most common description\n                    from collections import Counter\n                    desc_counter = Counter(data['descs'])\n                    most_common_desc = desc_counter.most_common(1)[0][0]\n\n                    # Format date nicely (e.g., \"Monday, Jan 15\")\n                    date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n                    formatted_date = date_obj.strftime('%A, %b %d')\n\n                    summary += f\"- {formatted_date}: {most_common_desc.title()}, {min_temp}\u00b0C to {max_temp}\u00b0C\\n\"\n\n            return summary\n\n        except KeyError as e:\n            print(f\"Error generating weather summary: {e}\")\n            return \"Unable to generate weather summary.\"\n\n    def get_ai_weather_advice(self, current_data, forecast_data, location):\n        \"\"\"Get AI-generated weather advice based on conditions.\"\"\"\n        if not current_data or not forecast_data:\n            return \"Unable to generate weather advice due to missing data.\"\n\n        try:\n            # Prepare weather information for the AI\n            current_temp = current_data['main']['temp']\n            current_desc = current_data['weather'][0]['description']\n            current_humidity = current_data['main']['humidity']\n            current_wind = current_data['wind']['speed']\n\n            # Extract forecast information\n            tomorrow_data = forecast_data['list'][:8]  # First 8 entries (24 hours)\n            tomorrow_descs = [item['weather'][0]['description'] for item in tomorrow_data]\n            tomorrow_temps = [item['main']['temp'] for item in tomorrow_data]\n\n            avg_tomorrow_temp = sum(tomorrow_temps) / len(tomorrow_temps)\n            min_tomorrow_temp = min(tomorrow_temps)\n            max_tomorrow_temp = max(tomorrow_temps)\n\n            # Create prompt for AI\n            prompt = f\"\"\"\n            Based on the following weather data for {location}:\n\n            Current conditions:\n            - Temperature: {current_temp}\u00b0C\n            - Description: {current_desc}\n            - Humidity: {current_humidity}%\n            - Wind speed: {current_wind} m/s\n\n            Tomorrow's forecast:\n            - Average temperature: {avg_tomorrow_temp:.1f}\u00b0C\n            - Range: {min_tomorrow_temp:.1f}\u00b0C to {max_tomorrow_temp:.1f}\u00b0C\n            - Conditions: {', '.join(set(tomorrow_descs))}\n\n            Please provide:\n            1. Practical advice for what to wear or prepare for today\n            2. Any weather warnings or precautions to be aware of\n            3. Suggested activities that would be appropriate for this weather\n\n            Keep your response conversational and under 150 words.\n            \"\"\"\n\n            try:\n                advice = get_response(prompt)\n                return advice\n            except Exception as e:\n                print(f\"Error getting AI weather advice: {e}\")\n                return \"Unable to generate AI weather advice at this time.\"\n\n        except KeyError as e:\n            print(f\"Error preparing data for AI advice: {e}\")\n            return \"Unable to generate weather advice due to missing data.\"\n\n    def run(self):\n        \"\"\"Run the main dashboard interface.\"\"\"\n        self.setup()\n\n        if not self.api_key:\n            print(\"No API key provided. Exiting.\")\n            return\n\n        print(\"\\n=== Weather Dashboard ===\")\n        location = input(\"Enter a city name (e.g., 'London' or 'London,UK'): \")\n\n        print(f\"\\nFetching weather data for {location}...\")\n        current_data = self.get_current_weather(location)\n\n        if current_data:\n            self.display_current_weather(current_data)\n\n            # Get forecast data\n            print(\"\\nFetching forecast data...\")\n            forecast_data = self.get_forecast(location)\n\n            if forecast_data:\n                # Plot forecast\n                temp_plot, humidity_plot = self.plot_forecast(forecast_data, location)\n\n                # Generate weather summary\n                summary = self.get_weather_summary(current_data, forecast_data, location)\n                print(\"\\n=== Weather Summary ===\")\n                print(summary)\n\n                # Get AI advice if requested\n                get_advice = input(\"\\nWould you like personalized weather advice? (y/n): \").lower() == 'y'\n                if get_advice:\n                    print(\"\\nGenerating advice...\")\n                    advice = self.get_ai_weather_advice(current_data, forecast_data, location)\n                    print(\"\\n=== Weather Advice ===\")\n                    print(advice)\n\n                # Save all info to a report file\n                save_report = input(\"\\nSave a weather report file? (y/n): \").lower() == 'y'\n                if save_report:\n                    try:\n                        report_file = os.path.join(self.output_dir, f\"{location.replace(',', '_')}_weather_report.txt\")\n                        with open(report_file, 'w') as f:\n                            f.write(f\"Weather Report for {location}\\n\")\n                            f.write(f\"Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n                            f.write(\"=== Current Conditions ===\\n\")\n\n                            # Extract current conditions\n                            f.write(f\"Temperature: {current_data['main']['temp']}\u00b0C\\n\")\n                            f.write(f\"Feels like: {current_data['main']['feels_like']}\u00b0C\\n\")\n                            f.write(f\"Weather: {current_data['weather'][0]['description'].title()}\\n\")\n                            f.write(f\"Humidity: {current_data['main']['humidity']}%\\n\")\n                            f.write(f\"Wind speed: {current_data['wind']['speed']} m/s\\n\")\n                            f.write(f\"Pressure: {current_data['main']['pressure']} hPa\\n\\n\")\n\n                            # Add summary\n                            f.write(\"=== Forecast Summary ===\\n\")\n                            f.write(summary + \"\\n\\n\")\n\n                            # Add advice if it was generated\n                            if get_advice:\n                                f.write(\"=== Weather Advice ===\\n\")\n                                f.write(advice + \"\\n\")\n\n                            # Add note about plot files\n                            if temp_plot and humidity_plot:\n                                f.write(\"\\nForecast plots saved as:\\n\")\n                                f.write(f\"- {os.path.basename(temp_plot)}\\n\")\n                                f.write(f\"- {os.path.basename(humidity_plot)}\\n\")\n\n                        print(f\"\\nWeather report saved to: {report_file}\")\n                    except Exception as e:\n                        print(f\"Error saving weather report: {e}\")\n\n        print(\"\\nThank you for using the Weather Dashboard!\")\n\n# Run the dashboard\nif __name__ == \"__main__\":\n    dashboard = WeatherDashboard()\n    dashboard.run()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_22","title":"Extension Ideas","text":"<ul> <li>Add support for multiple locations and comparison views</li> <li>Implement unit conversion between metric and imperial</li> <li>Create a historical weather data retrieval and analysis feature</li> <li>Add precipitation and wind forecasts with appropriate visualizations</li> <li>Implement a daily weather notification system</li> <li>Create a map-based visualization of weather data</li> </ul>"},{"location":"mini-projects/#youtube-to-blog-converter","title":"YouTube to Blog Converter","text":"<p>Difficulty: Beginner-Intermediate Time: 30-45 minutes Learning Focus: API integration, text processing, content repurposing</p>"},{"location":"mini-projects/#overview_23","title":"Overview","text":"<p>Create a tool that converts YouTube video transcripts into well-formatted blog posts using AI. This project helps students understand how to extract data from one format and transform it into another valuable piece of content.</p>"},{"location":"mini-projects/#instructions_23","title":"Instructions","text":"<pre><code>import re\nimport argparse\nfrom youtube_transcript_api import YouTubeTranscriptApi\nfrom chatcraft import get_response\n\ndef youtube_to_blog():\n    \"\"\"Convert YouTube video transcripts into blog post content using AI.\"\"\"\n    print(\"=== YouTube to Blog Converter ===\")\n    print(\"This tool extracts a transcript from a YouTube video and converts it to a blog post.\")\n\n    # Get video URL or ID\n    video_input = input(\"Enter YouTube video URL or video ID: \")\n\n    # Extract video ID from URL if needed\n    video_id = extract_video_id(video_input)\n\n    if not video_id:\n        print(\"Error: Could not extract a valid YouTube video ID.\")\n        return\n\n    print(f\"Processing video ID: {video_id}\")\n\n    # Get transcript\n    try:\n        transcript = get_transcript(video_id)\n        if not transcript:\n            return\n    except Exception as e:\n        print(f\"Error getting transcript: {e}\")\n        return\n\n    # Get video metadata if needed\n    video_title = input(\"Enter video title (or press Enter to skip): \")\n    video_author = input(\"Enter video creator/channel name (or press Enter to skip): \")\n\n    # Get blog style preferences\n    print(\"\\nBlog Style Options:\")\n    print(\"1. Informational/Educational\")\n    print(\"2. Conversational/Casual\")\n    print(\"3. Professional/Formal\")\n    print(\"4. Tutorial/How-To\")\n\n    style_choice = input(\"Select a style (1-4): \")\n\n    if style_choice == \"1\":\n        blog_style = \"informational\"\n    elif style_choice == \"2\":\n        blog_style = \"conversational\"\n    elif style_choice == \"3\":\n        blog_style = \"professional\"\n    elif style_choice == \"4\":\n        blog_style = \"tutorial\"\n    else:\n        print(\"Invalid choice. Using informational style.\")\n        blog_style = \"informational\"\n\n    # Get additional context\n    topic_keywords = input(\"Enter 3-5 keywords related to the video (comma separated): \")\n\n    # Get intended audience\n    audience = input(\"Who is the target audience for this blog post? \")\n\n    # Generate blog post with AI\n    generate_blog_post(transcript, video_title, video_author, blog_style, topic_keywords, audience)\n\ndef extract_video_id(video_input):\n    \"\"\"Extract the YouTube video ID from a URL or return the ID if already provided.\"\"\"\n    # Check if it's already a video ID (simple 11-character string)\n    if re.match(r'^[a-zA-Z0-9_-]{11}, video_input):\n        return video_input\n\n    # Try to extract from URL\n    youtube_regex = r'(?:youtube\\.com\\/(?:[^\\/\\n\\s]+\\/\\S+\\/|(?:v|e(?:mbed)?)\\/|\\S*?[?&amp;]v=)|youtu\\.be\\/)([a-zA-Z0-9_-]{11})'\n    match = re.search(youtube_regex, video_input)\n\n    if match:\n        return match.group(1)\n\n    return None\n\ndef get_transcript(video_id):\n    \"\"\"Get the transcript from a YouTube video.\"\"\"\n    try:\n        transcript_list = YouTubeTranscriptApi.get_transcript(video_id)\n\n        # Combine all transcript segments\n        full_transcript = \" \".join([item['text'] for item in transcript_list])\n\n        # Print a preview\n        preview_length = min(150, len(full_transcript))\n        print(f\"\\nTranscript preview ({len(full_transcript)} characters):\")\n        print(f\"{full_transcript[:preview_length]}...\")\n\n        return full_transcript\n\n    except Exception as e:\n        print(f\"Error: Could not retrieve transcript. {str(e)}\")\n        print(\"Possible reasons:\")\n        print(\"- The video might not have closed captions/subtitles\")\n        print(\"- The video ID might be incorrect\")\n        print(\"- The video owner may have disabled transcript access\")\n        return None\n\ndef generate_blog_post(transcript, title, author, style, keywords, audience):\n    \"\"\"Generate a blog post from the transcript using AI.\"\"\"\n    print(\"\\nGenerating blog post...\")\n\n    # Create a prompt for the AI\n    prompt = f\"\"\"\n    Convert this YouTube video transcript into a well-structured blog post:\n\n    VIDEO INFORMATION:\n    Title: {title if title else \"Not provided\"}\n    Creator: {author if author else \"Not provided\"}\n    Style: {style}\n    Keywords: {keywords}\n    Target Audience: {audience}\n\n    TRANSCRIPT:\n    {transcript[:4000]}  # Limit transcript length if needed\n\n    Please create a complete blog post with:\n    1. An engaging headline/title\n    2. Introduction that hooks the reader\n    3. Well-structured sections with subheadings\n    4. Conclusion or call-to-action\n    5. Add relevant statistics or examples where appropriate\n\n    Format the post using markdown syntax for headings, lists, etc.\n    The tone should be {style} and appropriate for the specified audience.\n    Expand on any concepts from the video that need more explanation.\n    Add 3-5 relevant tags at the end of the post.\n\n    Length: Aim for ~1000-1500 words.\n    \"\"\"\n\n    try:\n        # Generate blog post using the prompt\n        blog_post = get_response(prompt)\n\n        # Save the blog post to a file\n        filename = f\"blog_post_{title.replace(' ', '_')[:30] if title else 'from_youtube'}.md\"\n        with open(filename, 'w') as f:\n            f.write(blog_post)\n\n        print(f\"\\nBlog post successfully generated and saved to: {filename}\")\n\n        # Print a preview of the blog post\n        preview_lines = blog_post.split('\\n')[:10]\n        print(\"\\nBlog Post Preview:\")\n        print(\"\\n\".join(preview_lines) + \"\\n...\")\n\n    except Exception as e:\n        print(f\"Error generating blog post: {e}\")\n\nif __name__ == \"__main__\":\n    youtube_to_blog()\n</code></pre>"},{"location":"mini-projects/#extension-ideas_23","title":"Extension Ideas","text":"<ul> <li>Add support for multiple languages and translation</li> <li>Implement a social media post generator from the same content</li> <li>Create a scheduler to process videos in batch</li> <li>Add image extraction from video thumbnails or frames</li> <li>Build a web interface with Flask or Streamlit</li> <li>Implement SEO optimization suggestions for the generated content</li> </ul> <p>For implementation strategies and assessment ideas, see the ChatCraft Education Guide.</p>"},{"location":"ollama-guide/","title":"Setting Up Ollama for ChatCraft","text":"<p>This guide will walk you through the simple process of setting up Ollama on your local machine to power your ChatCraft projects.</p> <p>Great instinct! Since the docstring update was already complete, there's no change needed in your Python code.</p> <p>Now, for your Ollama guide, here\u2019s what you can add based on your idea:</p>"},{"location":"ollama-guide/#add-this-to-the-beginning-of-the-guide","title":"\u2705 Add this to the beginning of the guide:","text":""},{"location":"ollama-guide/#who-is-this-guide-for","title":"\ud83e\udded Who Is This Guide For?","text":"<p>This guide is written for beginners who want to run ChatCraft with a local LLM using Ollama. If you're an educator or student new to large language models, this will walk you through everything step by step.</p> <p>If you're an advanced user with an existing Ollama setup (custom models, non-default ports, Docker, remote hosting), feel free to skip this guide \u2014 ChatCraft will work as long as your Ollama server is reachable.</p>"},{"location":"ollama-guide/#what-is-ollama","title":"What is Ollama?","text":"<p>Ollama is a lightweight tool that allows you to run large language models (LLMs) locally on your computer. It makes it easy to download and run models like Llama 3 without needing specialized hardware or complex setup.</p>"},{"location":"ollama-guide/#system-requirements","title":"System Requirements","text":"<ul> <li>Windows, macOS, or Linux computer</li> <li>At least 8GB RAM (16GB+ recommended for better performance)</li> <li>At least 10GB of free disk space</li> <li>An internet connection (for the initial model download)</li> </ul>"},{"location":"ollama-guide/#installation-guide","title":"Installation Guide","text":""},{"location":"ollama-guide/#for-macos","title":"For macOS","text":"<ol> <li>Download the Ollama installer from ollama.ai</li> <li>Open the downloaded file and drag the Ollama app to your Applications folder</li> <li>Launch Ollama from your Applications folder</li> <li>Ollama will run in your menu bar (look for the llama icon)</li> </ol>"},{"location":"ollama-guide/#for-windows","title":"For Windows","text":"<ol> <li>Download the Windows installer from ollama.ai</li> <li>Run the installer and follow the on-screen instructions</li> <li>Once installed, Ollama will start automatically and run in the system tray</li> </ol>"},{"location":"ollama-guide/#for-linux","title":"For Linux","text":"<ol> <li>Run the following command in your terminal:    <pre><code>curl -fsSL https://ollama.ai/install.sh | sh\n</code></pre></li> <li>Start the Ollama service:    <pre><code>ollama serve\n</code></pre></li> </ol>"},{"location":"ollama-guide/#downloading-your-first-model","title":"Downloading Your First Model","text":"<p>After installing Ollama, you'll need to download at least one model. For beginners, we recommend the <code>llama3</code> model, which offers a good balance of performance and quality.</p> <ol> <li>Open a terminal or command prompt</li> <li>Run the following command:    <pre><code>ollama pull llama3\n</code></pre></li> <li>Wait for the download to complete (this may take a few minutes depending on your internet speed)</li> </ol> <p>The first time you run this command, it will download the model files (about 4GB). Once downloaded, the model will be available locally on your computer.</p>"},{"location":"ollama-guide/#testing-your-installation","title":"Testing Your Installation","text":"<p>Let's make sure everything is working properly:</p> <ol> <li>In your terminal or command prompt, run:    <pre><code>ollama run llama3 \"Hello, how are you today?\"\n</code></pre></li> <li>You should see a response from the model</li> </ol> <p>If you received a response, congratulations! Ollama is set up correctly and ready to use with ChatCraft.</p>"},{"location":"ollama-guide/#using-ollama-with-chatcraft","title":"Using Ollama with ChatCraft","text":"<p>ChatCraft is designed to work with Ollama by default. As long as Ollama is running in the background, ChatCraft will automatically connect to it at <code>http://localhost:11434</code>.</p> <p>No additional configuration is required unless you've changed Ollama's default settings.</p>"},{"location":"ollama-guide/#test-your-installation","title":"\ud83e\uddea Test Your Installation","text":"<p>Once you\u2019ve started a model using:</p> <pre><code>ollama run llama3\n</code></pre> <p>You can test ChatCraft in Python with:</p> <pre><code>from chatcraft import friendly_bot\nprint(friendly_bot(\\\"What is 3 + 4?\\\"))\n</code></pre> <p>You should get a real-time AI response!</p>"},{"location":"ollama-guide/#optional-tip-advanced-config","title":"\u2705 Optional Tip (Advanced Config):","text":""},{"location":"ollama-guide/#advanced-custom-model-host","title":"\u2699\ufe0f Advanced: Custom Model Host","text":"<p>If you're running Ollama on a different host or port (e.g. remote or Docker), you can create a config file to tell ChatCraft where to send requests.  </p> <p>See: docs/configuration.md for advanced setup.</p>"},{"location":"ollama-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"ollama-guide/#connection-refused-error","title":"\"Connection refused\" error","text":"<p>If ChatCraft shows a connection error: 1. Make sure Ollama is running 2. Check that you haven't changed the default port (11434) 3. On Windows or macOS, you might need to restart the Ollama application</p>"},{"location":"ollama-guide/#slow-responses","title":"Slow responses","text":"<ol> <li>Try a smaller model like <code>llama3:8b</code> which requires fewer resources</li> <li>Close other resource-intensive applications</li> <li>Ensure your computer meets the minimum requirements</li> </ol>"},{"location":"ollama-guide/#out-of-memory-error","title":"\"Out of memory\" error","text":"<ol> <li>Try a smaller model like <code>llama3:8b</code></li> <li>Increase your system's virtual memory (swap file)</li> <li>Close other applications to free up RAM</li> </ol>"},{"location":"ollama-guide/#available-models","title":"Available Models","text":"<p>Here are some models you can use with ChatCraft:</p> <ul> <li><code>llama3</code> - The recommended default model for most users</li> <li><code>llama3:8b</code> - A smaller, faster version if you have limited resources</li> <li><code>codellama</code> - Specialized for programming tasks (recommended for code-related exercises)</li> <li><code>mistral</code> - An alternative model with good performance</li> <li><code>phi</code> - A smaller model with good capabilities for simpler tasks</li> </ul> <p>To download any of these models, use: <pre><code>ollama pull model_name\n</code></pre></p>"},{"location":"ollama-guide/#need-more-help","title":"Need More Help?","text":"<p>For more detailed information about Ollama, visit their official documentation at ollama.ai/docs.</p> <p>Now that you have Ollama set up, you're ready to use ChatCraft and start creating your own AI educational experiences!</p>"},{"location":"projects/advanced-journal-bot/","title":"Advanced Journal Assistant","text":"<p>Difficulty: Intermediate-Advanced Time: 60-90 minutes Learning Focus: Data structures, file I/O, data visualization, natural language processing, user experience design</p>"},{"location":"projects/advanced-journal-bot/#overview","title":"Overview","text":"<p>Create a comprehensive journaling application that combines structured mood tracking with flexible reflection prompts, offering users deep insights through data visualization and AI-powered analysis.</p>"},{"location":"projects/advanced-journal-bot/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport datetime\nimport os\nimport json\nimport matplotlib.pyplot as plt\nfrom collections import Counter\nimport re\n\nclass AdvancedJournalAssistant:\n    def __init__(self):\n        \"\"\"Initialize the journal assistant with necessary directories and files\"\"\"\n        # Set up storage directories\n        self.journal_dir = os.path.expanduser(\"~/.advanced_journal\")\n        self.visualization_dir = os.path.join(self.journal_dir, \"visualizations\")\n        os.makedirs(self.journal_dir, exist_ok=True)\n        os.makedirs(self.visualization_dir, exist_ok=True)\n\n        # Define file paths\n        self.journal_file = os.path.join(self.journal_dir, \"journal_entries.json\")\n        self.prompt_file = os.path.join(self.journal_dir, \"custom_prompts.json\")\n\n        # Initialize data structures\n        self.entries = self._load_entries()\n        self.custom_prompts = self._load_custom_prompts()\n\n        # Default prompts\n        self.default_prompts = [\n            \"What's something that happened today that you'd like to reflect on?\",\n            \"What's something you learned today?\",\n            \"What's something you're grateful for today?\",\n            \"What's something that challenged you today?\",\n            \"What's something you're looking forward to?\",\n            \"How did you take care of yourself today?\",\n            \"Was there a moment today that stood out? Why?\",\n            \"What's something you'd like to remember about today?\"\n        ]\n\n        # Define mood labels for better interpretation\n        self.mood_labels = {\n            1: \"Very Low\", 2: \"Low\", 3: \"Somewhat Low\", 4: \"Below Average\", 5: \"Neutral\", \n            6: \"Slightly Positive\", 7: \"Good\", 8: \"Very Good\", 9: \"Excellent\", 10: \"Outstanding\"\n        }\n\n        # Track user preferences\n        self.preferences = self._load_preferences()\n\n    def _load_entries(self):\n        \"\"\"Load existing journal entries or return an empty list\"\"\"\n        if os.path.exists(self.journal_file):\n            try:\n                with open(self.journal_file, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                return []\n        return []\n\n    def _load_custom_prompts(self):\n        \"\"\"Load custom prompts or return an empty list\"\"\"\n        if os.path.exists(self.prompt_file):\n            try:\n                with open(self.prompt_file, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                return []\n        return []\n\n    def _load_preferences(self):\n        \"\"\"Load user preferences or set defaults\"\"\"\n        pref_file = os.path.join(self.journal_dir, \"preferences.json\")\n        defaults = {\n            \"auto_insights\": True,\n            \"daily_reminder\": False,\n            \"reminder_time\": \"20:00\",\n            \"favorite_prompts\": [],\n            \"theme\": \"standard\",\n            \"insight_frequency\": \"weekly\"\n        }\n\n        if os.path.exists(pref_file):\n            try:\n                with open(pref_file, 'r') as f:\n                    stored_prefs = json.load(f)\n                    # Update defaults with stored preferences\n                    defaults.update(stored_prefs)\n            except json.JSONDecodeError:\n                pass\n\n        return defaults\n\n    def _save_entries(self):\n        \"\"\"Save journal entries to file\"\"\"\n        with open(self.journal_file, 'w') as f:\n            json.dump(self.entries, f, indent=2)\n\n    def _save_custom_prompts(self):\n        \"\"\"Save custom prompts to file\"\"\"\n        with open(self.prompt_file, 'w') as f:\n            json.dump(self.custom_prompts, f, indent=2)\n\n    def _save_preferences(self):\n        \"\"\"Save user preferences to file\"\"\"\n        pref_file = os.path.join(self.journal_dir, \"preferences.json\")\n        with open(pref_file, 'w') as f:\n            json.dump(self.preferences, f, indent=2)\n\n    def display_menu(self):\n        \"\"\"Display the main menu and handle user choices\"\"\"\n        print(\"\\n======================================\")\n        print(\"=== Advanced Journal Assistant ===\")\n        print(\"======================================\")\n        print(\"1. Create new journal entry\")\n        print(\"2. View past entries\")\n        print(\"3. Get insights and analytics\")\n        print(\"4. Manage custom prompts\")\n        print(\"5. Set goals and intentions\")\n        print(\"6. Preferences\")\n        print(\"7. Export journal\")\n        print(\"8. Exit\")\n\n        try:\n            choice = input(\"\\nWhat would you like to do? (1-8): \")\n\n            menu_actions = {\n                \"1\": self.create_entry,\n                \"2\": self.view_entries,\n                \"3\": self.get_insights,\n                \"4\": self.manage_prompts,\n                \"5\": self.set_goals,\n                \"6\": self.set_preferences,\n                \"7\": self.export_journal,\n                \"8\": self.exit_app\n            }\n\n            # Execute the chosen action or show error\n            if choice in menu_actions:\n                menu_actions[choice]()\n            else:\n                print(\"Invalid choice. Please try again.\")\n                self.display_menu()\n\n        except KeyboardInterrupt:\n            self.exit_app()\n\n    def create_entry(self):\n        \"\"\"Create a new journal entry with structured and free-form components\"\"\"\n        print(\"\\n=== New Journal Entry ===\")\n\n        # Get date/time\n        today = datetime.datetime.now()\n        date_str = today.strftime(\"%Y-%m-%d\")\n        time_str = today.strftime(\"%H:%M\")\n\n        # Check if we already have an entry for today\n        existing_entries = [e for e in self.entries if e[\"date\"] == date_str]\n        if existing_entries:\n            print(f\"You already have {len(existing_entries)} entries for today.\")\n            add_another = input(\"Would you like to add another entry? (y/n): \").lower()\n            if add_another != 'y':\n                self.display_menu()\n                return\n\n        # Collect mood data\n        try:\n            mood = int(input(\"\\nHow would you rate your mood right now (1-10)? \"))\n            if not 1 &lt;= mood &lt;= 10:\n                print(\"Please enter a number between 1 and 10.\")\n                mood = 5  # Default to neutral if invalid\n            mood_label = self.mood_labels[mood]\n            print(f\"Mood: {mood}/10 - {mood_label}\")\n        except ValueError:\n            print(\"Invalid input. Setting mood to neutral (5/10).\")\n            mood = 5\n            mood_label = self.mood_labels[mood]\n\n        # Get energy level\n        try:\n            energy = int(input(\"\\nHow is your energy level (1-10)? \"))\n            if not 1 &lt;= energy &lt;= 10:\n                energy = 5  # Default if invalid\n        except ValueError:\n            energy = 5\n\n        # Get prompt for reflection\n        print(\"\\nChoose a prompt for reflection:\")\n        all_prompts = self.default_prompts + self.custom_prompts\n\n        # Show prompts\n        for i, prompt in enumerate(all_prompts, 1):\n            print(f\"{i}. {prompt}\")\n        print(f\"{len(all_prompts) + 1}. Create a custom prompt\")\n\n        try:\n            prompt_choice = int(input(\"\\nSelect a prompt (number): \"))\n            if 1 &lt;= prompt_choice &lt;= len(all_prompts):\n                selected_prompt = all_prompts[prompt_choice - 1]\n            else:\n                custom_prompt = input(\"Enter your custom prompt: \")\n                selected_prompt = custom_prompt\n                # Ask if they want to save this prompt for future use\n                save_prompt = input(\"Would you like to save this prompt for future use? (y/n): \").lower()\n                if save_prompt == 'y':\n                    self.custom_prompts.append(custom_prompt)\n                    self._save_custom_prompts()\n                    print(\"Custom prompt saved.\")\n        except (ValueError, IndexError):\n            # Default to first prompt if invalid\n            selected_prompt = all_prompts[0]\n            print(f\"Using default prompt: {selected_prompt}\")\n\n        # Display the selected prompt and get reflection\n        print(f\"\\n&gt; {selected_prompt}\")\n        reflection = input(\"Your reflection: \")\n\n        # Get activities\n        activities = input(\"\\nWhat activities did you do today? (comma-separated): \")\n        activity_list = [a.strip() for a in activities.split(\",\") if a.strip()]\n\n        # Get any tags the user wants to associate with this entry\n        tags = input(\"\\nAdd any tags to help categorize this entry (comma-separated): \")\n        tag_list = [t.strip() for t in tags.split(\",\") if t.strip()]\n\n        # Create the entry object\n        entry = {\n            \"date\": date_str,\n            \"time\": time_str,\n            \"mood\": mood,\n            \"mood_label\": mood_label,\n            \"energy\": energy,\n            \"prompt\": selected_prompt,\n            \"reflection\": reflection,\n            \"activities\": activity_list,\n            \"tags\": tag_list,\n            \"ai_insights\": None  # Will be filled in by AI\n        }\n\n        # Get AI reflection if user wants it\n        if self.preferences[\"auto_insights\"]:\n            print(\"\\nGenerating insights for your entry...\")\n            entry[\"ai_insights\"] = self._generate_entry_insight(entry)\n            print(\"\\n=== AI Reflection ===\")\n            print(entry[\"ai_insights\"])\n\n        # Add entry to the list and save\n        self.entries.append(entry)\n        self._save_entries()\n        print(\"\\nJournal entry saved successfully!\")\n\n        # Return to menu\n        input(\"\\nPress Enter to continue...\")\n        self.display_menu()\n\n    def view_entries(self):\n        \"\"\"View and search past journal entries\"\"\"\n        if not self.entries:\n            print(\"\\nNo journal entries found.\")\n            input(\"\\nPress Enter to continue...\")\n            self.display_menu()\n            return\n\n        print(\"\\n=== View Journal Entries ===\")\n        print(\"1. View recent entries\")\n        print(\"2. Search by date\")\n        print(\"3. Search by mood\")\n        print(\"4. Search by tag\")\n        print(\"5. Search by text\")\n        print(\"6. Return to main menu\")\n\n        choice = input(\"\\nWhat would you like to do? (1-6): \")\n\n        if choice == \"1\":\n            # Show recent entries\n            recent = self.entries[-10:]  # Last 10 entries\n            recent.reverse()  # Most recent first\n            self._display_entry_list(recent, \"Recent Entries\")\n\n        elif choice == \"2\":\n            # Search by date\n            date_query = input(\"\\nEnter date (YYYY-MM-DD) or month (YYYY-MM): \")\n            matching = [e for e in self.entries if e[\"date\"].startswith(date_query)]\n            self._display_entry_list(matching, f\"Entries for {date_query}\")\n\n        elif choice == \"3\":\n            # Search by mood\n            try:\n                mood_min = int(input(\"\\nEnter minimum mood (1-10): \"))\n                mood_max = int(input(\"Enter maximum mood (1-10): \"))\n                matching = [e for e in self.entries \n                           if mood_min &lt;= e[\"mood\"] &lt;= mood_max]\n                self._display_entry_list(matching, f\"Entries with mood {mood_min}-{mood_max}\")\n            except ValueError:\n                print(\"Invalid input. Please enter numbers for mood range.\")\n\n        elif choice == \"4\":\n            # Search by tag\n            tag = input(\"\\nEnter tag to search for: \").strip().lower()\n            matching = [e for e in self.entries \n                       if any(t.lower() == tag for t in e[\"tags\"])]\n            self._display_entry_list(matching, f\"Entries tagged with '{tag}'\")\n\n        elif choice == \"5\":\n            # Search by text\n            text = input(\"\\nEnter text to search for: \").strip().lower()\n            matching = [e for e in self.entries \n                       if text in e[\"reflection\"].lower() or \n                       text in e[\"prompt\"].lower() or\n                       any(text in a.lower() for a in e[\"activities\"])]\n            self._display_entry_list(matching, f\"Entries containing '{text}'\")\n\n        elif choice == \"6\":\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # After any search, go back to view menu\n        self.view_entries()\n\n    def _display_entry_list(self, entries, title):\n        \"\"\"Display a list of entries and allow user to select one to view in detail\"\"\"\n        if not entries:\n            print(f\"\\nNo entries found for {title}.\")\n            input(\"\\nPress Enter to continue...\")\n            return\n\n        print(f\"\\n=== {title} ===\")\n        for i, entry in enumerate(entries, 1):\n            date_str = entry[\"date\"]\n            mood = entry[\"mood\"]\n\n            # Get a preview of the reflection (first 40 chars)\n            preview = entry[\"reflection\"][:40] + \"...\" if len(entry[\"reflection\"]) &gt; 40 else entry[\"reflection\"]\n\n            print(f\"{i}. {date_str} - Mood: {mood}/10 - {preview}\")\n\n        print(f\"{len(entries) + 1}. Back\")\n\n        try:\n            choice = int(input(\"\\nSelect an entry to view (number): \"))\n            if 1 &lt;= choice &lt;= len(entries):\n                self._display_entry_detail(entries[choice - 1])\n            elif choice == len(entries) + 1:\n                return\n            else:\n                print(\"Invalid choice.\")\n        except ValueError:\n            print(\"Invalid input. Please enter a number.\")\n\n    def _display_entry_detail(self, entry):\n        \"\"\"Display details of a single entry\"\"\"\n        print(\"\\n\" + \"=\" * 50)\n        print(f\"Date: {entry['date']} at {entry['time']}\")\n        print(f\"Mood: {entry['mood']}/10 - {entry['mood_label']}\")\n        print(f\"Energy: {entry['energy']}/10\")\n        print(\"\\nPrompt:\")\n        print(f\"{entry['prompt']}\")\n        print(\"\\nReflection:\")\n        print(f\"{entry['reflection']}\")\n\n        if entry[\"activities\"]:\n            print(\"\\nActivities:\")\n            for activity in entry[\"activities\"]:\n                print(f\"- {activity}\")\n\n        if entry[\"tags\"]:\n            print(\"\\nTags:\")\n            print(\", \".join(entry[\"tags\"]))\n\n        if entry.get(\"ai_insights\"):\n            print(\"\\nAI Insights:\")\n            print(entry[\"ai_insights\"])\n\n        print(\"=\" * 50)\n\n        # Options after viewing an entry\n        print(\"\\n1. Edit this entry\")\n        print(\"2. Delete this entry\")\n        print(\"3. Generate AI insights for this entry\")\n        print(\"4. Back\")\n\n        choice = input(\"\\nWhat would you like to do? (1-4): \")\n\n        if choice == \"1\":\n            self._edit_entry(entry)\n        elif choice == \"2\":\n            self._delete_entry(entry)\n        elif choice == \"3\":\n            if not entry.get(\"ai_insights\"):\n                print(\"\\nGenerating insights...\")\n                entry[\"ai_insights\"] = self._generate_entry_insight(entry)\n                self._save_entries()\n            print(\"\\n=== AI Insights ===\")\n            print(entry[\"ai_insights\"])\n            input(\"\\nPress Enter to continue...\")\n        elif choice == \"4\":\n            return\n        else:\n            print(\"Invalid choice.\")\n            self._display_entry_detail(entry)\n\n    def _edit_entry(self, entry):\n        \"\"\"Edit an existing journal entry\"\"\"\n        print(\"\\n=== Edit Entry ===\")\n        print(\"What would you like to modify?\")\n        print(\"1. Mood rating\")\n        print(\"2. Energy rating\")\n        print(\"3. Reflection text\")\n        print(\"4. Activities\")\n        print(\"5. Tags\")\n        print(\"6. Cancel edit\")\n\n        choice = input(\"\\nEnter your choice (1-6): \")\n\n        if choice == \"1\":\n            try:\n                new_mood = int(input(\"Enter new mood rating (1-10): \"))\n                if 1 &lt;= new_mood &lt;= 10:\n                    entry[\"mood\"] = new_mood\n                    entry[\"mood_label\"] = self.mood_labels[new_mood]\n                    print(\"Mood updated.\")\n                else:\n                    print(\"Invalid mood rating. Must be between 1 and 10.\")\n            except ValueError:\n                print(\"Invalid input. Mood not changed.\")\n\n        elif choice == \"2\":\n            try:\n                new_energy = int(input(\"Enter new energy rating (1-10): \"))\n                if 1 &lt;= new_energy &lt;= 10:\n                    entry[\"energy\"] = new_energy\n                    print(\"Energy updated.\")\n                else:\n                    print(\"Invalid energy rating. Must be between 1 and 10.\")\n            except ValueError:\n                print(\"Invalid input. Energy not changed.\")\n\n        elif choice == \"3\":\n            print(f\"Current reflection: {entry['reflection']}\")\n            new_text = input(\"Enter new reflection (or press Enter to keep current): \")\n            if new_text:\n                entry[\"reflection\"] = new_text\n                print(\"Reflection updated.\")\n\n        elif choice == \"4\":\n            print(f\"Current activities: {', '.join(entry['activities'])}\")\n            new_activities = input(\"Enter new activities (comma-separated): \")\n            if new_activities:\n                entry[\"activities\"] = [a.strip() for a in new_activities.split(\",\") if a.strip()]\n                print(\"Activities updated.\")\n\n        elif choice == \"5\":\n            print(f\"Current tags: {', '.join(entry['tags'])}\")\n            new_tags = input(\"Enter new tags (comma-separated): \")\n            if new_tags:\n                entry[\"tags\"] = [t.strip() for t in new_tags.split(\",\") if t.strip()]\n                print(\"Tags updated.\")\n\n        elif choice == \"6\":\n            print(\"Edit canceled.\")\n            self._display_entry_detail(entry)\n            return\n\n        else:\n            print(\"Invalid choice.\")\n            self._edit_entry(entry)\n            return\n\n        # After any edit, regenerate insights if auto-insights is enabled\n        if self.preferences[\"auto_insights\"]:\n            print(\"Regenerating insights for updated entry...\")\n            entry[\"ai_insights\"] = self._generate_entry_insight(entry)\n\n        # Save changes\n        self._save_entries()\n        print(\"Entry updated successfully.\")\n\n        # Show the updated entry\n        self._display_entry_detail(entry)\n\n    def _delete_entry(self, entry):\n        \"\"\"Delete a journal entry\"\"\"\n        confirm = input(\"\\nAre you sure you want to delete this entry? (y/n): \").lower()\n        if confirm == 'y':\n            self.entries.remove(entry)\n            self._save_entries()\n            print(\"Entry deleted successfully.\")\n        else:\n            print(\"Deletion canceled.\")\n            self._display_entry_detail(entry)\n\n    def _generate_entry_insight(self, entry):\n        \"\"\"Generate AI insights for a journal entry\"\"\"\n        prompt = f\"\"\"\n        The user wrote a journal entry with the following details:\n        - Date: {entry['date']}\n        - Mood: {entry['mood']}/10 ({entry['mood_label']})\n        - Energy: {entry['energy']}/10\n        - Prompt: \"{entry['prompt']}\"\n        - Reflection: \"{entry['reflection']}\"\n        - Activities: {', '.join(entry['activities']) if entry['activities'] else 'None mentioned'}\n        - Tags: {', '.join(entry['tags']) if entry['tags'] else 'None'}\n\n        Please provide a thoughtful, empathetic reflection on this entry. Include:\n        1. An observation about their mood and energy\n        2. A meaningful insight about their reflection\n        3. A gentle question to deepen their self-awareness\n\n        Keep your response concise and supportive (150 words max).\n        \"\"\"\n\n        return get_response(prompt, \n                          system=\"You are an empathetic journaling assistant who helps users gain deeper insights from their reflections.\")\n\n    def get_insights(self):\n        \"\"\"Generate analytics and AI insights from journal entries\"\"\"\n        if len(self.entries) &lt; 3:\n            print(\"\\nYou need at least 3 journal entries to generate insights.\")\n            input(\"\\nPress Enter to continue...\")\n            self.display_menu()\n            return\n\n        print(\"\\n=== Journal Insights &amp; Analytics ===\")\n        print(\"1. Mood trends visualization\")\n        print(\"2. Activity impact analysis\")\n        print(\"3. Word cloud and themes\")\n        print(\"4. Weekly summary\")\n        print(\"5. Monthly review\")\n        print(\"6. Custom date range analysis\")\n        print(\"7. Return to main menu\")\n\n        choice = input(\"\\nWhat would you like to see? (1-7): \")\n\n        if choice == \"1\":\n            self._visualize_mood_trends()\n        elif choice == \"2\":\n            self._analyze_activity_impact()\n        elif choice == \"3\":\n            self._generate_word_cloud()\n        elif choice == \"4\":\n            self._generate_weekly_summary()\n        elif choice == \"5\":\n            self._generate_monthly_review()\n        elif choice == \"6\":\n            self._custom_date_analysis()\n        elif choice == \"7\":\n            self.display_menu()\n            return\n        else:\n            print(\"Invalid choice.\")\n\n        # Return to insights menu\n        input(\"\\nPress Enter to continue...\")\n        self.get_insights()\n\n    def _visualize_mood_trends(self):\n        \"\"\"Visualize mood trends over time\"\"\"\n        # Extract dates and moods\n        dates = [datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\") for e in self.entries]\n        moods = [e[\"mood\"] for e in self.entries]\n        energy = [e[\"energy\"] for e in self.entries]\n\n        # Create the visualization\n        plt.figure(figsize=(12, 6))\n        plt.plot(dates, moods, 'b-o', label='Mood')\n        plt.plot(dates, energy, 'r-o', label='Energy')\n        plt.axhline(y=5, color='g', linestyle='--', alpha=0.3, label='Neutral')\n\n        plt.title('Mood and Energy Trends')\n        plt.xlabel('Date')\n        plt.ylabel('Rating (1-10)')\n        plt.grid(True, alpha=0.3)\n        plt.legend()\n\n        # Format the x-axis to show dates nicely\n        plt.gcf().autofmt_xdate()\n\n        # Save the visualization\n        viz_path = os.path.join(self.visualization_dir, f\"mood_trends_{datetime.datetime.now().strftime('%Y%m%d')}.png\")\n        plt.savefig(viz_path)\n\n        print(f\"\\nMood trend visualization saved to: {viz_path}\")\n        print(\"\\nInsights about your mood trends:\")\n\n        # Calculate some basic statistics\n        avg_mood = sum(moods) / len(moods)\n        avg_energy = sum(energy) / len(energy)\n        mood_trend = \"improving\" if moods[-1] &gt; moods[0] else \"declining\" if moods[-1] &lt; moods[0] else \"stable\"\n\n        print(f\"- Your average mood is {avg_mood:.1f}/10\")\n        print(f\"- Your average energy level is {avg_energy:.1f}/10\")\n        print(f\"- Your overall mood trend appears to be {mood_trend}\")\n\n        # Generate AI insights on mood trends\n        if len(self.entries) &gt;= 5:  # Need enough data for meaningful trends\n            entries_text = \"\\n\".join([\n                f\"Date: {e['date']}, Mood: {e['mood']}/10, Energy: {e['energy']}/10, Activities: {', '.join(e['activities'])}\"\n                for e in self.entries[-10:]  # Last 10 entries\n            ])\n\n            prompt = f\"\"\"\n            Here are the user's recent journal entries with mood and energy ratings:\n\n            {entries_text}\n\n            Based on this data, provide:\n            1. Any patterns you notice in their mood and energy levels\n            2. Potential correlations between activities and mood\n            3. A gentle suggestion based on these patterns\n\n            Keep your response concise (150 words max).\n            \"\"\"\n\n            insights = get_response(prompt, \n                                  system=\"You are an analytical journaling assistant who helps identify patterns in mood, energy, and behavior.\")\n\n            print(\"\\nAI Analysis:\")\n            print(insights)\n\n    def _analyze_activity_impact(self):\n        \"\"\"Analyze how different activities impact mood\"\"\"\n        if not any(e.get(\"activities\") for e in self.entries):\n            print(\"\\nNot enough activity data found in your entries.\")\n            return\n\n        # Create a dictionary to track activities and associated moods\n        activity_moods = {}\n\n        # Collect data\n        for entry in self.entries:\n            mood = entry[\"mood\"]\n            for activity in entry.get(\"activities\", []):\n                activity = activity.lower().strip()\n                if activity:\n                    if activity not in activity_moods:\n                        activity_moods[activity] = []\n                    activity_moods[activity].append(mood)\n\n        # Filter to activities with at least 2 data points\n        activity_moods = {k: v for k, v in activity_moods.items() if len(v) &gt;= 2}\n\n        if not activity_moods:\n            print(\"\\nNot enough repeated activities found to analyze impact.\")\n            return\n\n        # Calculate average mood for each activity\n        activity_avg_moods = {activity: sum(moods)/len(moods) \n                             for activity, moods in activity_moods.items()}\n\n        # Sort activities by average mood (highest first)\n        sorted_activities = sorted(activity_avg_moods.items(), \n                                  key=lambda x: x[1], reverse=True)\n\n        # Display results\n        print(\"\\n=== Activity Impact Analysis ===\")\n        print(\"Activities sorted by average mood impact:\")\n\n        for activity, avg_mood in sorted_activities:\n            count = len(activity_moods[activity])\n            print(f\"- {activity.title()}: {avg_mood:.1f}/10 (mentioned {count} times)\")\n\n        # Visualize top activities\n        top_activities = sorted_activities[:min(8, len(sorted_activities))]\n\n        activities = [a[0].title() for a in top_activities]\n        avg_moods = [a[1] for a in top_activities]\n\n        plt.figure(figsize=(10, 6))\n        bars = plt.bar(activities, avg_moods, color='skyblue')\n\n        # Add value labels on top of bars\n        for bar in bars:\n            height = bar.get_height()\n            plt.text(bar.get_x() + bar.get_width()/2., height + 0.1,\n                    f'{height:.1f}', ha='center', va='bottom')\n\n        plt.title('Activities and Their Impact on Mood')\n        plt.xlabel('Activities')\n        plt.ylabel('Average Mood (1-10)')\n        plt.ylim(0, 10.5)  # Set y-axis limit with some padding\n        plt.grid(axis='y', alpha=0.3)\n\n        # Rotate x-axis labels for better readability\n        plt.xticks(rotation=45, ha='right')\n        plt.tight_layout()\n\n        # Save the visualization\n        viz_path = os.path.join(self.visualization_dir, f\"activity_impact_{datetime.datetime.now().strftime('%Y%m%d')}.png\")\n        plt.savefig(viz_path)\n\n        print(f\"\\nActivity impact visualization saved to: {viz_path}\")\n\n        # Generate AI insights\n        activities_text = \"\\n\".join([\n            f\"Activity: {activity}, Average Mood: {avg_mood:.1f}/10, Occurrences: {len(activity_moods[activity])}\"\n            for activity, avg_mood in sorted_activities\n        ])\n\n        prompt = f\"\"\"\n        Here's an analysis of how different activities affect the user's mood:\n\n        {activities_text}\n\n        Based on this data, provide:\n        1. Observations about which activities seem to have the most positive impact\n        2. Suggestions for which activities they might want to prioritize\n        3. A gentle question about their activity patterns\n\n        Keep your response concise (150 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an analytical journaling assistant who helps identify patterns between activities and well-being.\")\n\n        print(\"\\nAI Analysis:\")\n        print(insights)\n\n    def _generate_word_cloud(self):\n        \"\"\"Generate a word frequency analysis of journal entries\"\"\"\n        if not self.entries:\n            print(\"\\nNo journal entries found.\")\n            return\n\n        # Combine all reflections\n        all_text = \" \".join([e[\"reflection\"] for e in self.entries])\n\n        # Remove common stop words (simplified)\n        stop_words = [\"the\", \"and\", \"a\", \"to\", \"of\", \"in\", \"i\", \"it\", \"is\", \"that\", \n                     \"was\", \"for\", \"on\", \"you\", \"he\", \"be\", \"with\", \"as\", \"by\", \"at\", \n                     \"have\", \"are\", \"this\", \"but\", \"not\", \"from\", \"had\", \"has\", \"was\", \n                     \"were\", \"they\", \"will\", \"would\", \"could\", \"should\", \"did\", \"do\",\n                     \"does\", \"their\", \"there\", \"then\", \"than\", \"them\", \"these\", \"those\"]\n\n        # Extract words, convert to lowercase, and remove punctuation\n        words = re.findall(r'\\b[a-zA-Z]+\\b', all_text.lower())\n\n        # Filter out stop words\n        filtered_words = [word for word in words if word not in stop_words and len(word) &gt; 2]\n\n        # Count word frequencies\n        word_counts = Counter(filtered_words)\n\n        # Get the top 20 most frequent words\n        top_words = word_counts.most_common(20)\n\n        # Display results\n        print(\"\\n=== Word Frequency Analysis ===\")\n        print(\"Most common words in your journal:\")\n\n        for word, count in top_words:\n            print(f\"- {word}: {count} occurrences\")\n\n        # Visualize word frequencies\n        words = [w[0] for w in top_words]\n        counts = [w[1] for w in top_words]\n\n        plt.figure(figsize=(12, 6))\n        bars = plt.barh(words[::-1], counts[::-1], color='lightgreen')  # Reverse to show highest at top\n\n        # Add value labels\n        for bar in bars:\n            width = bar.get_width()\n            plt.text(width + 0.5, bar.get_y() + bar.get_height()/2., \n                    f'{width}', ha='left', va='center')\n\n        plt.title('Most Common Words in Journal Entries')\n        plt.xlabel('Frequency')\n        plt.tight_layout()\n\n        # Save the visualization\n        viz_path = os.path.join(self.visualization_dir, f\"word_frequency_{datetime.datetime.now().strftime('%Y%m%d')}.png\")\n        plt.savefig(viz_path)\n\n        print(f\"\\nWord frequency visualization saved to: {viz_path}\")\n\n        # Generate AI insights on themes\n        prompt = f\"\"\"\n        These are the most common words in the user's journal entries:\n\n        {', '.join([f\"{word} ({count})\" for word, count in top_words])}\n\n        Based on these words, please:\n        1. Identify potential themes or patterns in their journaling\n        2. Suggest areas for deeper reflection\n        3. Provide a gentle observation about what these themes might indicate\n\n        Keep your response concise (150 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an insightful journaling assistant who helps identify themes and patterns in journal entries.\")\n\n        print(\"\\nAI Theme Analysis:\")\n        print(insights)\n\n    def _generate_weekly_summary(self):\n        \"\"\"Generate a weekly summary of journal entries\"\"\"\n        # Get entries from the past 7 days\n        today = datetime.datetime.now().date()\n        week_ago = today - datetime.timedelta(days=7)\n\n        weekly_entries = [e for e in self.entries \n                         if datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\").date() &gt;= week_ago]\n\n        if len(weekly_entries) &lt; 2:\n            print(\"\\nNot enough entries in the past week for a meaningful summary.\")\n            return\n\n        # Compile weekly data\n        weekly_moods = [e[\"mood\"] for e in weekly_entries]\n        avg_mood = sum(weekly_moods) / len(weekly_moods)\n\n        weekly_energy = [e[\"energy\"] for e in weekly_entries]\n        avg_energy = sum(weekly_energy) / len(weekly_energy)\n\n        # Get all activities\n        all_activities = []\n        for entry in weekly_entries:\n            all_activities.extend(entry.get(\"activities\", []))\n\n        # Count activity frequencies\n        activity_counts = Counter(all_activities)\n        most_common = activity_counts.most_common(5)\n\n        # Display weekly summary\n        print(\"\\n=== Weekly Summary ===\")\n        print(f\"Period: {week_ago.strftime('%Y-%m-%d')} to {today.strftime('%Y-%m-%d')}\")\n        print(f\"Number of entries: {len(weekly_entries)}\")\n        print(f\"Average mood: {avg_mood:.1f}/10\")\n        print(f\"Average energy: {avg_energy:.1f}/10\")\n\n        if most_common:\n            print(\"\\nMost common activities:\")\n            for activity, count in most_common:\n                print(f\"- {activity}: {count} times\")\n\n        # Generate AI summary\n        entries_text = \"\\n\\n\".join([\n            f\"Date: {e['date']}\\nMood: {e['mood']}/10\\nEnergy: {e['energy']}/10\\n\"\n            f\"Activities: {', '.join(e.get('activities', []))}\\nReflection: {e['reflection']}\"\n            for e in weekly_entries\n        ])\n\n        prompt = f\"\"\"\n        Here's a summary of the user's journal entries for the past week:\n\n        {entries_text}\n\n        Please provide a weekly reflection that includes:\n        1. Notable patterns or trends in their mood and energy\n        2. Observations about activities and their potential impact\n        3. A gentle suggestion for the coming week\n        4. A thoughtful reflection question\n\n        Keep your response concise and supportive (200 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an empathetic journaling assistant who helps provide weekly summaries and insights.\")\n\n        print(\"\\nAI Weekly Reflection:\")\n        print(insights)\n\n    def _generate_monthly_review(self):\n        \"\"\"Generate a monthly review of journal entries\"\"\"\n        # Get entries from the current month\n        today = datetime.datetime.now()\n        first_day = datetime.datetime(today.year, today.month, 1)\n\n        # For previous month, use:\n        # prev_month = first_day - datetime.timedelta(days=1)\n        # first_day = datetime.datetime(prev_month.year, prev_month.month, 1)\n\n        monthly_entries = [e for e in self.entries \n                          if datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\") &gt;= first_day]\n\n        if len(monthly_entries) &lt; 3:\n            print(\"\\nNot enough entries this month for a meaningful review.\")\n            return\n\n        # Compile monthly data\n        monthly_moods = [e[\"mood\"] for e in monthly_entries]\n        avg_mood = sum(monthly_moods) / len(monthly_moods)\n        high_mood = max(monthly_moods)\n        low_mood = min(monthly_moods)\n\n        high_entry = next(e for e in monthly_entries if e[\"mood\"] == high_mood)\n        low_entry = next(e for e in monthly_entries if e[\"mood\"] == low_mood)\n\n        # Get all activities and tags\n        all_activities = []\n        all_tags = []\n        for entry in monthly_entries:\n            all_activities.extend(entry.get(\"activities\", []))\n            all_tags.extend(entry.get(\"tags\", []))\n\n        # Count frequencies\n        activity_counts = Counter(all_activities)\n        tag_counts = Counter(all_tags)\n\n        # Display monthly review\n        print(\"\\n=== Monthly Review ===\")\n        print(f\"Month: {first_day.strftime('%B %Y')}\")\n        print(f\"Number of entries: {len(monthly_entries)}\")\n        print(f\"Average mood: {avg_mood:.1f}/10\")\n        print(f\"Highest mood: {high_mood}/10 on {high_entry['date']}\")\n        print(f\"Lowest mood: {low_mood}/10 on {low_entry['date']}\")\n\n        if activity_counts:\n            print(\"\\nTop activities this month:\")\n            for activity, count in activity_counts.most_common(5):\n                print(f\"- {activity}: {count} times\")\n\n        if tag_counts:\n            print(\"\\nTop themes/tags this month:\")\n            for tag, count in tag_counts.most_common(5):\n                print(f\"- {tag}: {count} times\")\n\n        # Generate AI review\n        entries_summary = \"\\n\".join([\n            f\"Date: {e['date']}, Mood: {e['mood']}/10, Energy: {e['energy']}/10, \"\n            f\"Activities: {', '.join(e.get('activities', []))}, Tags: {', '.join(e.get('tags', []))}\"\n            for e in monthly_entries\n        ])\n\n        prompt = f\"\"\"\n        Here's a summary of the user's journal entries for {first_day.strftime('%B %Y')}:\n\n        {entries_summary}\n\n        Please provide a monthly review that includes:\n        1. Overall patterns in mood and energy\n        2. Key achievements or challenges that stood out\n        3. Activities that seemed most beneficial\n        4. Gentle suggestions for next month\n        5. A thoughtful reflection question\n\n        Keep your response supportive and actionable (250 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an insightful journaling assistant who helps provide monthly reviews and insights.\")\n\n        print(\"\\nAI Monthly Review:\")\n        print(insights)\n\n    def _custom_date_analysis(self):\n        \"\"\"Generate insights for a custom date range\"\"\"\n        print(\"\\n=== Custom Date Range Analysis ===\")\n\n        # Get start date\n        start_date_str = input(\"Enter start date (YYYY-MM-DD): \")\n        try:\n            start_date = datetime.datetime.strptime(start_date_str, \"%Y-%m-%d\").date()\n        except ValueError:\n            print(\"Invalid date format. Using 30 days ago as default.\")\n            start_date = datetime.datetime.now().date() - datetime.timedelta(days=30)\n\n        # Get end date\n        end_date_str = input(\"Enter end date (YYYY-MM-DD) or press Enter for today: \")\n        if end_date_str:\n            try:\n                end_date = datetime.datetime.strptime(end_date_str, \"%Y-%m-%d\").date()\n            except ValueError:\n                print(\"Invalid date format. Using today as default.\")\n                end_date = datetime.datetime.now().date()\n        else:\n            end_date = datetime.datetime.now().date()\n\n        # Validate date range\n        if start_date &gt; end_date:\n            print(\"Start date must be before end date. Swapping dates.\")\n            start_date, end_date = end_date, start_date\n\n        # Filter entries by date range\n        filtered_entries = [e for e in self.entries \n                           if start_date &lt;= datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\").date() &lt;= end_date]\n\n        if len(filtered_entries) &lt; 2:\n            print(f\"\\nNot enough entries between {start_date} and {end_date} for analysis.\")\n            return\n\n        # Display basic stats\n        moods = [e[\"mood\"] for e in filtered_entries]\n        avg_mood = sum(moods) / len(moods)\n\n        print(f\"\\nPeriod: {start_date} to {end_date}\")\n        print(f\"Number of entries: {len(filtered_entries)}\")\n        print(f\"Average mood: {avg_mood:.1f}/10\")\n\n        # Create mood trend visualization\n        dates = [datetime.datetime.strptime(e[\"date\"], \"%Y-%m-%d\") for e in filtered_entries]\n        moods = [e[\"mood\"] for e in filtered_entries]\n        energy = [e[\"energy\"] for e in filtered_entries]\n\n        plt.figure(figsize=(12, 6))\n        plt.plot(dates, moods, 'b-o', label='Mood')\n        plt.plot(dates, energy, 'r-o', label='Energy')\n        plt.axhline(y=5, color='g', linestyle='--', alpha=0.3, label='Neutral')\n\n        plt.title(f'Mood and Energy Trends ({start_date} to {end_date})')\n        plt.xlabel('Date')\n        plt.ylabel('Rating (1-10)')\n        plt.grid(True, alpha=0.3)\n        plt.legend()\n\n        # Format the x-axis to show dates nicely\n        plt.gcf().autofmt_xdate()\n        plt.tight_layout()\n\n        # Save the visualization\n        viz_path = os.path.join(self.visualization_dir, \n                              f\"custom_trend_{start_date}_{end_date}.png\")\n        plt.savefig(viz_path)\n\n        print(f\"\\nCustom trend visualization saved to: {viz_path}\")\n\n        # Generate AI insights\n        entries_summary = \"\\n\".join([\n            f\"Date: {e['date']}, Mood: {e['mood']}/10, Energy: {e['energy']}/10, \"\n            f\"Activities: {', '.join(e.get('activities', []))}, Reflection: {e['reflection'][:100]}...\"\n            for e in filtered_entries\n        ])\n\n        prompt = f\"\"\"\n        Here's a summary of the user's journal entries from {start_date} to {end_date}:\n\n        {entries_summary}\n\n        Please provide a custom period analysis that includes:\n        1. Notable trends or patterns in mood and energy\n        2. Key themes or recurring topics\n        3. Activities that appeared to influence mood\n        4. A thoughtful observation about this period\n\n        Keep your response insightful and supportive (200 words max).\n        \"\"\"\n\n        insights = get_response(prompt, \n                              system=\"You are an analytical journaling assistant who helps identify patterns across custom time periods.\")\n\n        print(\"\\nAI Period Analysis:\")\n        print(insights)\n\n    def manage_prompts(self):\n        \"\"\"Manage custom prompts\"\"\"\n        print(\"\\n=== Manage Custom Prompts ===\")\n        print(\"1. View all prompts\")\n        print(\"2. Add new prompt\")\n        print(\"3. Delete prompt\")\n        print(\"4. Return to main menu\")\n\n        choice = input(\"\\nWhat would you like to do? (1-4): \")\n\n        if choice == \"1\":\n            # View all prompts\n            print(\"\\n=== Available Prompts ===\")\n            print(\"Default prompts:\")\n            for i, prompt in enumerate(self.default_prompts, 1):\n                print(f\"{i}. {prompt}\")\n\n            if self.custom_prompts:\n                print(\"\\nCustom prompts:\")\n                for i, prompt in enumerate(self.custom_prompts, 1):\n                    print(f\"{i}. {prompt}\")\n            else:\n                print(\"\\nNo custom prompts yet.\")\n\n        elif choice == \"2\":\n            # Add new prompt\n            new_prompt = input(\"\\nEnter a new journal prompt: \")\n            if new_prompt:\n                self.custom_prompts.append(new_prompt)\n                self._save_custom_prompts()\n                print(\"Custom prompt added successfully!\")\n\n        elif choice == \"3\":\n            # Delete prompt\n            if not self.custom_prompts:\n                print(\"\\nNo custom prompts to delete.\")\n                self.manage_prompts()\n                return\n\n            print(\"\\nCustom prompts:\")\n            for i, prompt in enumerate(self.custom_prompts, 1):\n                print(f\"{i}. {prompt}\")\n\n            try:\n                idx = int(input(\"\\nEnter the number of the prompt to delete: \")) - 1\n                if 0 &lt;= idx &lt; len(self.custom_prompts):\n                    deleted = self.custom_prompts.pop(idx)\n                    self._save_custom_prompts()\n                    print(f\"Deleted prompt: {deleted}\")\n                else:\n                    print(\"Invalid prompt number.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        elif choice == \"4\":\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # Return to prompt management menu\n        self.manage_prompts()\n\n    def set_goals(self):\n        \"\"\"Set goals and intentions\"\"\"\n        print(\"\\n=== Goals and Intentions ===\")\n        print(\"1. View current goals\")\n        print(\"2. Add new goal\")\n        print(\"3. Update goal progress\")\n        print(\"4. Delete goal\")\n        print(\"5. Generate goal suggestions\")\n        print(\"6. Return to main menu\")\n\n        # Load goals from file\n        goals_file = os.path.join(self.journal_dir, \"goals.json\")\n        if os.path.exists(goals_file):\n            try:\n                with open(goals_file, 'r') as f:\n                    goals = json.load(f)\n            except json.JSONDecodeError:\n                goals = []\n        else:\n            goals = []\n\n        choice = input(\"\\nWhat would you like to do? (1-6): \")\n\n        if choice == \"1\":\n            # View current goals\n            if not goals:\n                print(\"\\nNo goals found.\")\n            else:\n                print(\"\\n=== Current Goals ===\")\n                for i, goal in enumerate(goals, 1):\n                    status = f\"{goal['progress']}% complete\" if 'progress' in goal else \"Not started\"\n                    target_date = goal.get('target_date', 'No target date')\n                    print(f\"{i}. {goal['description']} - {status} - Target: {target_date}\")\n\n                    if 'milestones' in goal and goal['milestones']:\n                        print(\"   Milestones:\")\n                        for m in goal['milestones']:\n                            check = \"\u2713\" if m.get('completed', False) else \"\u25cb\"\n                            print(f\"   {check} {m['description']}\")\n\n        elif choice == \"2\":\n            # Add new goal\n            print(\"\\n=== Add New Goal ===\")\n            description = input(\"Goal description: \")\n            if not description:\n                print(\"Goal description cannot be empty.\")\n                self.set_goals()\n                return\n\n            target_date = input(\"Target date (YYYY-MM-DD) or leave blank: \")\n            if target_date:\n                try:\n                    # Validate date format\n                    datetime.datetime.strptime(target_date, \"%Y-%m-%d\")\n                except ValueError:\n                    print(\"Invalid date format. Using no target date.\")\n                    target_date = \"\"\n\n            # Create goal object\n            goal = {\n                \"description\": description,\n                \"created_date\": datetime.datetime.now().strftime(\"%Y-%m-%d\"),\n                \"progress\": 0\n            }\n\n            if target_date:\n                goal[\"target_date\"] = target_date\n\n            # Ask for milestones\n            add_milestones = input(\"Would you like to add milestones? (y/n): \").lower()\n            if add_milestones == 'y':\n                milestones = []\n                while True:\n                    milestone = input(\"Enter milestone (or leave blank to finish): \")\n                    if not milestone:\n                        break\n                    milestones.append({\"description\": milestone, \"completed\": False})\n\n                if milestones:\n                    goal[\"milestones\"] = milestones\n\n            # Add goal to list and save\n            goals.append(goal)\n            with open(goals_file, 'w') as f:\n                json.dump(goals, f, indent=2)\n\n            print(\"Goal added successfully!\")\n\n        elif choice == \"3\":\n            # Update goal progress\n            if not goals:\n                print(\"\\nNo goals found.\")\n                self.set_goals()\n                return\n\n            print(\"\\n=== Update Goal Progress ===\")\n            for i, goal in enumerate(goals, 1):\n                status = f\"{goal['progress']}% complete\" if 'progress' in goal else \"Not started\"\n                print(f\"{i}. {goal['description']} - {status}\")\n\n            try:\n                idx = int(input(\"\\nEnter the number of the goal to update: \")) - 1\n                if 0 &lt;= idx &lt; len(goals):\n                    goal = goals[idx]\n\n                    print(f\"\\nUpdating goal: {goal['description']}\")\n\n                    # Update progress\n                    try:\n                        new_progress = int(input(f\"Enter new progress (0-100) [current: {goal.get('progress', 0)}%]: \"))\n                        if 0 &lt;= new_progress &lt;= 100:\n                            goal['progress'] = new_progress\n                        else:\n                            print(\"Progress must be between 0 and 100.\")\n                    except ValueError:\n                        print(\"Invalid input. Progress not updated.\")\n\n                    # Update milestones if they exist\n                    if 'milestones' in goal and goal['milestones']:\n                        print(\"\\nUpdate milestones:\")\n                        for i, milestone in enumerate(goal['milestones'], 1):\n                            status = \"Completed\" if milestone.get('completed', False) else \"Not completed\"\n                            print(f\"{i}. {milestone['description']} - {status}\")\n\n                            update = input(f\"Mark as {'not ' if milestone.get('completed', False) else ''}completed? (y/n): \").lower()\n                            if update == 'y':\n                                milestone['completed'] = not milestone.get('completed', False)\n\n                    # Save updated goals\n                    with open(goals_file, 'w') as f:\n                        json.dump(goals, f, indent=2)\n\n                    print(\"Goal updated successfully!\")\n                else:\n                    print(\"Invalid goal number.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        elif choice == \"4\":\n            # Delete goal\n            if not goals:\n                print(\"\\nNo goals found.\")\n                self.set_goals()\n                return\n\n            print(\"\\n=== Delete Goal ===\")\n            for i, goal in enumerate(goals, 1):\n                print(f\"{i}. {goal['description']}\")\n\n            try:\n                idx = int(input(\"\\nEnter the number of the goal to delete: \")) - 1\n                if 0 &lt;= idx &lt; len(goals):\n                    goal = goals.pop(idx)\n\n                    # Save updated goals\n                    with open(goals_file, 'w') as f:\n                        json.dump(goals, f, indent=2)\n\n                    print(f\"Goal '{goal['description']}' deleted successfully!\")\n                else:\n                    print(\"Invalid goal number.\")\n            except ValueError:\n                print(\"Invalid input. Please enter a number.\")\n\n        elif choice == \"5\":\n            # Generate goal suggestions\n            if not self.entries or len(self.entries) &lt; 5:\n                print(\"\\nNot enough journal entries to generate meaningful goal suggestions.\")\n                self.set_goals()\n                return\n\n            print(\"\\nGenerating goal suggestions based on your journal entries...\")\n\n            # Get recent entries\n            recent_entries = self.entries[-15:]  # Last 15 entries\n            entries_text = \"\\n\\n\".join([\n                f\"Date: {e['date']}\\nMood: {e['mood']}/10\\nActivities: {', '.join(e.get('activities', []))}\\n\"\n                f\"Tags: {', '.join(e.get('tags', []))}\\nReflection: {e['reflection']}\"\n                for e in recent_entries\n            ])\n\n            prompt = f\"\"\"\n            Here are some recent journal entries from the user:\n\n            {entries_text}\n\n            Based on these entries, suggest 3-5 meaningful goals or intentions that might help the user's wellbeing or personal growth. For each goal:\n            1. Provide a clear, actionable description\n            2. Explain briefly why this goal might be beneficial (based on patterns in their journal)\n            3. Suggest 2-3 possible milestones for the goal\n\n            Make the goals specific, measurable, and aligned with what seems to matter to the user.\n            \"\"\"\n\n            suggestions = get_response(prompt, \n                                     system=\"You are a supportive goal-setting assistant who helps users identify meaningful goals based on their journal patterns.\")\n\n            print(\"\\n=== Goal Suggestions ===\")\n            print(suggestions)\n\n        elif choice == \"6\":\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # Return to goals menu\n        self.set_goals()\n\n    def set_preferences(self):\n        \"\"\"Set user preferences\"\"\"\n        print(\"\\n=== Preferences ===\")\n        print(f\"1. Auto-generate insights: {self.preferences['auto_insights']}\")\n        print(f\"2. Daily reminder: {self.preferences['daily_reminder']}\")\n        print(f\"3. Reminder time: {self.preferences['reminder_time']}\")\n        print(f\"4. Theme: {self.preferences['theme']}\")\n        print(f\"5. Insight frequency: {self.preferences['insight_frequency']}\")\n        print(\"6. Return to main menu\")\n\n        choice = input(\"\\nWhat would you like to change? (1-6): \")\n\n        if choice == \"1\":\n            # Toggle auto-insights\n            self.preferences['auto_insights'] = not self.preferences['auto_insights']\n            print(f\"Auto-generate insights: {self.preferences['auto_insights']}\")\n\n        elif choice == \"2\":\n            # Toggle daily reminder\n            self.preferences['daily_reminder'] = not self.preferences['daily_reminder']\n            print(f\"Daily reminder: {self.preferences['daily_reminder']}\")\n\n        elif choice == \"3\":\n            # Set reminder time\n            time_str = input(\"Enter reminder time (HH:MM): \")\n            try:\n                # Validate time format\n                datetime.datetime.strptime(time_str, \"%H:%M\")\n                self.preferences['reminder_time'] = time_str\n                print(f\"Reminder time set to: {time_str}\")\n            except ValueError:\n                print(\"Invalid time format. Using previous setting.\")\n\n        elif choice == \"4\":\n            # Set theme\n            print(\"\\nAvailable themes:\")\n            themes = [\"standard\", \"dark\", \"light\", \"colorful\"]\n            for i, theme in enumerate(themes, 1):\n                print(f\"{i}. {theme}\")\n\n            try:\n                idx = int(input(\"\\nSelect theme number: \")) - 1\n                if 0 &lt;= idx &lt; len(themes):\n                    self.preferences['theme'] = themes[idx]\n                    print(f\"Theme set to: {themes[idx]}\")\n                else:\n                    print(\"Invalid theme number.\")\n            except ValueError:\n                print(\"Invalid input. Theme not changed.\")\n\n        elif choice == \"5\":\n            # Set insight frequency\n            print(\"\\nInsight frequency options:\")\n            frequencies = [\"daily\", \"weekly\", \"monthly\"]\n            for i, freq in enumerate(frequencies, 1):\n                print(f\"{i}. {freq}\")\n\n            try:\n                idx = int(input(\"\\nSelect frequency number: \")) - 1\n                if 0 &lt;= idx &lt; len(frequencies):\n                    self.preferences['insight_frequency'] = frequencies[idx]\n                    print(f\"Insight frequency set to: {frequencies[idx]}\")\n                else:\n                    print(\"Invalid frequency number.\")\n            except ValueError:\n                print(\"Invalid input. Frequency not changed.\")\n\n        elif choice == \"6\":\n            self._save_preferences()\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # Save preferences after any change\n        self._save_preferences()\n\n        # Return to preferences menu\n        self.set_preferences()\n\n    def export_journal(self):\n        \"\"\"Export journal to different formats\"\"\"\n        if not self.entries:\n            print(\"\\nNo journal entries to export.\")\n            input(\"\\nPress Enter to continue...\")\n            self.display_menu()\n            return\n\n        print(\"\\n=== Export Journal ===\")\n        print(\"1. Export as text file\")\n        print(\"2. Export as CSV\")\n        print(\"3. Export as PDF (plain)\")\n        print(\"4. Export with visualizations\")\n        print(\"5. Return to main menu\")\n\n        choice = input(\"\\nChoose export format (1-5): \")\n\n        if choice == \"1\":\n            # Export as text\n            export_path = os.path.join(self.journal_dir, f\"journal_export_{datetime.datetime.now().strftime('%Y%m%d')}.txt\")\n\n            with open(export_path, 'w') as f:\n                f.write(\"===== JOURNAL EXPORT =====\\n\\n\")\n\n                for entry in sorted(self.entries, key=lambda e: e[\"date\"]):\n                    f.write(f\"Date: {entry['date']} at {entry.get('time', '00:00')}\\n\")\n                    f.write(f\"Mood: {entry['mood']}/10 - {entry.get('mood_label', '')}\\n\")\n                    f.write(f\"Energy: {entry.get('energy', 'N/A')}/10\\n\\n\")\n                    f.write(f\"Prompt: {entry.get('prompt', 'No prompt')}\\n\\n\")\n                    f.write(f\"Reflection:\\n{entry['reflection']}\\n\\n\")\n\n                    if entry.get('activities'):\n                        f.write(f\"Activities: {', '.join(entry['activities'])}\\n\")\n\n                    if entry.get('tags'):\n                        f.write(f\"Tags: {', '.join(entry['tags'])}\\n\")\n\n                    f.write(\"\\n\" + \"=\" * 50 + \"\\n\\n\")\n\n            print(f\"\\nJournal exported to: {export_path}\")\n\n        elif choice == \"2\":\n            # Export as CSV\n            export_path = os.path.join(self.journal_dir, f\"journal_export_{datetime.datetime.now().strftime('%Y%m%d')}.csv\")\n\n            with open(export_path, 'w') as f:\n                # Write header\n                f.write(\"date,time,mood,energy,prompt,reflection,activities,tags\\n\")\n\n                # Write entries\n                for entry in self.entries:\n                    date = entry['date']\n                    time = entry.get('time', '')\n                    mood = entry['mood']\n                    energy = entry.get('energy', '')\n                    prompt = entry.get('prompt', '').replace('\"', '\"\"')\n                    reflection = entry['reflection'].replace('\"', '\"\"').replace('\\n', ' ')\n                    activities = \"|\".join(entry.get('activities', []))\n                    tags = \"|\".join(entry.get('tags', []))\n\n                    f.write(f'\"{date}\",\"{time}\",{mood},{energy},\"{prompt}\",\"{reflection}\",\"{activities}\",\"{tags}\"\\n')\n\n            print(f\"\\nJournal exported to: {export_path}\")\n\n        elif choice == \"3\" or choice == \"4\":\n            # Export as PDF (would require additional libraries like reportlab)\n            print(\"\\nPDF export would require additional libraries not included in this example.\")\n            print(\"In a full implementation, this would generate a formatted PDF document.\")\n\n        elif choice == \"5\":\n            self.display_menu()\n            return\n\n        else:\n            print(\"Invalid choice.\")\n\n        # Return to export menu\n        input(\"\\nPress Enter to continue...\")\n        self.export_journal()\n\n    def exit_app(self):\n        \"\"\"Exit the application\"\"\"\n        print(\"\\nThank you for using Advanced Journal Assistant. Goodbye!\")\n        exit()\n\ndef main():\n    \"\"\"Main function to run the application\"\"\"\n    journal = AdvancedJournalAssistant()\n    journal.display_menu()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"projects/advanced-journal-bot/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Data Visualization Enhancements: Add interactive visualizations using libraries like Plotly or Bokeh</li> <li>Natural Language Processing: Implement sentiment analysis to automatically detect the emotional tone of entries</li> <li>Machine Learning Integration: Build a recommendation system that suggests activities based on past mood correlations</li> <li>Multiple Journaling Modes: Add specialized templates for gratitude journaling, goal tracking, habit formation, etc.</li> <li>Social Features: Add optional sharing of insights (anonymized) with trusted friends or mentors</li> <li>Integrations: Connect with other applications like calendar, fitness trackers, or meditation apps</li> <li>Mobile Compatibility: Create a companion mobile app for on-the-go journaling</li> <li>Voice Journaling: Add speech-to-text functionality for verbal journaling</li> <li>Export Options: Enhanced export formats including PDF with embedded visualizations, interactive web formats</li> <li>Cloud Sync: Add secure cloud synchronization for access across multiple devices</li> <li>Guided Journaling Sessions: AI-guided journaling sessions focused on specific topics or goals</li> </ul>"},{"location":"projects/bot-personality-menu-generator/","title":"Bot Personality Menu Generator","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: Dictionaries, functions, menu systems</p>"},{"location":"projects/bot-personality-menu-generator/#overview","title":"Overview","text":"<p>Create a flexible menu system that allows users to interact with multiple bot personalities on demand, practicing dictionary management, function mappings, and user interface design.</p>"},{"location":"projects/bot-personality-menu-generator/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef personality_menu():\n    print(\"=== Bot Personality Menu Generator ===\")\n    print(\"Interact with various bot personalities!\")\n    print(\"Type 'exit' at any time to quit.\\n\")\n\n    # Define different bot personalities\n    def friendly_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a friendly, helpful assistant who is always positive and encouraging. You use warm language and provide supportive responses.\"\n        )\n\n    def emoji_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are an emoji enthusiast who includes multiple relevant emojis in every response. Your tone is upbeat and playful. Make sure to use at least 3-5 emojis in each message.\"\n        )\n\n    def pirate_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a salty pirate captain from the Golden Age of Piracy. You speak with pirate slang (arr, matey, avast, etc.) and make frequent references to sailing, treasure, and the sea. Your responses are brief and colorful.\"\n        )\n\n    def teacher_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a patient, knowledgeable teacher who explains concepts clearly. You break down complex ideas into simple terms and use examples to illustrate points. Your tone is educational but never condescending.\"\n        )\n\n    def detective_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a sharp-witted detective with keen analytical skills. You approach every question like a mystery to solve, looking for clues and making deductions. Your tone is contemplative and slightly dramatic, similar to classic detective novels.\"\n        )\n\n    def poet_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a lyrical poet who often speaks in verse or uses metaphorical language. Your responses are thoughtful and artistic, with attention to the rhythm and beauty of language. Occasionally include short poems in your responses.\"\n        )\n\n    # Store bot functions in a dictionary for easy access\n    bots = {\n        \"1\": {\"name\": \"Friendly Assistant\", \"function\": friendly_bot, \"description\": \"Warm and supportive\"},\n        \"2\": {\"name\": \"Emoji Enthusiast\", \"function\": emoji_bot, \"description\": \"Playful with lots of emojis\"},\n        \"3\": {\"name\": \"Pirate Captain\", \"function\": pirate_bot, \"description\": \"Salty sea dog with nautical flair\"},\n        \"4\": {\"name\": \"Wise Teacher\", \"function\": teacher_bot, \"description\": \"Patient and educational\"},\n        \"5\": {\"name\": \"Detective\", \"function\": detective_bot, \"description\": \"Analytical problem-solver\"},\n        \"6\": {\"name\": \"Poet\", \"function\": poet_bot, \"description\": \"Lyrical and metaphorical\"}\n    }\n\n    # Function to display the menu\n    def show_menu():\n        print(\"\\n=== Available Bot Personalities ===\")\n        for key, bot_info in bots.items():\n            print(f\"{key}. {bot_info['name']} - {bot_info['description']}\")\n        print(\"7. Exit\")\n\n    # Main interaction loop\n    current_bot = None\n    current_bot_name = None\n\n    while True:\n        if current_bot is None:\n            show_menu()\n            choice = input(\"\\nSelect a bot personality (1-7): \")\n\n            # Exit condition\n            if choice == \"7\" or choice.lower() == \"exit\":\n                print(\"Thanks for using the Bot Personality Menu! Goodbye!\")\n                break\n\n            if choice in bots:\n                current_bot = bots[choice][\"function\"]\n                current_bot_name = bots[choice][\"name\"]\n                print(f\"\\nYou're now chatting with the {current_bot_name}!\")\n\n                # Welcome message from the selected bot\n                welcome = current_bot(\"Give a brief introduction of yourself.\")\n                print(f\"{current_bot_name}: {welcome}\")\n            else:\n                print(\"Invalid choice. Please select a number from 1-7.\")\n                continue\n\n        # Interaction with the current bot\n        user_input = input(\"\\nYou: \")\n\n        # Check for exit or menu commands\n        if user_input.lower() == \"exit\":\n            print(\"Thanks for using the Bot Personality Menu! Goodbye!\")\n            break\n        elif user_input.lower() == \"menu\":\n            current_bot = None\n            continue\n\n        # Get response from the current bot\n        response = current_bot(user_input)\n        print(f\"\\n{current_bot_name}: {response}\")\n\n        # Option to change bots\n        print(\"\\nType 'menu' to switch bots or 'exit' to quit\")\n\n# Run the personality menu\nif __name__ == \"__main__\":\n    personality_menu()\n</code></pre>"},{"location":"projects/bot-personality-menu-generator/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Allow users to create and save their own custom bot personalities</li> <li>Add a \"random\" option that selects a personality at random</li> <li>Create a rating system where users can score responses</li> <li>Implement a \"conversation history\" feature that remembers past interactions</li> <li>Create themed conversation scenarios for different bot personalities</li> </ul>"},{"location":"projects/build-your-own-personality-bot/","title":"Build Your Own Personality Bot","text":"<p>Difficulty: Beginner Time: 30-45 minutes Learning Focus: Functions, system prompts, creative writing</p>"},{"location":"projects/build-your-own-personality-bot/#overview","title":"Overview","text":"<p>Create a new bot personality that responds in a unique way \u2014 like a movie character, animal, celebrity, or completely invented creature. Students will learn how to craft system prompts that reflect specific voices or styles.</p>"},{"location":"projects/build-your-own-personality-bot/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\n# Example bot personality\ndef cat_bot(prompt):\n    return get_response(\n        prompt, \n        system=\"You are a lazy cat who answers everything with sass, yawns, or meows.\"\n    )\n\n# Create your own unique bot personality\ndef custom_bot(prompt):\n    return get_response(\n        prompt,\n        system=\"You are a [personality type] who [describes behavior/speaking style].\"\n    )\n\n# Test your bot with different prompts\ntest_prompts = [\n    \"What's the weather like today?\",\n    \"Explain quantum physics to me.\",\n    \"What should I do this weekend?\",\n    \"Tell me a joke.\"\n]\n\n# Choose which bot to use\nmy_bot = cat_bot  # Replace with your custom bot\n\n# Test with each prompt\nfor prompt in test_prompts:\n    print(f\"User: {prompt}\")\n    print(f\"Bot: {my_bot(prompt)}\")\n    print(\"-\" * 50)\n\n# You can also create a short conversation script\nconversation = [\n    \"Hello there!\",\n    \"What's your favorite food?\",\n    \"Tell me something interesting about yourself.\",\n    \"Goodbye!\"\n]\n\nprint(\"\\n=== Conversation with Bot ===\\n\")\nfor prompt in conversation:\n    print(f\"User: {prompt}\")\n    print(f\"Bot: {my_bot(prompt)}\")\n    print()\n</code></pre>"},{"location":"projects/build-your-own-personality-bot/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Create multiple personalities and compare how they respond to the same questions</li> <li>Hold a \"bot showcase\" where students introduce their bots to the class</li> <li>Design a bot personality based on a character from literature the class is studying</li> <li>Create a bot with a specific expertise or profession (scientist, chef, historian)</li> </ul>"},{"location":"projects/choose-your-own-adventure/","title":"Choose Your Own Adventure","text":"<p>Difficulty: Intermediate Time: 60-90 minutes Learning Focus: State management, narrative design, user input handling</p>"},{"location":"projects/choose-your-own-adventure/#overview","title":"Overview","text":"<p>Create an interactive story where the bot generates narrative segments based on user choices.</p>"},{"location":"projects/choose-your-own-adventure/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef adventure_game():\n    \"\"\"Interactive Choose Your Own Adventure game powered by an LLM\"\"\"\n    # Story state tracking\n    story_context = {\n        \"setting\": \"\",\n        \"character\": \"\",\n        \"inventory\": [],\n        \"goals\": [],\n        \"events\": []\n    }\n\n    print(\"=== Choose Your Own Adventure Generator ===\")\n    print(\"Let's create your custom adventure!\\n\")\n\n    # Get initial story parameters\n    setting_options = [\"fantasy kingdom\", \"space station\", \"haunted mansion\", \n                       \"prehistoric world\", \"cyberpunk city\", \"desert island\"]\n\n    print(\"Choose a setting:\")\n    for i, setting in enumerate(setting_options):\n        print(f\"{i+1}. {setting}\")\n\n    setting_choice = int(input(\"\\nSetting (1-6): \")) - 1\n    story_context[\"setting\"] = setting_options[setting_choice]\n\n    character_type = input(\"\\nWhat type of character do you want to play? \")\n    story_context[\"character\"] = character_type\n\n    goal = input(\"\\nWhat is your character's main goal? \")\n    story_context[\"goals\"].append(goal)\n\n    # Generate story intro\n    story_prompt = f\"\"\"\n    Create the introduction to an interactive adventure story with these details:\n    - Setting: {story_context['setting']}\n    - Main character: {story_context['character']}\n    - Character's goal: {story_context['goals'][0]}\n\n    End with exactly two choices the player can make.\n    Format the choices as:\n    CHOICE 1: (first option)\n    CHOICE 2: (second option)\n    \"\"\"\n\n    story_system = \"\"\"\n    You are a creative storyteller crafting an interactive adventure.\n    Create vivid descriptions and meaningful choices.\n    For each story segment, provide exactly two choices for the player.\n    \"\"\"\n\n    # Generate and print first segment\n    current_segment = get_response(story_prompt, system=story_system)\n    print(\"\\n=== Your Adventure Begins ===\\n\")\n\n    # Split segment from choices\n    parts = current_segment.split(\"CHOICE 1:\")\n    narrative = parts[0].strip()\n    choices = \"CHOICE 1:\" + parts[1]\n\n    print(narrative + \"\\n\")\n    print(choices)\n\n    # Story loop\n    turns = 0\n    max_turns = 5\n\n    while turns &lt; max_turns:\n        choice = input(\"\\nEnter 1 or 2 to choose: \")\n\n        if choice not in [\"1\", \"2\"]:\n            print(\"Please enter 1 or 2.\")\n            continue\n\n        # Add to story context\n        if choice == \"1\":\n            chosen_option = choices.split(\"CHOICE 1:\")[1].split(\"CHOICE 2:\")[0].strip()\n        else:\n            chosen_option = choices.split(\"CHOICE 2:\")[1].strip()\n\n        story_context[\"events\"].append(chosen_option)\n\n        # Generate next segment based on choice and story so far\n        context_summary = f\"\"\"\n        Setting: {story_context['setting']}\n        Character: {story_context['character']}\n        Goal: {story_context['goals'][0]}\n        Previous events: {' '.join(story_context['events'])}\n        \"\"\"\n\n        continuation_prompt = f\"\"\"\n        Continue the story based on these details:\n        {context_summary}\n\n        The player just chose: {chosen_option}\n\n        Continue the story from there and provide two new choices.\n        End with:\n        CHOICE 1: (first option)\n        CHOICE 2: (second option)\n        \"\"\"\n\n        # Generate next segment\n        next_segment = get_response(continuation_prompt, system=story_system)\n        print(\"\\n\" + \"=\"*50 + \"\\n\")\n\n        # Split segment from choices\n        parts = next_segment.split(\"CHOICE 1:\")\n        narrative = parts[0].strip()\n\n        # Check if we've reached the ending\n        if \"CHOICE 1:\" not in next_segment:\n            print(next_segment)\n            print(\"\\n=== The End ===\")\n            break\n\n        choices = \"CHOICE 1:\" + parts[1]\n\n        print(narrative + \"\\n\")\n        print(choices)\n\n        turns += 1\n\n        # Final turn\n        if turns &gt;= max_turns:\n            # Generate conclusion\n            conclusion_prompt = f\"\"\"\n            Create a satisfying conclusion to the story based on these details:\n            {context_summary}\n\n            The player just chose: {chosen_option}\n\n            Write a final paragraph that wraps up the adventure.\n            \"\"\"\n\n            conclusion = get_response(conclusion_prompt, system=story_system)\n\n            print(\"\\n\" + \"=\"*50 + \"\\n\")\n            print(conclusion)\n            print(\"\\n=== The End ===\")\n\n    print(\"\\nThanks for playing!\")\n\n# Run the adventure game\nif __name__ == \"__main__\":\n    adventure_game()\n</code></pre>"},{"location":"projects/choose-your-own-adventure/#extension-ideas","title":"Extension Ideas","text":"<p>Add inventory management, character stats, or multiple endings based on decisions.</p>"},{"location":"projects/classroom-simulation-bot/","title":"Classroom Simulation Bot","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: Functions, menu systems, multiple bot use</p>"},{"location":"projects/classroom-simulation-bot/#overview","title":"Overview","text":"<p>Create a classroom simulation where students can interact with different characters or experts on various topics, practicing both coding skills and exploring different perspectives.</p>"},{"location":"projects/classroom-simulation-bot/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef classroom_simulation():\n    print(\"=== Virtual Classroom Simulation ===\")\n    print(\"Ask questions to different characters about any topic!\")\n    print(\"Type 'exit' at any time to quit.\\n\")\n\n    # Define different bot personalities\n    def teacher_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a knowledgeable, patient teacher who explains concepts clearly with examples. You encourage critical thinking and use analogies to simplify complex ideas. Keep explanations concise but thorough.\"\n        )\n\n    def hacker_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are an ethical hacker with expertise in cybersecurity. You explain technical concepts with a slightly rebellious attitude but always emphasize ethical practices and security. Never provide instructions for illegal activities. Use technical terminology but explain it.\"\n        )\n\n    def pirate_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a pirate captain from the Golden Age of Piracy. You speak with pirate slang and terminology (arr, matey, etc.). Despite your rough manner, you're surprisingly knowledgeable about navigation, history, and seafaring. Keep responses brief and entertaining.\"\n        )\n\n    def scientist_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a brilliant scientist who is excited about all fields of science. You explain scientific concepts with enthusiasm and wonder, citing relevant research and discoveries. You are factual and precise but can make complex ideas accessible.\"\n        )\n\n    # Display available characters\n    def show_menu():\n        print(\"\\n=== Available Characters ===\")\n        print(\"1. Teacher - Clear explanations and educational guidance\")\n        print(\"2. Hacker - Cybersecurity and tech knowledge with attitude\")\n        print(\"3. Pirate - Nautical expertise with a swashbuckling style\")\n        print(\"4. Scientist - Enthusiastic scientific explanations\")\n        print(\"5. Exit simulation\")\n\n    # Main interaction loop\n    while True:\n        show_menu()\n        choice = input(\"\\nChoose a character (1-5): \")\n\n        # Exit condition\n        if choice == \"5\" or choice.lower() == \"exit\":\n            print(\"Exiting the classroom simulation. Thanks for participating!\")\n            break\n\n        # Select the appropriate bot based on user choice\n        if choice == \"1\":\n            bot = teacher_bot\n            name = \"Teacher\"\n        elif choice == \"2\":\n            bot = hacker_bot\n            name = \"Hacker\"\n        elif choice == \"3\":\n            bot = pirate_bot\n            name = \"Pirate Captain\"\n        elif choice == \"4\":\n            bot = scientist_bot\n            name = \"Scientist\"\n        else:\n            print(\"Invalid choice. Please enter a number from 1-5.\")\n            continue\n\n        # Get the question from the user\n        question = input(f\"\\nWhat would you like to ask the {name}? \")\n\n        # Exit condition\n        if question.lower() == \"exit\":\n            print(\"Exiting the classroom simulation. Thanks for participating!\")\n            break\n\n        # Get the response from the selected bot\n        print(f\"\\n{name}:\")\n        response = bot(question)\n        print(response)\n\n        # Ask if they want to ask another question to the same character\n        while True:\n            another = input(f\"\\nWould you like to ask the {name} another question? (yes/no): \").lower()\n\n            if another == \"no\" or another == \"exit\":\n                break\n            elif another == \"yes\":\n                question = input(f\"\\nWhat's your next question for the {name}? \")\n\n                # Exit condition\n                if question.lower() == \"exit\":\n                    print(\"Exiting the classroom simulation. Thanks for participating!\")\n                    return\n\n                print(f\"\\n{name}:\")\n                response = bot(question)\n                print(response)\n            else:\n                print(\"Please answer 'yes' or 'no'.\")\n\n# Run the classroom simulation\nif __name__ == \"__main__\":\n    classroom_simulation()\n</code></pre>"},{"location":"projects/classroom-simulation-bot/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add more character types like historian, artist, or fictional character</li> <li>Create a debate mode where two characters discuss the same topic</li> <li>Add a quiz feature where characters test the user's knowledge</li> <li>Create a storyline or scenario that involves multiple characters</li> <li>Allow characters to \"remember\" previous interactions in the session</li> </ul>"},{"location":"projects/code-explainer-tool/","title":"Code Explainer Tool","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: Code analysis, documentation</p>"},{"location":"projects/code-explainer-tool/#overview","title":"Overview","text":"<p>Create a tool that explains code snippets and helps users understand programming concepts.</p>"},{"location":"projects/code-explainer-tool/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport sys\n\ndef code_explainer():\n    \"\"\"Tool to explain code and help with programming concepts\"\"\"\n    print(\"=== Code Explainer Tool ===\")\n    print(\"1. Explain a code snippet\")\n    print(\"2. Simplify complex code\")\n    print(\"3. Debug problematic code\")\n    print(\"4. Learn a programming concept\")\n\n    choice = input(\"\\nWhat would you like to do? \")\n\n    if choice == \"1\":\n        # Explain code\n        print(\"\\nPaste your code snippet below (type 'DONE' on a new line when finished):\")\n        code_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            code_lines.append(line)\n\n        code = \"\\n\".join(code_lines)\n\n        detail_level = input(\"\\nExplanation detail (brief/detailed/step-by-step): \")\n        audience = input(\"Target audience (beginner/intermediate/advanced): \")\n\n        system_prompt = f\"\"\"\n        You are an expert programming tutor specializing in code explanation.\n        You break down code in a way that's understandable to {audience} programmers.\n        You provide {detail_level} explanations that help users truly understand the code.\n        \"\"\"\n\n        explain_prompt = f\"\"\"\n        Explain this code:\n        ```\n        {code}\n        ```\n\n        Provide a {detail_level} explanation suitable for a {audience} programmer.\n        If possible, identify:\n        1. The programming language\n        2. What the code does\n        3. Key concepts it demonstrates\n        4. Any potential issues or improvements\n        \"\"\"\n\n        print(\"\\nAnalyzing code...\")\n        explanation = get_response(explain_prompt, system=system_prompt)\n\n        print(\"\\n=== Code Explanation ===\")\n        print(explanation)\n\n    elif choice == \"2\":\n        # Simplify complex code\n        print(\"\\nPaste the complex code below (type 'DONE' on a new line when finished):\")\n        code_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            code_lines.append(line)\n\n        code = \"\\n\".join(code_lines)\n\n        system_prompt = \"\"\"\n        You are an expert in code refactoring and simplification.\n        You take complex code and make it more readable while preserving functionality.\n        You explain your changes clearly so the user understands the improvements.\n        \"\"\"\n\n        simplify_prompt = f\"\"\"\n        Simplify this code to make it more readable and maintainable:\n        ```\n        {code}\n        ```\n\n        Provide:\n        1. A simplified version of the code\n        2. An explanation of what changes you made and why\n        3. How the simplified version improves upon the original\n        \"\"\"\n\n        print(\"\\nSimplifying code...\")\n        simplified = get_response(simplify_prompt, system=system_prompt)\n\n        print(\"\\n=== Simplified Code ===\")\n        print(simplified)\n\n    elif choice == \"3\":\n        # Debug code\n        print(\"\\nPaste the problematic code below (type 'DONE' on a new line when finished):\")\n        code_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            code_lines.append(line)\n\n        code = \"\\n\".join(code_lines)\n\n        error = input(\"\\nDescribe any error messages you're seeing: \")\n        expected = input(\"What did you expect the code to do? \")\n\n        system_prompt = \"\"\"\n        You are an expert debugging assistant who helps find and fix code issues.\n        You are an expert debugging assistant who helps find and fix code issues.\n        You carefully analyze code to identify bugs, logic errors, and other problems.\n        You explain issues clearly and provide working solutions.\n        \"\"\"\n\n        debug_prompt = f\"\"\"\n        Debug this code:\n        ```\n        {code}\n        ```\n\n        Error information: {error}\n        Expected behavior: {expected}\n\n        Provide:\n        1. Identification of the likely issue(s)\n        2. An explanation of what's causing the problem\n        3. A corrected version of the code\n        4. Testing suggestions to verify the fix\n        \"\"\"\n\n        print(\"\\nDebugging code...\")\n        debug_info = get_response(debug_prompt, system=system_prompt)\n\n        print(\"\\n=== Debugging Results ===\")\n        print(debug_info)\n\n    elif choice == \"4\":\n        # Learn programming concept\n        concept = input(\"\\nWhat programming concept would you like to learn about? \")\n        language = input(\"For which programming language? \")\n\n        system_prompt = \"\"\"\n        You are a programming educator who excels at explaining technical concepts clearly.\n        You use examples and analogies to make abstract ideas concrete and understandable.\n        You provide practical code examples to illustrate concepts.\n        \"\"\"\n\n        learn_prompt = f\"\"\"\n        Explain the programming concept of {concept} in {language}.\n\n        Include:\n        1. A clear definition of the concept\n        2. Why it's important and when to use it\n        3. At least 2 practical code examples in {language}\n        4. Common pitfalls or misconceptions\n        5. Best practices when using this concept\n        \"\"\"\n\n        print(f\"\\nResearching {concept} in {language}...\")\n        concept_explanation = get_response(learn_prompt, system=system_prompt)\n\n        print(f\"\\n=== {concept.title()} in {language.title()} ===\")\n        print(concept_explanation)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the code explainer\nif __name__ == \"__main__\":\n    code_explainer()\n</code></pre>"},{"location":"projects/code-explainer-tool/#extension-ideas","title":"Extension Ideas","text":"<p>Add functionality to generate test cases or convert code between languages.</p>"},{"location":"projects/creative-writing-partner/","title":"Creative Writing Partner","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: Narrative development, creative collaboration, editing</p>"},{"location":"projects/creative-writing-partner/#overview","title":"Overview","text":"<p>A collaborative writing tool that helps students develop stories, poems, or essays.</p>"},{"location":"projects/creative-writing-partner/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef writing_partner():\n    \"\"\"Interactive creative writing assistant\"\"\"\n    print(\"=== Creative Writing Partner ===\")\n    print(\"1. Story development\")\n    print(\"2. Poetry assistant\")\n    print(\"3. Essay outliner\")\n    print(\"4. Character creator\")\n    print(\"5. Writing feedback\")\n\n    choice = input(\"\\nWhat would you like to do? \")\n\n    if choice == \"1\":\n        # Story development\n        print(\"\\n=== Story Development ===\")\n        genre = input(\"What genre is your story? \")\n        premise = input(\"What's the basic premise or idea? \")\n\n        system_prompt = \"\"\"\n        You are a creative writing coach who helps develop stories.\n        You ask thoughtful questions, offer suggestions, and help organize ideas.\n        You're supportive and encouraging while providing constructive guidance.\n        \"\"\"\n\n        story_prompt = f\"\"\"\n        Help the user develop a {genre} story with this premise:\n        \"{premise}\"\n\n        Provide:\n        1. Three potential directions the story could take\n        2. Key elements that would make this story engaging\n        3. Suggestions for main characters and their motivations\n        4. A potential outline for the beginning, middle, and end\n        5. Questions that would help the user further develop their idea\n        \"\"\"\n\n        print(\"\\nDeveloping story ideas...\")\n        story_ideas = get_response(story_prompt, system=system_prompt)\n\n        print(\"\\n\" + story_ideas)\n\n        # Follow-up questions\n        print(\"\\nWould you like help with a specific aspect of your story?\")\n        print(\"1. Develop a character\")\n        print(\"2. Create a setting\")\n        print(\"3. Generate a plot twist\")\n        print(\"4. Write an opening paragraph\")\n\n        follow_up = input(\"\\nChoose an option (1-4): \")\n\n        if follow_up == \"1\":\n            character_type = input(\"\\nWhat type of character (protagonist, villain, sidekick, etc.)? \")\n\n            character_prompt = f\"\"\"\n            Help create a compelling {character_type} for a {genre} story with this premise:\n            \"{premise}\"\n\n            Develop:\n            1. Name and brief physical description\n            2. Background/history\n            3. Personality traits and quirks\n            4. Motivations and goals\n            5. Internal and external conflicts\n            \"\"\"\n\n            character = get_response(character_prompt, system=system_prompt)\n            print(\"\\n=== Character Profile ===\")\n            print(character)\n\n        elif follow_up == \"2\":\n            setting_type = input(\"\\nWhat type of setting (time period, location, etc.)? \")\n\n            setting_prompt = f\"\"\"\n            Create a vivid setting for a {genre} story with this premise:\n            \"{premise}\"\n\n            The setting is: {setting_type}\n\n            Include:\n            1. Detailed sensory descriptions (sights, sounds, smells)\n            2. Unique features of this world/place\n            3. How the setting influences the story\n            4. Potential conflicts arising from the setting\n            \"\"\"\n\n            setting = get_response(setting_prompt, system=system_prompt)\n            print(\"\\n=== Setting Description ===\")\n            print(setting)\n\n        elif follow_up == \"3\":\n            twist_prompt = f\"\"\"\n            Generate three potential plot twists for a {genre} story with this premise:\n            \"{premise}\"\n\n            For each twist, explain:\n            1. What the twist is\n            2. When it might occur in the story\n            3. How it would change the direction of the narrative\n            4. Why it would be surprising but still logical within the story\n            \"\"\"\n\n            twists = get_response(twist_prompt, system=system_prompt)\n            print(\"\\n=== Plot Twist Ideas ===\")\n            print(twists)\n\n        elif follow_up == \"4\":\n            style = input(\"\\nDescribe the writing style you'd like to use: \")\n\n            opening_prompt = f\"\"\"\n            Write an engaging opening paragraph for a {genre} story with this premise:\n            \"{premise}\"\n\n            Using this writing style: {style}\n\n            The opening should:\n            1. Hook the reader's attention\n            2. Establish tone and atmosphere\n            3. Introduce either a character, setting, or conflict\n            4. Hint at the larger story to come\n            \"\"\"\n\n            opening = get_response(opening_prompt, system=system_prompt)\n            print(\"\\n=== Opening Paragraph ===\")\n            print(opening)\n\n    elif choice == \"2\":\n        # Poetry assistant\n        print(\"\\n=== Poetry Assistant ===\")\n        poetry_type = input(\"What type of poem (sonnet, haiku, free verse, etc.)? \")\n        theme = input(\"What theme or topic for your poem? \")\n\n        system_prompt = \"\"\"\n        You are a poetry writing coach who helps develop beautiful, meaningful poems.\n        You provide guidance on form, structure, language, and imagery.\n        You're artistic and thoughtful while remaining accessible and supportive.\n        \"\"\"\n\n        poetry_prompt = f\"\"\"\n        Help the user write a {poetry_type} about {theme}.\n\n        Provide:\n        1. A brief explanation of the {poetry_type} form and its characteristics\n        2. Suggested imagery, metaphors, or symbols related to {theme}\n        3. A list of evocative words related to the theme\n        4. An example first stanza or line to get started\n        5. Tips for writing effectively in this form\n        \"\"\"\n\n        print(\"\\nGenerating poetry guidance...\")\n        poetry_guidance = get_response(poetry_prompt, system=system_prompt)\n\n        print(\"\\n\" + poetry_guidance)\n\n        # User writes poem\n        print(\"\\nWrite your poem below (type 'DONE' on a new line when finished):\")\n        poem_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            poem_lines.append(line)\n\n        poem = \"\\n\".join(poem_lines)\n\n        # Feedback on poem\n        feedback_prompt = f\"\"\"\n        The user has written this {poetry_type} about {theme}:\n\n        {poem}\n\n        Provide constructive, supportive feedback, including:\n        1. What works well in the poem\n        2. Suggestions for strengthening imagery or language\n        3. Ideas for revision if appropriate\n        4. One or two specific lines that could be enhanced, with suggestions\n        \"\"\"\n\n        print(\"\\nAnalyzing your poem...\")\n        feedback = get_response(feedback_prompt, system=system_prompt)\n\n        print(\"\\n=== Poetry Feedback ===\")\n        print(feedback)\n\n    elif choice == \"3\":\n        # Essay outliner\n        print(\"\\n=== Essay Outliner ===\")\n        essay_type = input(\"What type of essay (argumentative, expository, etc.)? \")\n        topic = input(\"What's your essay topic? \")\n\n        system_prompt = \"\"\"\n        You are an academic writing coach who helps develop well-structured essays.\n        You help organize ideas, develop arguments, and create coherent outlines.\n        You provide guidance on thesis statements, evidence, and logical flow.\n        \"\"\"\n\n        essay_prompt = f\"\"\"\n        Help the user outline a {essay_type} essay on the topic:\n        \"{topic}\"\n\n        Provide:\n        1. Potential thesis statements or research questions\n        2. A suggested structure with main sections\n        3. Key points to cover in each section\n        4. Types of evidence or examples that could support each point\n        5. Ideas for a strong introduction and conclusion\n        \"\"\"\n\n        print(\"\\nDeveloping essay outline...\")\n        essay_outline = get_response(essay_prompt, system=system_prompt)\n\n        print(\"\\n\" + essay_outline)\n\n        # Thesis refinement\n        thesis = input(\"\\nBased on these suggestions, write your thesis statement: \")\n\n        refine_prompt = f\"\"\"\n        Analyze this thesis statement for a {essay_type} essay on {topic}:\n\n        \"{thesis}\"\n\n        Provide feedback on:\n        1. Clarity and specificity\n        2. Arguability (is it something that could be supported/contested?)\n        3. Scope (is it appropriately focused for an essay?)\n        4. Suggested revisions if needed\n        \"\"\"\n\n        print(\"\\nAnalyzing thesis statement...\")\n        thesis_feedback = get_response(refine_prompt, system=system_prompt)\n\n        print(\"\\n=== Thesis Feedback ===\")\n        print(thesis_feedback)\n\n    elif choice == \"4\":\n        # Character creator\n        print(\"\\n=== Character Creator ===\")\n        role = input(\"What role will this character play (protagonist, villain, etc.)? \")\n        story_type = input(\"What type of story is this character for? \")\n\n        system_prompt = \"\"\"\n        You are a character development coach who helps create deep, nuanced characters.\n        You ask insightful questions and provide suggestions for well-rounded character creation.\n        You focus on psychology, motivation, and authentic human behavior.\n        \"\"\"\n\n        character_prompt = f\"\"\"\n        Help the user create a compelling {role} for a {story_type}.\n\n        Provide:\n        1. Questions to consider about the character's background\n        2. Suggestions for interesting personality traits and quirks\n        3. Ideas for internal and external conflicts\n        4. Potential character arcs or growth journeys\n        5. Tips for making the character authentic and three-dimensional\n        \"\"\"\n\n        print(\"\\nGenerating character development ideas...\")\n        character_ideas = get_response(character_prompt, system=system_prompt)\n\n        print(\"\\n\" + character_ideas)\n\n        # Character profile\n        print(\"\\nBased on these ideas, let's create a character profile.\")\n        name = input(\"Character name: \")\n        traits = input(\"Three key personality traits: \")\n        background = input(\"Brief background: \")\n        goal = input(\"Main goal or motivation: \")\n\n        profile_prompt = f\"\"\"\n        Develop a complete character profile for {name}, a {role} in a {story_type}.\n\n        Use this information:\n        - Key traits: {traits}\n        - Background: {background}\n        - Goal/motivation: {goal}\n\n        Create a comprehensive profile including:\n        1. Physical description and appearance\n        2. Detailed personality analysis\n        3. Relationships with other potential characters\n        4. Internal contradictions or complexities\n        5. How they might respond in various situations\n        6. Character arc - how they might change throughout the story\n        \"\"\"\n\n        print(\"\\nCreating detailed character profile...\")\n        profile = get_response(profile_prompt, system=system_prompt)\n\n        print(\"\\n=== Character Profile: \" + name + \" ===\")\n        print(profile)\n\n    elif choice == \"5\":\n        # Writing feedback\n        print(\"\\n=== Writing Feedback ===\")\n        writing_type = input(\"What type of writing (story, poem, essay, etc.)? \")\n\n        print(\"\\nPaste your writing below (type 'DONE' on a new line when finished):\")\n        writing_lines = []\n        while True:\n            line = input()\n            if line == \"DONE\":\n                break\n            writing_lines.append(line)\n\n        writing = \"\\n\".join(writing_lines)\n\n        focus_areas = input(\"\\nWhat aspects would you like feedback on (e.g., structure, characters, language)? \")\n\n        system_prompt = \"\"\"\n        You are a supportive writing coach who provides constructive feedback.\n        You balance positive observations with suggestions for improvement.\n        You're specific, actionable, and encouraging in your feedback.\n        \"\"\"\n\n        feedback_prompt = f\"\"\"\n        Provide constructive feedback on this {writing_type}:\n\n        {writing}\n\n        Focus on these areas: {focus_areas}\n\n        Include in your feedback:\n        1. Overall impression and strengths\n        2. Specific suggestions for improvement in the requested areas\n        3. Examples from the text with suggested revisions\n        4. Next steps for revision\n\n        Be supportive and constructive while providing honest feedback.\n        \"\"\"\n\n        print(\"\\nAnalyzing your writing...\")\n        feedback = get_response(feedback_prompt, system=system_prompt)\n\n        print(\"\\n=== Writing Feedback ===\")\n        print(feedback)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the writing partner\nif __name__ == \"__main__\":\n    writing_partner()\n</code></pre>"},{"location":"projects/creative-writing-partner/#extension-ideas","title":"Extension Ideas","text":"<p>Add a collaborative storytelling mode where student and bot take turns adding to a story.</p>"},{"location":"projects/creative-writing-partner/#implementation-tips","title":"Implementation Tips","text":"<p>When using these mini-projects in a classroom setting:</p> <ol> <li>Scaffold appropriately: Start with simpler projects for beginners, then progress to more complex ones.</li> <li>Modify complexity: Adjust project requirements based on student skill level and available time.</li> <li>Pair programming: Have students work in pairs to encourage collaboration.</li> <li>Challenge extensions: Provide additional challenges for students who finish early.</li> <li>Focus on concepts: Emphasize the programming concepts being used rather than just creating a functioning bot.</li> <li>Ethical discussions: Use these projects as opportunities to discuss AI ethics, bias, and limitations.</li> </ol>"},{"location":"projects/creative-writing-partner/#assessment-ideas","title":"Assessment Ideas","text":"<ul> <li>Have students document their process in a digital portfolio</li> <li>Create a \"bot showcase\" where students present their creations</li> <li>Ask students to write reflections on what they learned</li> <li>Evaluate code structure, comments, and organization</li> <li>Have students peer-review each other's projects</li> </ul> <p>These examples are designed to be flexible starting points. Adjust and expand them to suit your specific educational needs and student skill levels.</p>"},{"location":"projects/data-visualization-dashboard/","title":"Data Visualization Dashboard","text":"<p>Difficulty: Intermediate Time: 60-90 minutes Learning Focus: Data analysis, visualization, pandas, matplotlib</p>"},{"location":"projects/data-visualization-dashboard/#overview","title":"Overview","text":"<p>Create an interactive dashboard that allows users to visualize and explore data relationships through various chart types. Students will learn data manipulation with pandas and visualization with matplotlib.</p>"},{"location":"projects/data-visualization-dashboard/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom io import BytesIO\nimport base64\nimport random\nimport os\nimport numpy as np\n\ndef data_dashboard():\n    \"\"\"Interactive data visualization dashboard for exploring datasets\"\"\"\n\n    # Sample dataset (students could replace with their own CSV)\n    sample_data = {\n        'Month': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        'Temperature': [12, 14, 16, 19, 22, 25, 27, 26, 23, 19, 15, 13],\n        'Rainfall': [50, 45, 35, 30, 25, 15, 10, 12, 20, 35, 40, 48],\n        'Visitors': [120, 135, 190, 240, 310, 430, 590, 560, 420, 320, 190, 150]\n    }\n\n    # Create a DataFrame from the sample data\n    df = pd.DataFrame(sample_data)\n\n    print(\"=== Data Visualization Dashboard ===\")\n    print(\"This dashboard allows you to explore relationships in data.\")\n\n    # Create directory for plots if it doesn't exist\n    plots_dir = \"dashboard_plots\"\n    os.makedirs(plots_dir, exist_ok=True)\n\n    while True:\n        print(\"\\nOptions:\")\n        print(\"1. View data summary\")\n        print(\"2. Line chart\")\n        print(\"3. Bar chart\")\n        print(\"4. Scatter plot\")\n        print(\"5. Get AI insights\")\n        print(\"6. Exit\")\n\n        choice = input(\"\\nSelect an option (1-6): \")\n\n        if choice == '1':\n            # Data summary\n            print(\"\\n=== Data Summary ===\")\n            print(f\"Dataset shape: {df.shape[0]} rows, {df.shape[1]} columns\")\n            print(\"\\nColumns:\")\n            for column in df.columns:\n                print(f\"- {column}\")\n\n            print(\"\\nSummary statistics:\")\n            print(df.describe())\n\n            print(\"\\nFirst few rows:\")\n            print(df.head())\n\n        elif choice == '2':\n            # Line chart\n            print(\"\\n=== Line Chart ===\")\n            print(\"Available columns:\")\n            for i, column in enumerate(df.columns[1:], 1):  # Skip 'Month' column\n                print(f\"{i}. {column}\")\n\n            column_idx = int(input(\"\\nSelect column to plot (1-3): \")) - 1\n            column_to_plot = df.columns[column_idx + 1]  # +1 to account for skipping 'Month'\n\n            plt.figure(figsize=(10, 6))\n            plt.plot(df['Month'], df[column_to_plot], marker='o', linewidth=2)\n            plt.title(f'{column_to_plot} by Month')\n            plt.xlabel('Month')\n            plt.ylabel(column_to_plot)\n            plt.grid(True, linestyle='--', alpha=0.7)\n\n            # Save plot to file\n            plot_filename = os.path.join(plots_dir, f\"line_{column_to_plot.lower()}.png\")\n            plt.savefig(plot_filename)\n            plt.close()\n\n            print(f\"\\nLine chart created and saved as {plot_filename}\")\n\n        elif choice == '3':\n            # Bar chart\n            print(\"\\n=== Bar Chart ===\")\n            print(\"Available columns:\")\n            for i, column in enumerate(df.columns[1:], 1):  # Skip 'Month' column\n                print(f\"{i}. {column}\")\n\n            column_idx = int(input(\"\\nSelect column to plot (1-3): \")) - 1\n            column_to_plot = df.columns[column_idx + 1]  # +1 to account for skipping 'Month'\n\n            plt.figure(figsize=(10, 6))\n            plt.bar(df['Month'], df[column_to_plot], color='skyblue', edgecolor='navy')\n            plt.title(f'{column_to_plot} by Month')\n            plt.xlabel('Month')\n            plt.ylabel(column_to_plot)\n            plt.grid(True, axis='y', linestyle='--', alpha=0.7)\n\n            # Save plot to file\n            plot_filename = os.path.join(plots_dir, f\"bar_{column_to_plot.lower()}.png\")\n            plt.savefig(plot_filename)\n            plt.close()\n\n            print(f\"\\nBar chart created and saved as {plot_filename}\")\n\n        elif choice == '4':\n            # Scatter plot\n            print(\"\\n=== Scatter Plot ===\")\n            print(\"Available columns for X-axis:\")\n            for i, column in enumerate(df.columns[1:], 1):  # Skip 'Month' column\n                print(f\"{i}. {column}\")\n\n            x_idx = int(input(\"\\nSelect X-axis column (1-3): \")) - 1\n            x_column = df.columns[x_idx + 1]  # +1 to account for skipping 'Month'\n\n            print(\"\\nAvailable columns for Y-axis:\")\n            for i, column in enumerate(df.columns[1:], 1):  # Skip 'Month' column\n                if column != x_column:  # Don't show the X column again\n                    print(f\"{i}. {column}\")\n\n            y_idx = int(input(\"\\nSelect Y-axis column (1-3): \")) - 1\n            y_column = df.columns[y_idx + 1]  # +1 to account for skipping 'Month'\n\n            plt.figure(figsize=(10, 6))\n            plt.scatter(df[x_column], df[y_column], color='purple', alpha=0.7, s=100)\n\n            # Add month labels to each point\n            for i, month in enumerate(df['Month']):\n                plt.annotate(month, (df[x_column][i], df[y_column][i]), \n                             xytext=(5, 5), textcoords='offset points')\n\n            plt.title(f'{y_column} vs {x_column}')\n            plt.xlabel(x_column)\n            plt.ylabel(y_column)\n            plt.grid(True, linestyle='--', alpha=0.7)\n\n            # Optional: Add trendline\n            plt.plot(np.unique(df[x_column]), \n                     np.poly1d(np.polyfit(df[x_column], df[y_column], 1))(np.unique(df[x_column])),\n                     color='red', linestyle='--', alpha=0.7)\n\n            # Save plot to file\n            plot_filename = os.path.join(plots_dir, f\"scatter_{x_column.lower()}_{y_column.lower()}.png\")\n            plt.savefig(plot_filename)\n            plt.close()\n\n            print(f\"\\nScatter plot created and saved as {plot_filename}\")\n\n        elif choice == '5':\n            # AI insights\n            print(\"\\n=== AI Data Insights ===\")\n\n            try:\n                # Prepare data summary for AI\n                data_description = f\"\"\"\n                Dataset with columns: {', '.join(df.columns)}\n                Summary statistics:\n                {df.describe().to_string()}\n\n                First few rows:\n                {df.head().to_string()}\n                \"\"\"\n\n                insight_prompt = f\"\"\"\n                Analyze this dataset and provide 3-5 key insights:\n                {data_description}\n\n                Focus on:\n                1. Patterns or trends over months\n                2. Correlations between variables\n                3. Anomalies or interesting data points\n                4. Suggestions for further analysis\n                \"\"\"\n\n                print(\"Generating AI insights...\")\n                insights = get_response(insight_prompt)\n\n                print(\"\\n=== AI Analysis Results ===\")\n                print(insights)\n\n            except Exception as e:\n                print(f\"Error getting AI insights: {e}\")\n                print(\"AI insight generation is not available.\")\n\n        elif choice == '6':\n            print(\"\\nExiting Dashboard. Goodbye!\")\n            break\n\n        else:\n            print(\"\\nInvalid choice. Please select a number between 1 and 6.\")\n\n# Run the dashboard\nif __name__ == \"__main__\":\n    data_dashboard()\n</code></pre>"},{"location":"projects/data-visualization-dashboard/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add more visualization types like pie charts, histograms, or heatmaps</li> <li>Implement data filtering options to explore subsets of the data</li> <li>Add the ability to load CSV files from disk</li> <li>Create a feature to export all visualizations as a report</li> <li>Implement interactive plots using libraries like Plotly</li> <li>Add clustering or other basic data analysis techniques</li> </ul>"},{"location":"projects/debate-interview-panel-dialogue-simulator/","title":"AI Persona Dialogue Simulator","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: Function calls, lists, creativity, dialogue simulation</p>"},{"location":"projects/debate-interview-panel-dialogue-simulator/#overview","title":"Overview","text":"<p>Simulate interactive dialogues between multiple AI personas with different personalities or perspectives. This flexible tool enables both multi-participant panel discussions and focused one-on-one debates, allowing students to explore how different characters approach the same topics. The simulator can also be configured to run simulated interviews by selecting appropriate personas and question formats.</p> <p>Simulate an interview or debate between multiple bots with different personalities or perspectives, exploring how different characters might approach the same questions or topics.</p> <p>This project offers flexibility to run either panel discussions with multiple participants or focused one-on-one debates, allowing students to explore how different personas respond to the same topics.</p>"},{"location":"projects/debate-interview-panel-dialogue-simulator/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport time\n\ndef ai_persona_dialogue_simulator():\n    \"\"\"\n    Simulate a dialogue between multiple AI personas with different personalities,\n    exploring how different characters approach the same questions or topics.\n\n    This tool supports multiple dialogue formats:\n    1. Panel discussion - Multiple personas exchange views with less structure\n    2. Formal debate - Two personas engage in structured argument with multiple rounds\n    3. Interview - One persona can be set as an \"interviewer\" asking questions \n       of other personas serving as \"interviewees\"\n    \"\"\"\n    print(\"=== AI Persona Dialogue Simulator ===\")\n\n    # Define different bot personalities\n    # Each personality has a unique perspective that influences how they respond\n    bot_personalities = {\n        \"Professor\": \"You are a logical, analytical professor who values facts, research, and intellectual rigor. You speak formally and cite evidence for your claims. You believe in rational inquiry and skepticism.\",\n        \"Coach\": \"You are an inspirational coach who focuses on motivation, emotional intelligence, and personal growth. You believe in the power of passion, intuition, and human potential. You speak with enthusiasm and use motivational language.\",\n        \"Artist\": \"You are a creative artist who values beauty, expression, and innovation. You think metaphorically and appreciate the abstract and subjective. You believe in breaking rules to create something new. Your language is colorful and expressive.\",\n        \"Entrepreneur\": \"You are a practical entrepreneur focused on results, efficiency, and real-world applications. You value solutions that work and ideas that can be implemented. You speak directly and focus on action.\",\n        \"Dr. Logic\": \"You value logical reasoning and empirical evidence above all. You cite studies and statistics to support your points. You believe decisions should be made based on data, not emotions.\",\n        \"Empathetic Emma\": \"You believe emotional impact and human stories are most important. You consider how policies and ideas affect real people. You speak with compassion and emphasize the human element in every issue.\",\n        \"Traditional Tom\": \"You value tradition, stability, and time-tested approaches. You're skeptical of rapid change and new untested ideas. You believe in preserving what works and making careful, incremental improvements.\",\n        \"Interviewer\": \"You are a professional interviewer who asks insightful, probing questions. You're curious and neutral, aiming to bring out the most interesting perspectives from others. You follow up with clarifying questions when needed.\"\n    }\n\n    # List of debate/discussion topics\n    # These can be used for debates, panel discussions, or interview topics\n    dialogue_topics = [\n        \"What's more important: creativity or logic?\",\n        \"Is technology improving or harming society?\",\n        \"Should education focus more on facts or skills?\",\n        \"Is it better to be a specialist or a generalist?\",\n        \"Are humans naturally cooperative or competitive?\",\n        \"What's the best way to measure success in life?\",\n        \"Should we prioritize individual freedom or collective welfare?\",\n        \"Is artificial intelligence more likely to help or harm humanity?\",\n        \"Should governments regulate social media platforms?\"\n    ]\n\n    # Let user select a dialogue topic\n    # TODO: Add input validation to handle non-integer inputs\n    print(\"Choose a topic:\")\n    for i, question in enumerate(dialogue_topics, 1):\n        print(f\"{i}. {question}\")\n    print(f\"{len(dialogue_topics) + 1}. Custom topic (enter your own)\")\n\n    # Input validation could be added here to handle non-integer inputs\n    try:\n        choice = int(input(\"\\nEnter topic number: \"))\n        if choice &lt;= 0 or choice &gt; len(dialogue_topics) + 1:\n            print(\"Invalid choice. Using default topic #1.\")\n            choice = 1\n    except ValueError:\n        print(\"Invalid input. Using default topic #1.\")\n        choice = 1\n\n    if choice &lt;= len(dialogue_topics):\n        dialogue_topic = dialogue_topics[choice - 1]\n    else:\n        dialogue_topic = input(\"\\nEnter your custom topic: \")\n\n    # Choose dialogue format\n    # The format affects how the personas interact with each other\n    print(\"\\nChoose dialogue format:\")\n    print(\"1. Panel discussion (multiple personas participate in an open exchange)\")\n    print(\"2. One-on-one debate (two personas engage in structured argument)\")\n    print(\"3. Interview (one persona interviews the others)\")\n\n    # TODO: Add input validation for format choice\n    try:\n        format_choice = int(input(\"\\nEnter format number (1-3): \"))\n        if format_choice &lt; 1 or format_choice &gt; 3:\n            print(\"Invalid format. Using panel discussion (1).\")\n            format_choice = 1\n    except ValueError:\n        print(\"Invalid input. Using panel discussion (1).\")\n        format_choice = 1\n\n    # Select personas based on format\n    if format_choice == 1:\n        # Panel discussion - let user select multiple participants\n        # This mode simulates a roundtable where each persona responds to the previous one\n        print(\"\\nAvailable personalities:\")\n        for i, (name, perspective) in enumerate(bot_personalities.items(), 1):\n            print(f\"{i}. {name}: {perspective[:60]}...\")\n\n        # TODO: Add more robust input validation for selections\n        selections = input(\"\\nSelect personalities (comma-separated numbers, e.g., 1,3,4): \")\n        try:\n            selected_indices = [int(idx.strip()) - 1 for idx in selections.split(\",\")]\n            # Check if indices are valid\n            if any(idx &lt; 0 or idx &gt;= len(bot_personalities) for idx in selected_indices):\n                print(\"Some selections were invalid. Using first 3 personalities.\")\n                selected_indices = [0, 1, 2]\n        except ValueError:\n            print(\"Invalid input. Using first 3 personalities.\")\n            selected_indices = [0, 1, 2]\n\n        # Get the selected personalities\n        personalities = list(bot_personalities.items())\n        participants = {personalities[idx][0]: personalities[idx][1] for idx in selected_indices if 0 &lt;= idx &lt; len(personalities)}\n\n        # Panel discussions typically have fewer rounds with more participants\n        rounds = 1  \n\n    elif format_choice == 2:\n        # One-on-one debate - let user select exactly two participants\n        # This mode creates a structured back-and-forth exchange with multiple rounds\n        print(\"\\nChoose two debaters:\")\n        for i, (name, perspective) in enumerate(bot_personalities.items(), 1):\n            print(f\"{i}. {name}: {perspective[:60]}...\")\n\n        # TODO: Add input validation for debater selections\n        try:\n            choice1 = int(input(\"\\nSelect first debater (1-8): \")) - 1\n            choice2 = int(input(\"Select second debater (1-8): \")) - 1\n\n            if choice1 &lt; 0 or choice1 &gt;= len(bot_personalities) or choice2 &lt; 0 or choice2 &gt;= len(bot_personalities):\n                print(\"Invalid selection. Using Professor and Coach.\")\n                choice1, choice2 = 0, 1\n        except ValueError:\n            print(\"Invalid input. Using Professor and Coach.\")\n            choice1, choice2 = 0, 1\n\n        # Get the selected personalities\n        personalities = list(bot_personalities.items())\n        participants = {\n            personalities[choice1][0]: personalities[choice1][1],\n            personalities[choice2][0]: personalities[choice2][1]\n        }\n\n        # Set number of rounds for one-on-one debate\n        try:\n            rounds = int(input(\"\\nHow many response rounds? (1-5): \"))\n            rounds = min(max(1, rounds), 5)  # Ensure rounds is between 1 and 5\n        except ValueError:\n            print(\"Invalid input. Using 2 rounds.\")\n            rounds = 2\n\n    else:  # format_choice == 3\n        # Interview format - one interviewer, multiple interviewees\n        # This mode has one persona asking questions and others responding\n        print(\"\\nSelect the interviewer:\")\n        for i, (name, perspective) in enumerate(bot_personalities.items(), 1):\n            print(f\"{i}. {name}\")\n\n        # TODO: Add input validation for interviewer selection\n        try:\n            interviewer_idx = int(input(\"\\nSelect interviewer (1-8, recommend #8 'Interviewer'): \")) - 1\n            if interviewer_idx &lt; 0 or interviewer_idx &gt;= len(bot_personalities):\n                print(\"Invalid selection. Using 'Interviewer' persona.\")\n                # Find the Interviewer in the list\n                interviewer_idx = list(bot_personalities.keys()).index(\"Interviewer\") if \"Interviewer\" in bot_personalities else 0\n        except ValueError:\n            print(\"Invalid input. Using 'Interviewer' persona.\")\n            interviewer_idx = list(bot_personalities.keys()).index(\"Interviewer\") if \"Interviewer\" in bot_personalities else 0\n\n        print(\"\\nSelect interviewees:\")\n        personalities = list(bot_personalities.items())\n        interviewees = list(range(len(personalities)))\n        interviewees.remove(interviewer_idx)  # Remove interviewer from potential interviewees\n\n        for i, idx in enumerate(interviewees, 1):\n            name, perspective = personalities[idx]\n            print(f\"{i}. {name}: {perspective[:60]}...\")\n\n        # TODO: Add input validation for interviewee selections\n        selections = input(\"\\nSelect interviewees (comma-separated numbers): \")\n        try:\n            selected = [int(idx.strip()) - 1 for idx in selections.split(\",\")]\n            # Convert selected indices to actual personality indices\n            selected_indices = [interviewees[idx] for idx in selected if 0 &lt;= idx &lt; len(interviewees)]\n            if not selected_indices:\n                print(\"No valid selections. Using first two personalities.\")\n                selected_indices = interviewees[:2]\n        except ValueError:\n            print(\"Invalid input. Using first two personalities.\")\n            selected_indices = interviewees[:2]\n\n        # Add interviewer and interviewees to participants\n        participants = {personalities[interviewer_idx][0]: personalities[interviewer_idx][1]}\n        for idx in selected_indices:\n            participants[personalities[idx][0]] = personalities[idx][1]\n\n        # Set number of interview questions\n        try:\n            rounds = int(input(\"\\nHow many interview questions? (1-5): \"))\n            rounds = min(max(1, rounds), 5)  # Ensure rounds is between 1 and 5\n        except ValueError:\n            print(\"Invalid input. Using 3 questions.\")\n            rounds = 3\n\n    # Function to get response from a bot\n    def get_bot_response(prompt, perspective, name):\n        \"\"\"Generate a response from a persona based on their perspective.\"\"\"\n        system_prompt = f\"You are {name}. {perspective} Keep responses under 100 words to keep the dialogue flowing.\"\n        return get_response(prompt, system=system_prompt)\n\n    # Start the dialogue\n    participant_names = list(participants.keys())\n    print(f\"\\n=== Dialogue on: {dialogue_topic} ===\\n\")\n    time.sleep(1)\n\n    # Opening statements (except for interview format)\n    if format_choice != 3:  # Not interview format\n        print(\"=== Opening Statements ===\\n\")\n        statements = {}\n\n        for name, perspective in participants.items():\n            print(f\"{name}'s opening statement:\")\n            statement = get_bot_response(\n                f\"Give an opening statement on the topic of {dialogue_topic}\",\n                perspective,\n                name\n            )\n            statements[name] = statement\n            print(statement)\n            print()\n            time.sleep(1)\n\n    # Discussion rounds based on format\n    if format_choice == 1:\n        # Panel discussion - each persona responds to the previous speaker\n        # This creates a chain of responses where each builds on the last\n        print(\"\\n=== Panel Discussion ===\\n\")\n\n        previous_statement = statements[participant_names[-1]]\n        previous_name = participant_names[-1]\n\n        for round_num in range(rounds):\n            print(f\"--- Round {round_num + 1} ---\\n\")\n\n            for name in participant_names:\n                time.sleep(1)\n                print(f\"{name} responds to {previous_name}:\")\n                response = get_bot_response(\n                    f\"The topic is: {dialogue_topic}\\n{previous_name} said: '{previous_statement}'\\n\\nRespond to {previous_name}'s perspective with your own viewpoint.\",\n                    participants[name],\n                    name\n                )\n                print(response)\n                print()\n\n                previous_statement = response\n                previous_name = name\n\n    elif format_choice == 2:\n        # One-on-one debate - alternating responses with structured format\n        # This simulates a formal debate with clear turns and direct responses\n        print(\"\\n=== Debate Rounds ===\\n\")\n\n        debater1 = participant_names[0]\n        debater2 = participant_names[1]\n        current_statement = statements[debater2]\n\n        for round_num in range(rounds):\n            print(f\"--- Round {round_num + 1} ---\\n\")\n\n            # First debater responds\n            time.sleep(1)\n            print(f\"{debater1} responds:\")\n            response = get_bot_response(\n                f\"Respond to this statement on {dialogue_topic}: '{current_statement}'\",\n                participants[debater1],\n                debater1\n            )\n            print(response)\n            print()\n            current_statement = response\n\n            # Second debater responds\n            time.sleep(1)\n            print(f\"{debater2} responds:\")\n            response = get_bot_response(\n                f\"Respond to this statement on {dialogue_topic}: '{current_statement}'\",\n                participants[debater2],\n                debater2\n            )\n            print(response)\n            print()\n            current_statement = response\n\n    else:  # format_choice == 3\n        # Interview format - interviewer asks questions, interviewees respond\n        # This simulates a talk show or interview panel with one host\n        print(\"\\n=== Interview Session ===\\n\")\n\n        interviewer = participant_names[0]\n        interviewees = participant_names[1:]\n\n        # Opening question about the topic\n        print(f\"{interviewer} asks about {dialogue_topic}:\")\n        question = get_bot_response(\n            f\"As an interviewer, ask an insightful opening question about {dialogue_topic}\",\n            participants[interviewer],\n            interviewer\n        )\n        print(question)\n        print()\n\n        # Each interviewee responds to the opening question\n        for interviewee in interviewees:\n            time.sleep(1)\n            print(f\"{interviewee} responds:\")\n            response = get_bot_response(\n                f\"You're being interviewed. The interviewer asked: '{question}' regarding {dialogue_topic}. Respond with your perspective.\",\n                participants[interviewee],\n                interviewee\n            )\n            print(response)\n            print()\n\n        # Additional rounds of questions\n        for round_num in range(1, rounds):\n            time.sleep(1)\n            print(f\"--- Question {round_num + 1} ---\\n\")\n\n            # Interviewer asks a follow-up question\n            print(f\"{interviewer} asks:\")\n            question = get_bot_response(\n                f\"Based on the previous responses about {dialogue_topic}, ask a follow-up question that explores a different angle or aspect of the topic.\",\n                participants[interviewer],\n                interviewer\n            )\n            print(question)\n            print()\n\n            # Each interviewee responds to the new question\n            for interviewee in interviewees:\n                time.sleep(1)\n                print(f\"{interviewee} responds:\")\n                response = get_bot_response(\n                    f\"You're being interviewed. The interviewer asked: '{question}' regarding {dialogue_topic}. Respond with your perspective.\",\n                    participants[interviewee],\n                    interviewee\n                )\n                print(response)\n                print()\n\n    # Closing statements (except for interview format which has a special closing)\n    if format_choice != 3:\n        print(\"=== Closing Statements ===\\n\")\n        closing_statements = {}\n\n        for name, perspective in participants.items():\n            time.sleep(1)\n            print(f\"{name}'s closing remarks:\")\n            closing = get_bot_response(\n                f\"Give a brief closing statement summarizing your position on {dialogue_topic}\",\n                perspective,\n                name\n            )\n            closing_statements[name] = closing\n            print(closing)\n            print()\n    else:\n        # Special closing for interview format\n        print(\"=== Interview Wrap-up ===\\n\")\n        closing_statements = {}\n\n        # Interviewer provides a wrap-up\n        time.sleep(1)\n        print(f\"{interviewer}'s wrap-up:\")\n        interviewer_closing = get_bot_response(\n            f\"Provide a thoughtful wrap-up to the interview about {dialogue_topic}, thanking your guests and highlighting key insights.\",\n            participants[interviewer],\n            interviewer\n        )\n        closing_statements[interviewer] = interviewer_closing\n        print(interviewer_closing)\n        print()\n\n        # Each interviewee gives a brief final thought\n        for interviewee in interviewees:\n            time.sleep(1)\n            print(f\"{interviewee}'s final thought:\")\n            closing = get_bot_response(\n                f\"The interview about {dialogue_topic} is ending. Share a brief, impactful final thought in 1-2 sentences.\",\n                participants[interviewee],\n                interviewee\n            )\n            closing_statements[interviewee] = closing\n            print(closing)\n            print()\n\n    # Moderator summary\n    print(\"\\n=== Summary ===\\n\")\n\n    summary_prompt = f\"Summarize the dialogue on '{dialogue_topic}' between the following participants:\\n\\n\"\n\n    for name, perspective in participants.items():\n        summary_prompt += f\"{name}'s perspective: {perspective}\\n\"\n        if name in closing_statements:\n            summary_prompt += f\"{name}'s closing: {closing_statements[name]}\\n\\n\"\n\n    if format_choice == 1:\n        summary_type = \"panel discussion\"\n    elif format_choice == 2:\n        summary_type = \"debate\"\n    else:\n        summary_type = \"interview\"\n\n    summary_prompt += f\"Provide a neutral, balanced summary of this {summary_type}, highlighting the key differences in their approaches and the strengths of each perspective.\"\n\n    moderator = get_response(\n        summary_prompt,\n        system=\"You are a neutral, insightful moderator who can identify the merits of different viewpoints. Provide a balanced summary.\"\n    )\n\n    print(moderator)\n\n# Run the dialogue simulator\nif __name__ == \"__main__\":\n    ai_persona_dialogue_simulator()\n</code></pre>"},{"location":"projects/debate-interview-panel-dialogue-simulator/#using-the-simulator-for-interviews","title":"Using the Simulator for Interviews","text":"<p>To use this simulator specifically for interview scenarios:</p> <ol> <li> <p>Select Format #3 (Interview) - This configures one persona to act as the interviewer and others as interviewees</p> </li> <li> <p>Choose the Interviewer - Select the \"Interviewer\" persona (option #8) for best results, though any persona can serve as an interviewer</p> </li> <li> <p>Select Interviewees - Choose which personas will be interviewed on the selected topic</p> </li> <li> <p>Set Number of Questions - Determine how many rounds of questions the interviewer will ask</p> </li> <li> <p>Interview Structure:</p> </li> <li>The interviewer begins with an opening question about the topic</li> <li>Each interviewee responds from their unique perspective</li> <li>The interviewer asks follow-up questions in subsequent rounds</li> <li>The session concludes with a wrap-up from the interviewer and final thoughts from interviewees</li> </ol> <p>This interview format is particularly useful for: - Exploring multiple perspectives on controversial topics - Demonstrating how different personality types respond to the same questions - Simulating talk show or panel interview dynamics - Teaching questioning techniques and response patterns</p>"},{"location":"projects/debate-interview-panel-dialogue-simulator/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add a feature for the user to join as an additional participant</li> <li>Create specialized formats for specific topics (ethics, technology, etc.)</li> <li>Implement a scoring system where users rate which perspective they found most compelling</li> <li>Add follow-up questions that challenge each persona's perspective</li> <li>Create a \"change my mind\" feature where personas try to persuade on a controversial topic</li> <li>Allow students to create their own custom persona profiles</li> <li>Add a feature to visualize the dialogue flow and connections between arguments</li> <li>Implement a fact-checker persona that evaluates claims made during discussions</li> <li>Create a mode where personas can switch perspectives mid-dialogue to show flexibility in thinking</li> <li>Add the ability to save transcripts for later analysis or comparison</li> </ul>"},{"location":"projects/emotional-support-bot/","title":"Emotional Support Bot","text":"<p>Difficulty: Beginner-Intermediate Time: 30-45 minutes Learning Focus: Selection, text analysis, branching logic</p>"},{"location":"projects/emotional-support-bot/#overview","title":"Overview","text":"<p>Create a bot that responds differently based on the user's emotional state, providing tailored support, advice, or encouragement depending on the mood expressed.</p>"},{"location":"projects/emotional-support-bot/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef emotional_support_bot():\n    print(\"=== Emotional Support Bot ===\")\n    print(\"This bot will respond differently based on how you're feeling.\")\n    print(\"Type 'exit' at any time to quit.\\n\")\n\n    # Define different bot personalities for different moods\n    def therapist_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a compassionate and empathetic therapist. Provide supportive, thoughtful responses that validate the user's feelings. Offer gentle guidance and perspective without being pushy. Keep responses brief and focused on emotional support.\"\n        )\n\n    def coach_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are an energetic and motivational coach. Be enthusiastic, positive, and encouraging. Help channel the user's good energy into productive actions or goals. Keep responses upbeat and action-oriented.\"\n        )\n\n    def chill_bot(prompt):\n        return get_response(\n            prompt,\n            system=\"You are a calm, relaxed friend. Your responses are low-pressure and soothing. Suggest restful activities and ways to recharge. Keep responses brief and gentle.\"\n        )\n\n    # Main interaction loop\n    while True:\n        # Ask how the user is feeling\n        mood = input(\"\\nHow are you feeling today? (happy, sad, tired, anxious, exit): \").lower()\n\n        # Exit condition\n        if mood == \"exit\":\n            print(\"Take care! Remember I'm here whenever you need to talk.\")\n            break\n\n        # Get more details about their state\n        if mood in [\"happy\", \"sad\", \"tired\", \"anxious\"]:\n            details = input(f\"Tell me more about why you're feeling {mood}: \")\n\n            # Select appropriate bot based on mood\n            if mood == \"sad\" or mood == \"anxious\":\n                response = therapist_bot(f\"I'm feeling {mood}. {details}\")\n            elif mood == \"happy\":\n                response = coach_bot(f\"I'm feeling {mood}! {details}\")\n            elif mood == \"tired\":\n                response = chill_bot(f\"I'm feeling {mood}. {details}\")\n\n            print(\"\\nBot's response:\")\n            print(response)\n\n            # Follow-up question based on mood\n            if mood in [\"sad\", \"anxious\"]:\n                follow_up = input(\"\\nWould you like some suggestions to help you feel better? (yes/no): \")\n                if follow_up.lower() == \"yes\":\n                    suggestions = get_response(\n                        f\"The user is feeling {mood} because: {details}. Provide 3 specific, helpful suggestions to improve their mood.\",\n                        system=\"You are a supportive counselor offering practical, actionable advice. Format your response as a numbered list.\"\n                    )\n                    print(\"\\nHere are some suggestions:\")\n                    print(suggestions)\n            elif mood == \"happy\":\n                follow_up = input(\"\\nWould you like ideas to make the most of your good mood? (yes/no): \")\n                if follow_up.lower() == \"yes\":\n                    ideas = get_response(\n                        f\"The user is feeling {mood} because: {details}. Suggest 3 ways to channel this positive energy productively.\",\n                        system=\"You are an enthusiastic coach offering creative ways to use positive energy. Format your response as a numbered list.\"\n                    )\n                    print(\"\\nHere are some ideas:\")\n                    print(ideas)\n            elif mood == \"tired\":\n                follow_up = input(\"\\nWould you like some relaxation or energy tips? (relax/energy): \")\n                if follow_up.lower() == \"relax\":\n                    tips = get_response(\n                        \"Suggest 3 calming activities for someone who is tired and wants to relax.\",\n                        system=\"You are a wellness coach specializing in restful activities. Format your response as a numbered list.\"\n                    )\n                    print(\"\\nRelaxation suggestions:\")\n                    print(tips)\n                elif follow_up.lower() == \"energy\":\n                    tips = get_response(\n                        \"Suggest 3 gentle ways to boost energy when feeling tired without causing stress.\",\n                        system=\"You are a wellness coach specializing in natural energy boosters. Format your response as a numbered list.\"\n                    )\n                    print(\"\\nEnergy-boosting suggestions:\")\n                    print(tips)\n        else:\n            print(\"I don't recognize that mood. Please try again with happy, sad, tired, or anxious.\")\n\n# Run the emotional support bot\nif __name__ == \"__main__\":\n    emotional_support_bot()\n</code></pre>"},{"location":"projects/emotional-support-bot/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add more emotional states and corresponding bot personalities</li> <li>Create a mood tracking feature that remembers past interactions</li> <li>Implement sentiment analysis to detect mood from user's free text input</li> <li>Create a guided meditation or breathing exercise option</li> <li>Allow users to rate how helpful the responses were to improve the bot</li> </ul>"},{"location":"projects/historical-figure-chat/","title":"Historical Figure Chat","text":"<p>Difficulty: Beginner-Intermediate Time: 30-45 minutes Learning Focus: Historical research, character perspective, dialogue</p>"},{"location":"projects/historical-figure-chat/#overview","title":"Overview","text":"<p>Chat with simulated historical figures to learn about their lives, achievements, and time periods.</p>"},{"location":"projects/historical-figure-chat/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport random\n\ndef historical_figure_chat():\n    \"\"\"Chat with simulated historical figures\"\"\"\n    # Available historical figures\n    figures = {\n        \"Albert Einstein\": \"physicist who developed the theory of relativity\",\n        \"Marie Curie\": \"physicist and chemist who conducted pioneering research on radioactivity\",\n        \"Leonardo da Vinci\": \"Renaissance polymath known for art and inventions\",\n        \"Ada Lovelace\": \"mathematician and writer, known for work on Babbage's Analytical Engine\",\n        \"Martin Luther King Jr.\": \"civil rights leader and advocate for nonviolent resistance\",\n        \"Cleopatra\": \"last active ruler of the Ptolemaic Kingdom of Egypt\",\n        \"Mahatma Gandhi\": \"leader of India's nonviolent independence movement\",\n        \"Confucius\": \"Chinese philosopher and politician of the Spring and Autumn period\",\n        \"Frida Kahlo\": \"Mexican painter known for her portraits and works inspired by nature\",\n        \"Nelson Mandela\": \"revolutionary and political leader who served as President of South Africa\"\n    }\n\n    print(\"=== Historical Figure Chat ===\")\n    print(\"Available historical figures:\")\n\n    figure_list = list(figures.keys())\n    for i, figure in enumerate(figure_list):\n        print(f\"{i+1}. {figure} - {figures[figure]}\")\n\n    figure_choice = int(input(\"\\nSelect a figure (1-10): \")) - 1\n    figure = figure_list[figure_choice]\n\n    system_prompt = f\"\"\"\n    You are {figure}, {figures[figure]}.\n    Respond as if you are this historical figure, with appropriate knowledge, perspective, and speaking style.\n    Your knowledge is limited to what was known during your lifetime and your own experiences.\n    If asked about events after your lifetime, you should acknowledge you wouldn't know about them.\n    Maintain the personality, values, and worldview of {figure} based on historical accounts.\n    \"\"\"\n\n    print(f\"\\n=== Conversation with {figure} ===\")\n    print(f\"You are now chatting with {figure}. Type 'exit' to end.\")\n\n    # Welcome message\n    greetings = [\n        f\"Greetings! I am {figure}. What would you like to discuss?\",\n        f\"Hello there! {figure} at your service. How may I assist you?\",\n        f\"Welcome! You're speaking with {figure}. What's on your mind?\",\n        f\"Ah, a visitor! I am {figure}. What would you like to know?\",\n        f\"Good day! It's {figure} here. What shall we talk about?\"\n    ]\n\n    print(\"\\n\" + random.choice(greetings))\n\n    # Chat loop\n    while True:\n        user_input = input(\"\\nYou: \")\n\n        if user_input.lower() == \"exit\":\n            print(f\"\\n{figure}: Farewell! It was a pleasure speaking with you.\")\n            break\n\n        response = get_response(user_input, system=system_prompt)\n        print(f\"\\n{figure}: {response}\")\n\n# Run the historical figure chat\nif __name__ == \"__main__\":\n    historical_figure_chat()\n</code></pre>"},{"location":"projects/historical-figure-chat/#extension-ideas","title":"Extension Ideas","text":"<p>Add a \"time travel interview\" mode where students can interview multiple figures about the same topic or event.</p>"},{"location":"projects/image-gallery-creator/","title":"Image Gallery Creator","text":"<p>Difficulty: Intermediate Time: 45-60 minutes Learning Focus: File handling, HTML generation, metadata management, API integration</p>"},{"location":"projects/image-gallery-creator/#overview","title":"Overview","text":"<p>Create a tool that generates an HTML gallery from a collection of images. The tool manages image metadata, generates descriptions (optionally with AI assistance), and creates a responsive web gallery to showcase the images.</p>"},{"location":"projects/image-gallery-creator/#instructions","title":"Instructions","text":"<pre><code>import os\nimport json\nfrom chatcraft import get_response\nfrom datetime import datetime\n\ndef create_image_gallery():\n    \"\"\"\n    Creates an HTML image gallery from a collection of images.\n    Students can add their own images to the 'gallery_images' folder.\n    \"\"\"\n\n    print(\"=== Image Gallery Creator ===\")\n\n    # Create necessary directories\n    image_dir = \"gallery_images\"\n    output_dir = \"gallery_output\"\n    os.makedirs(image_dir, exist_ok=True)\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Check if there are images to process\n    image_files = [f for f in os.listdir(image_dir) \n                  if f.lower().endswith(('.jpg', '.jpeg', '.png', '.gif'))]\n\n    if not image_files:\n        print(f\"No images found in '{image_dir}' folder.\")\n        print(f\"Please add some image files (JPG, PNG, GIF) to the '{image_dir}' folder.\")\n        return\n\n    print(f\"Found {len(image_files)} images.\")\n\n    # Load existing metadata or create new\n    metadata_file = os.path.join(output_dir, \"gallery_metadata.json\")\n    if os.path.exists(metadata_file):\n        with open(metadata_file, 'r') as f:\n            try:\n                gallery_data = json.load(f)\n            except json.JSONDecodeError:\n                gallery_data = {\"title\": \"My Image Gallery\", \"images\": []}\n    else:\n        gallery_data = {\"title\": \"My Image Gallery\", \"images\": []}\n\n    # Update gallery title\n    gallery_title = input(f\"Gallery title [{gallery_data['title']}]: \")\n    if gallery_title:\n        gallery_data[\"title\"] = gallery_title\n\n    # Process each image\n    existing_images = {img[\"filename\"]: img for img in gallery_data[\"images\"]}\n\n    for image_file in image_files:\n        if image_file in existing_images:\n            # Image already has metadata\n            print(f\"\\nImage {image_file} already has metadata:\")\n            print(f\"Title: {existing_images[image_file]['title']}\")\n            print(f\"Description: {existing_images[image_file]['description']}\")\n\n            update = input(\"Update this image's information? (y/n): \").lower() == 'y'\n            if not update:\n                continue\n\n        print(f\"\\nProcessing: {image_file}\")\n\n        # Get metadata for this image\n        default_title = os.path.splitext(image_file)[0].replace('_', ' ').title()\n        title = input(f\"Image title [{default_title}]: \") or default_title\n\n        description = input(\"Image description: \")\n\n        # Optionally generate description using AI\n        if not description:\n            generate_ai = input(\"Generate description with AI? (y/n): \").lower() == 'y'\n            if generate_ai:\n                try:\n                    prompt = f\"Generate a brief, interesting description for an image named '{image_file}'. Create something imaginative based on the filename, without stating that you're guessing or that you haven't seen the image.\"\n                    description = get_response(prompt)\n                    print(f\"AI-generated description: {description}\")\n                    use_desc = input(\"Use this description? (y/n): \").lower() == 'y'\n                    if not use_desc:\n                        description = input(\"Enter alternative description: \")\n                except Exception as e:\n                    print(f\"Error generating AI description: {e}\")\n                    description = input(\"Enter description manually: \")\n\n        # Add or update metadata\n        image_data = {\n            \"filename\": image_file,\n            \"title\": title,\n            \"description\": description,\n            \"date_added\": datetime.now().strftime(\"%Y-%m-%d\")\n        }\n\n        if image_file in existing_images:\n            # Update existing entry\n            for i, img in enumerate(gallery_data[\"images\"]):\n                if img[\"filename\"] == image_file:\n                    gallery_data[\"images\"][i] = image_data\n                    break\n        else:\n            # Add new entry\n            gallery_data[\"images\"].append(image_data)\n\n    # Save updated metadata\n    with open(metadata_file, 'w') as f:\n        json.dump(gallery_data, f, indent=2)\n\n    print(\"\\nGenerating HTML gallery...\")\n\n    # Generate HTML gallery\n    html_output = f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;{gallery_data['title']}&lt;/title&gt;\n    &lt;style&gt;\n        body {{\n            font-family: Arial, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }}\n        h1 {{\n            text-align: center;\n            color: #333;\n        }}\n        .gallery {{\n            display: grid;\n            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n            grid-gap: 20px;\n            max-width: 1200px;\n            margin: 0 auto;\n        }}\n        .gallery-item {{\n            border-radius: 5px;\n            overflow: hidden;\n            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);\n            background-color: white;\n            transition: transform 0.3s;\n        }}\n        .gallery-item:hover {{\n            transform: translateY(-5px);\n        }}\n        .gallery-image {{\n            width: 100%;\n            height: 200px;\n            object-fit: cover;\n        }}\n        .gallery-content {{\n            padding: 15px;\n        }}\n        .gallery-title {{\n            margin-top: 0;\n            color: #333;\n        }}\n        .gallery-description {{\n            color: #666;\n            font-size: 0.9em;\n        }}\n        .gallery-date {{\n            color: #999;\n            font-size: 0.8em;\n            text-align: right;\n            margin-top: 10px;\n        }}\n        footer {{\n            text-align: center;\n            margin-top: 30px;\n            color: #999;\n            font-size: 0.8em;\n        }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{gallery_data['title']}&lt;/h1&gt;\n\n    &lt;div class=\"gallery\"&gt;\n\"\"\"\n\n    # Add each image to the gallery\n    for img in gallery_data[\"images\"]:\n        html_output += f\"\"\"        &lt;div class=\"gallery-item\"&gt;\n            &lt;img src=\"../{image_dir}/{img['filename']}\" alt=\"{img['title']}\" class=\"gallery-image\"&gt;\n            &lt;div class=\"gallery-content\"&gt;\n                &lt;h3 class=\"gallery-title\"&gt;{img['title']}&lt;/h3&gt;\n                &lt;p class=\"gallery-description\"&gt;{img['description']}&lt;/p&gt;\n                &lt;p class=\"gallery-date\"&gt;Added: {img['date_added']}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\"\"\"\n\n    # Complete the HTML\n    html_output += \"\"\"    &lt;/div&gt;\n\n    &lt;footer&gt;\n        &lt;p&gt;Created with Image Gallery Creator&lt;/p&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n    # Save the HTML file\n    html_file = os.path.join(output_dir, \"index.html\")\n    with open(html_file, 'w') as f:\n        f.write(html_output)\n\n    print(f\"\\nGallery created successfully!\")\n    print(f\"HTML file saved to: {html_file}\")\n    print(f\"Open this file in a web browser to view your gallery.\")\n\n    # Optional: Open the gallery in the default browser\n    try_open = input(\"\\nOpen gallery in browser? (y/n): \").lower() == 'y'\n    if try_open:\n        try:\n            import webbrowser\n            webbrowser.open('file://' + os.path.abspath(html_file))\n        except Exception as e:\n            print(f\"Could not open browser: {e}\")\n\n# Run the gallery creator\nif __name__ == \"__main__\":\n    create_image_gallery()\n</code></pre>"},{"location":"projects/image-gallery-creator/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add image filtering by tags or categories</li> <li>Implement image resizing and thumbnail generation</li> <li>Create a lightbox effect for viewing full-size images</li> <li>Add EXIF data extraction to display camera information</li> <li>Implement a theme selector with different gallery styles</li> <li>Create a server-side component to host the gallery online</li> </ul>"},{"location":"projects/journal-or-reflection-bot/","title":"Journal or Reflection Bot","text":"<p>Difficulty: Beginner-Intermediate Time: 30-45 minutes Learning Focus: Lists, memory, summarization</p>"},{"location":"projects/journal-or-reflection-bot/#overview","title":"Overview","text":"<p>Create a digital journaling assistant that helps users reflect on their experiences, identify patterns in their thoughts, and provide meaningful insights or feedback on their entries.</p>"},{"location":"projects/journal-or-reflection-bot/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport datetime\nimport os\n\ndef reflection_journal():\n    print(\"=== Personal Reflection Journal ===\")\n    print(\"Use this bot to keep track of your thoughts and receive insights.\")\n    print(\"Type 'exit' at any time to quit.\\n\")\n\n    # Create a list to store journal entries\n    memory = []\n\n    # Create a simple file-based storage system\n    journal_file = \"journal_entries.txt\"\n\n    # Load previous entries if file exists\n    if os.path.exists(journal_file):\n        try:\n            with open(journal_file, 'r') as f:\n                previous_entries = f.read().strip()\n                if previous_entries:\n                    print(\"Found previous journal entries.\")\n                    restore = input(\"Would you like to include them in today's reflection? (yes/no): \").lower()\n                    if restore == \"yes\":\n                        memory.append(previous_entries)\n                        print(\"Previous entries loaded.\")\n        except Exception as e:\n            print(f\"Error loading previous entries: {e}\")\n\n    # Main journaling loop\n    num_entries = int(input(\"How many things would you like to reflect on today? (1-5): \"))\n    num_entries = min(max(1, num_entries), 5)  # Ensure between 1 and 5\n\n    for i in range(num_entries):\n        print(f\"\\n--- Entry {i+1}/{num_entries} ---\")\n\n        # Prompt options\n        prompts = [\n            \"What's something that happened today that you'd like to reflect on?\",\n            \"What's something you learned today?\",\n            \"What's something you're grateful for today?\",\n            \"What's something that challenged you today?\",\n            \"What's something you're looking forward to?\"\n        ]\n\n        # Let user choose a prompt or write their own\n        print(\"Choose a prompt or create your own:\")\n        for j, prompt in enumerate(prompts, 1):\n            print(f\"{j}. {prompt}\")\n        print(f\"{len(prompts) + 1}. Write my own prompt\")\n\n        prompt_choice = input(\"\\nEnter choice (1-6): \")\n\n        # Exit condition\n        if prompt_choice.lower() == \"exit\":\n            break\n\n        # Get the prompt\n        try:\n            choice_num = int(prompt_choice)\n            if 1 &lt;= choice_num &lt;= len(prompts):\n                selected_prompt = prompts[choice_num - 1]\n            else:\n                selected_prompt = input(\"Enter your custom prompt: \")\n        except ValueError:\n            selected_prompt = prompts[0]  # Default to first prompt if invalid input\n\n        # Get the journal entry\n        print(f\"\\n{selected_prompt}\")\n        entry = input(\"&gt; \")\n\n        # Exit condition\n        if entry.lower() == \"exit\":\n            break\n\n        # Record the timestamp and add to memory\n        timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M\")\n        full_entry = f\"[{timestamp}] {selected_prompt}\\n{entry}\"\n        memory.append(full_entry)\n\n        # Give immediate reflection\n        if i &lt; num_entries - 1:  # Only for entries except the last one\n            reflection = get_response(\n                f\"The user wrote this journal entry: {entry}\\n\\nGive a brief, thoughtful response that might help them reflect deeper.\",\n                system=\"You are a supportive journaling assistant. Respond with 1-2 sentences that are empathetic and thought-provoking, but not advice-giving.\"\n            )\n            print(\"\\nReflection:\")\n            print(reflection)\n\n    # If we have entries, save them and provide insights\n    if memory:\n        # Save entries to file\n        try:\n            with open(journal_file, 'a') as f:\n                for entry in memory:\n                    f.write(entry + \"\\n\\n\")\n            print(\"\\nJournal entries saved.\")\n        except Exception as e:\n            print(f\"Error saving entries: {e}\")\n\n        # Combine all entries for analysis\n        all_entries = \"\\n\\n\".join(memory)\n\n        # Generate insights\n        print(\"\\n=== Journal Insights ===\")\n        insights = get_response(\n            f\"Here are the user's journal entries:\\n\\n{all_entries}\\n\\nProvide thoughtful insights about these reflections.\",\n            system=\"You are an insightful journaling assistant. Analyze these entries for patterns, themes, or notable elements. Provide 3-4 helpful observations that might help the user understand their thoughts better. Be supportive and thoughtful.\"\n        )\n\n        print(insights)\n\n        # Offer a follow-up question\n        print(\"\\n=== Reflection Question ===\")\n        question = get_response(\n            f\"Based on these journal entries:\\n\\n{all_entries}\\n\\nProvide one thoughtful question that would help the user reflect more deeply.\",\n            system=\"You are a reflective journaling coach. Create one open-ended, thought-provoking question that will help the user explore their thoughts more deeply. The question should be specific to the content of their entries.\"\n        )\n\n        print(question)\n    else:\n        print(\"No journal entries were recorded.\")\n\n# Run the reflection journal\nif __name__ == \"__main__\":\n    reflection_journal()\n</code></pre>"},{"location":"projects/journal-or-reflection-bot/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add mood tracking to each entry</li> <li>Create visualizations of common themes or topics over time</li> <li>Add a guided meditation option based on journal content</li> <li>Implement a goal-setting feature that references past entries</li> <li>Create specialized journaling templates for different purposes (gratitude, productivity, etc.)</li> </ul>"},{"location":"projects/knowledge-quiz-bot/","title":"Knowledge Quiz Bot","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: Lists, loops, conditionals, scoring systems</p>"},{"location":"projects/knowledge-quiz-bot/#overview","title":"Overview","text":"<p>Build a bot that quizzes the user on a topic and tracks their score.</p>"},{"location":"projects/knowledge-quiz-bot/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport random\n\ndef generate_questions(topic, number_of_questions=5):\n    \"\"\"Generate quiz questions about a specific topic\"\"\"\n    system_prompt = f\"\"\"\n    Create {number_of_questions} multiple-choice quiz questions about {topic}.\n    For each question, provide:\n    1. The question\n    2. Four possible answers labeled A, B, C, D\n    3. The correct answer letter\n    Format exactly as follows for each question:\n    QUESTION: (the question)\n    A. (option A)\n    B. (option B)\n    C. (option C)\n    D. (option D)\n    CORRECT: (correct letter)\n    \"\"\"\n\n    response = get_response(f\"Generate quiz questions about {topic}\", system=system_prompt)\n    questions = []\n\n    # Parse the response into a structured format\n    sections = response.split(\"QUESTION: \")\n    for section in sections[1:]:  # Skip first empty section\n        question_parts = section.strip().split(\"CORRECT: \")\n        options_text = question_parts[0]\n        correct_answer = question_parts[1].strip()[0]  # Just take the letter\n\n        # Split the question from options\n        question_lines = options_text.split(\"\\n\")\n        question = question_lines[0].strip()\n        options = question_lines[1:5]\n\n        questions.append({\n            \"question\": question,\n            \"options\": options,\n            \"correct\": correct_answer\n        })\n\n    return questions\n\ndef run_quiz():\n    \"\"\"Run an interactive quiz\"\"\"\n    print(\"Welcome to the Quiz Bot!\")\n    topic = input(\"What topic would you like to be quizzed on? \")\n\n    print(f\"\\nGenerating quiz questions about {topic}...\")\n    questions = generate_questions(topic)\n\n    score = 0\n\n    for i, q in enumerate(questions):\n        print(f\"\\nQuestion {i+1}: {q['question']}\")\n        for option in q['options']:\n            print(option)\n\n        user_answer = input(\"\\nYour answer (A, B, C, or D): \").strip().upper()\n\n        if user_answer == q['correct']:\n            print(\"Correct! \u2705\")\n            score += 1\n        else:\n            print(f\"Incorrect. The correct answer was {q['correct']}. \u274c\")\n\n    print(f\"\\nQuiz complete! Your score: {score}/{len(questions)}\")\n    percentage = (score / len(questions)) * 100\n\n    # Get feedback based on score\n    feedback_prompt = f\"The user scored {percentage}% on a quiz about {topic}. Give them a short, encouraging message based on their score.\"\n    feedback = get_response(feedback_prompt)\n    print(f\"\\n{feedback}\")\n\n# Run the quiz\nif __name__ == \"__main__\":\n    run_quiz()\n</code></pre>"},{"location":"projects/knowledge-quiz-bot/#extension-ideas","title":"Extension Ideas","text":"<p>Add difficulty levels, timing, or topic categories.</p>"},{"location":"projects/language-translation-helper/","title":"Language Translation Helper","text":"<p>Difficulty: Beginner Time: 30-45 minutes Learning Focus: Multilingual communication, cultural context</p>"},{"location":"projects/language-translation-helper/#overview","title":"Overview","text":"<p>Create a tool that helps translate text between languages and explains cultural context.</p>"},{"location":"projects/language-translation-helper/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\ndef translation_helper():\n    \"\"\"Tool to translate text and explain cultural context\"\"\"\n    # Available languages\n    languages = [\n        \"Spanish\", \"French\", \"German\", \"Italian\", \"Portuguese\", \n        \"Japanese\", \"Chinese\", \"Russian\", \"Arabic\", \"Hindi\"\n    ]\n\n    print(\"=== Language Translation Helper ===\")\n    print(\"1. Translate text\")\n    print(\"2. Learn useful phrases\")\n    print(\"3. Understand cultural context\")\n\n    choice = input(\"\\nWhat would you like to do? \")\n\n    if choice == \"1\":\n        # Translate text\n        print(\"\\nAvailable languages:\")\n        for i, lang in enumerate(languages):\n            print(f\"{i+1}. {lang}\")\n\n        source_lang = input(\"\\nFrom which language (or English)? \")\n        target_idx = int(input(\"Translate to which language (number)? \")) - 1\n        target_lang = languages[target_idx]\n\n        text = input(\"\\nEnter the text to translate: \")\n\n        system_prompt = f\"\"\"\n        You are a helpful translator between {source_lang} and {target_lang}.\n        Provide accurate translations while preserving meaning and tone.\n        For longer texts, include both a translation and a brief summary of the content.\n        \"\"\"\n\n        translate_prompt = f\"\"\"\n        Translate this {source_lang} text to {target_lang}:\n\n        \"{text}\"\n\n        Provide:\n        1. The translation\n        2. Pronunciation help (if applicable)\n        3. Any idiomatic expressions or culturally specific references explained\n        \"\"\"\n\n        print(f\"\\nTranslating from {source_lang} to {target_lang}...\")\n        translation = get_response(translate_prompt, system=system_prompt)\n\n        print(\"\\n=== Translation Results ===\")\n        print(translation)\n\n    elif choice == \"2\":\n        # Learn useful phrases\n        print(\"\\nAvailable languages:\")\n        for i, lang in enumerate(languages):\n            print(f\"{i+1}. {lang}\")\n\n        lang_idx = int(input(\"\\nWhich language (number)? \")) - 1\n        language = languages[lang_idx]\n\n        situation = input(\"\\nWhat situation do you need phrases for (e.g., restaurant, shopping, emergency)? \")\n\n        system_prompt = f\"\"\"\n        You are a helpful language guide who provides useful {language} phrases for travelers.\n        You provide accurate phrases, pronunciation guides, and cultural context.\n        \"\"\"\n\n        phrases_prompt = f\"\"\"\n        Provide useful {language} phrases for {situation} situations.\n\n        Include:\n        1. At least 5 essential phrases with English translations\n        2. Pronunciation guide for each phrase\n        3. Any cultural considerations to be aware of\n        4. When and how to use each phrase appropriately\n        \"\"\"\n\n        print(f\"\\nFinding useful {language} phrases for {situation}...\")\n        phrases = get_response(phrases_prompt, system=system_prompt)\n\n        print(f\"\\n=== Useful {language} Phrases for {situation.title()} ===\")\n        print(phrases)\n\n    elif choice == \"3\":\n        # Cultural context\n        print(\"\\nAvailable cultures/regions:\")\n        cultures = [lang + \"-speaking regions\" for lang in languages]\n        cultures.extend([\"Latin America\", \"Middle East\", \"Southeast Asia\", \"Nordic countries\"])\n\n        for i, culture in enumerate(cultures):\n            print(f\"{i+1}. {culture}\")\n\n        culture_idx = int(input(\"\\nWhich culture/region (number)? \")) - 1\n        culture = cultures[culture_idx]\n\n        aspect = input(\"\\nWhat cultural aspect are you interested in (e.g., greetings, dining, business, gestures)? \")\n\n        system_prompt = \"\"\"\n        You are a cultural consultant who helps people understand and respect different cultures.\n        You provide accurate, nuanced information about cultural practices, values, and etiquette.\n        \"\"\"\n\n        culture_prompt = f\"\"\"\n        Explain important aspects of {aspect} in {culture}.\n\n        Include:\n        1. Key cultural norms and expectations\n        2. Do's and don'ts to be aware of\n        3. How practices might differ from Western/American norms\n        4. Any regional variations to be aware of\n        5. Historical or social context that helps explain these practices\n        \"\"\"\n\n        print(f\"\\nResearching {aspect} in {culture}...\")\n        cultural_info = get_response(culture_prompt, system=system_prompt)\n\n        print(f\"\\n=== {aspect.title()} in {culture} ===\")\n        print(cultural_info)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the translation helper\nif __name__ == \"__main__\":\n    translation_helper()\n</code></pre>"},{"location":"projects/language-translation-helper/#extension-ideas","title":"Extension Ideas","text":"<p>Add a conversation practice mode where students can simulate dialogues in another language.</p>"},{"location":"projects/mood-journal-assistant/","title":"Mood Journal Assistant","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: File I/O, date handling, text analysis</p>"},{"location":"projects/mood-journal-assistant/#overview","title":"Overview","text":"<p>Create a journaling assistant that helps users track moods and reflect on patterns.</p>"},{"location":"projects/mood-journal-assistant/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport datetime\nimport os\nimport json\n\ndef mood_journal():\n    \"\"\"Interactive mood journaling assistant\"\"\"\n    journal_dir = os.path.expanduser(\"~/.mood_journal\")\n    os.makedirs(journal_dir, exist_ok=True)\n\n    journal_file = os.path.join(journal_dir, \"journal_entries.json\")\n\n    # Load existing entries\n    if os.path.exists(journal_file):\n        with open(journal_file, 'r') as f:\n            try:\n                entries = json.load(f)\n            except json.JSONDecodeError:\n                entries = []\n    else:\n        entries = []\n\n    # Get today's date\n    today = datetime.datetime.now().strftime(\"%Y-%m-%d\")\n\n    print(\"=== Mood Journal Assistant ===\")\n    print(\"1. Add a new entry\")\n    print(\"2. View past entries\")\n    print(\"3. Get insights\")\n\n    choice = input(\"\\nWhat would you like to do? \")\n\n    if choice == \"1\":\n        # Add new entry\n        mood = input(\"\\nHow would you rate your mood today (1-10)? \")\n        activities = input(\"What activities did you do today? \")\n        thoughts = input(\"Share any thoughts or reflections: \")\n\n        entry = {\n            \"date\": today,\n            \"mood\": mood,\n            \"activities\": activities,\n            \"thoughts\": thoughts\n        }\n\n        entries.append(entry)\n\n        # Save updated entries\n        with open(journal_file, 'w') as f:\n            json.dump(entries, f, indent=2)\n\n        # Get AI reflection\n        reflection_prompt = f\"\"\"\n        The user rated their mood as {mood}/10 today.\n        They did these activities: {activities}\n        Their thoughts: {thoughts}\n\n        Provide a thoughtful, supportive reflection on their entry.\n        \"\"\"\n\n        reflection = get_response(reflection_prompt, \n                                 system=\"You are a supportive, empathetic journaling assistant.\")\n        print(\"\\n=== Reflection ===\")\n        print(reflection)\n\n    elif choice == \"2\":\n        # View past entries\n        if not entries:\n            print(\"No entries found.\")\n            return\n\n        print(\"\\n=== Past Entries ===\")\n        for i, entry in enumerate(reversed(entries[-10:])):  # Show last 10 entries\n            print(f\"{i+1}. {entry['date']} - Mood: {entry['mood']}/10\")\n\n        entry_choice = input(\"\\nWhich entry would you like to view? (number) \")\n        try:\n            idx = int(entry_choice) - 1\n            entry = list(reversed(entries[-10:]))[idx]\n            print(f\"\\nDate: {entry['date']}\")\n            print(f\"Mood: {entry['mood']}/10\")\n            print(f\"Activities: {entry['activities']}\")\n            print(f\"Thoughts: {entry['thoughts']}\")\n        except (ValueError, IndexError):\n            print(\"Invalid entry number.\")\n\n    elif choice == \"3\":\n        # Get insights\n        if len(entries) &lt; 3:\n            print(\"Need more entries to generate insights (at least 3).\")\n            return\n\n        # Create a summary of recent entries\n        recent_entries = entries[-7:]  # Last 7 entries\n        entries_text = \"\"\n\n        for entry in recent_entries:\n            entries_text += f\"Date: {entry['date']}, Mood: {entry['mood']}/10\\n\"\n            entries_text += f\"Activities: {entry['activities']}\\n\"\n            entries_text += f\"Thoughts: {entry['thoughts']}\\n\\n\"\n\n        insight_prompt = f\"\"\"\n        Here are the user's recent journal entries:\n\n        {entries_text}\n\n        Based on these entries, provide:\n        1. Any patterns you notice in their mood\n        2. Activities that seem to correlate with higher moods\n        3. Gentle suggestions that might help improve their wellbeing\n        4. A positive affirmation\n        \"\"\"\n\n        insights = get_response(insight_prompt, \n                               system=\"You are an insightful, supportive journaling assistant who helps identify patterns in mood and behavior.\")\n        print(\"\\n=== Mood Insights ===\")\n        print(insights)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the journal\nif __name__ == \"__main__\":\n    mood_journal()\n</code></pre>"},{"location":"projects/mood-journal-assistant/#extension-ideas","title":"Extension Ideas","text":"<p>Add mood tracking visualizations or goal-setting features.</p>"},{"location":"projects/pdf-question-answering-chatbot/","title":"PDF Question Answering Chatbot","text":"<p>Difficulty: Intermediate-Advanced Time: 60-90 minutes Learning Focus: Document processing, natural language understanding, information retrieval</p>"},{"location":"projects/pdf-question-answering-chatbot/#overview","title":"Overview","text":"<p>Create a chatbot that can answer questions from a PDF document. This project teaches students how to extract and process text from PDFs and use AI to retrieve relevant information based on user queries.</p>"},{"location":"projects/pdf-question-answering-chatbot/#instructions","title":"Instructions","text":"<pre><code>import os\nimport sys\nimport fitz  # PyMuPDF\nfrom chatcraft import get_response\n\nclass PDFChatbot:\n    \"\"\"A chatbot that can answer questions about PDF documents.\"\"\"\n\n    def __init__(self):\n        self.pdf_file = None\n        self.pdf_text = \"\"\n        self.context_size = 5000  # Max context size to send to the AI\n\n    def load_pdf(self, file_path):\n        \"\"\"Load and extract text from a PDF file.\"\"\"\n        try:\n            if not os.path.exists(file_path):\n                print(f\"Error: File '{file_path}' not found.\")\n                return False\n\n            self.pdf_file = file_path\n\n            # Open the PDF\n            doc = fitz.open(file_path)\n\n            # Extract text from all pages\n            full_text = []\n            for page_num in range(len(doc)):\n                page = doc.load_page(page_num)\n                full_text.append(page.get_text())\n\n            self.pdf_text = \"\\n\".join(full_text)\n\n            # Print document stats\n            print(f\"\\nDocument loaded: {os.path.basename(file_path)}\")\n            print(f\"Number of pages: {len(doc)}\")\n            print(f\"Total characters: {len(self.pdf_text)}\")\n\n            # Print a preview\n            preview_length = min(200, len(self.pdf_text))\n            print(f\"\\nPreview:\\n{self.pdf_text[:preview_length]}...\")\n\n            return True\n\n        except Exception as e:\n            print(f\"Error loading PDF: {e}\")\n            return False\n\n    def summarize_document(self):\n        \"\"\"Generate a summary of the document.\"\"\"\n        if not self.pdf_text:\n            print(\"Error: No document loaded. Please load a PDF first.\")\n            return\n\n        print(\"\\nGenerating document summary...\")\n\n        # Create a prompt for the AI\n        prompt = f\"\"\"\n        Please provide a concise summary of the following document:\n\n        {self.pdf_text[:5000]}  # Send only the first part if the document is large\n\n        Include:\n        1. Main topics and themes\n        2. Key points or arguments\n        3. Important entities mentioned\n        4. Document structure overview\n\n        Keep the summary under 300 words.\n        \"\"\"\n\n        try:\n            summary = get_response(prompt)\n            print(\"\\n=== Document Summary ===\")\n            print(summary)\n        except Exception as e:\n            print(f\"Error generating summary: {e}\")\n\n    def answer_question(self, question):\n        \"\"\"Answer a question about the document.\"\"\"\n        if not self.pdf_text:\n            print(\"Error: No document loaded. Please load a PDF first.\")\n            return\n\n        if not question:\n            print(\"Error: No question provided.\")\n            return\n\n        print(f\"\\nAnswering: {question}\")\n\n        # Create a prompt for the AI\n        prompt = f\"\"\"\n        Document text:\n        {self.pdf_text[:self.context_size]}\n\n        Question: {question}\n\n        Please answer the question based only on the information provided in the document.\n        If the answer cannot be found in the document, state that clearly.\n        Provide page numbers or sections if you can determine them from the context.\n        \"\"\"\n\n        try:\n            answer = get_response(prompt)\n            print(\"\\n=== Answer ===\")\n            print(answer)\n        except Exception as e:\n            print(f\"Error generating answer: {e}\")\n\n    def extract_key_information(self):\n        \"\"\"Extract key information from the document.\"\"\"\n        if not self.pdf_text:\n            print(\"Error: No document loaded. Please load a PDF first.\")\n            return\n\n        print(\"\\nExtracting key information...\")\n\n        # Create a prompt for the AI\n        prompt = f\"\"\"\n        Please extract and organize key information from this document:\n\n        {self.pdf_text[:self.context_size]}\n\n        Extract the following (if present):\n        1. Dates and deadlines\n        2. Names and organizations\n        3. Numerical data or statistics\n        4. Definitions or technical terms\n        5. Action items or requirements\n\n        Format the information in clear categories with brief explanations.\n        \"\"\"\n\n        try:\n            key_info = get_response(prompt)\n            print(\"\\n=== Key Information ===\")\n            print(key_info)\n        except Exception as e:\n            print(f\"Error extracting information: {e}\")\n\n    def find_related_topics(self, topic):\n        \"\"\"Find information related to a specific topic in the document.\"\"\"\n        if not self.pdf_text:\n            print(\"Error: No document loaded. Please load a PDF first.\")\n            return\n\n        if not topic:\n            print(\"Error: No topic provided.\")\n            return\n\n        print(f\"\\nFinding information related to: {topic}\")\n\n        # Create a prompt for the AI\n        prompt = f\"\"\"\n        Document text:\n        {self.pdf_text[:self.context_size]}\n\n        Please find and extract all information related to the topic \"{topic}\" from the document.\n        Include any definitions, explanations, examples, or references related to this topic.\n        Organize the information in a structured way and indicate where in the document it appears if possible.\n        If the topic is not mentioned in the document, please state that clearly.\n        \"\"\"\n\n        try:\n            related_info = get_response(prompt)\n            print(f\"\\n=== Information Related to '{topic}' ===\")\n            print(related_info)\n        except Exception as e:\n            print(f\"Error finding related information: {e}\")\n\n    def run(self):\n        \"\"\"Run the PDF chatbot interface.\"\"\"\n        print(\"=== PDF Question Answering Chatbot ===\")\n        print(\"This chatbot can answer questions about PDF documents.\")\n\n        while True:\n            print(\"\\nOptions:\")\n            print(\"1. Load a PDF document\")\n            print(\"2. Get document summary\")\n            print(\"3. Ask a question\")\n            print(\"4. Extract key information\")\n            print(\"5. Find related topics\")\n            print(\"6. Exit\")\n\n            choice = input(\"\\nSelect an option (1-6): \")\n\n            if choice == '1':\n                # Load PDF\n                file_path = input(\"\\nEnter the path to a PDF file: \")\n                self.load_pdf(file_path)\n\n            elif choice == '2':\n                # Summarize document\n                self.summarize_document()\n\n            elif choice == '3':\n                # Ask a question\n                if not self.pdf_text:\n                    print(\"Please load a PDF document first (option 1).\")\n                    continue\n\n                question = input(\"\\nEnter your question about the document: \")\n                self.answer_question(question)\n\n            elif choice == '4':\n                # Extract key information\n                self.extract_key_information()\n\n            elif choice == '5':\n                # Find related topics\n                if not self.pdf_text:\n                    print(\"Please load a PDF document first (option 1).\")\n                    continue\n\n                topic = input(\"\\nEnter a topic to find in the document: \")\n                self.find_related_topics(topic)\n\n            elif choice == '6':\n                # Exit\n                print(\"\\nExiting PDF Chatbot. Goodbye!\")\n                break\n\n            else:\n                print(\"Invalid choice. Please select a number between 1 and 6.\")\n\n# Run the chatbot\nif __name__ == \"__main__\":\n    chatbot = PDFChatbot()\n    chatbot.run()\n</code></pre>"},{"location":"projects/pdf-question-answering-chatbot/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add support for multiple document formats (DOCX, TXT, etc.)</li> <li>Implement semantic search to find specific information more efficiently</li> <li>Create a feature to compare information across multiple documents</li> <li>Add a citation generator for referencing document content</li> <li>Build a web interface using Flask or Streamlit</li> <li>Implement document chunking for handling very large documents</li> </ul>"},{"location":"projects/pdf-question-answering-chatbot/#implementation-tips","title":"Implementation Tips","text":"<p>When using these advanced mini-projects in a classroom setting:</p> <ol> <li>Scaffold appropriately: Start with simpler projects for beginners, then progress to more complex ones.</li> <li>Modify complexity: Adjust project requirements based on student skill level and available time.</li> <li>Pair programming: Have students work in pairs to encourage collaboration.</li> <li>Challenge extensions: Provide additional challenges for students who finish early.</li> <li>Focus on concepts: Emphasize the programming concepts being used rather than just creating a functioning application.</li> <li>Ethical discussions: Use these projects as opportunities to discuss AI ethics, bias, and limitations.</li> </ol>"},{"location":"projects/pdf-question-answering-chatbot/#assessment-ideas","title":"Assessment Ideas","text":"<ul> <li>Have students document their process in a digital portfolio</li> <li>Create a \"project showcase\" where students present their creations</li> <li>Ask students to write reflections on what they learned</li> <li>Evaluate code structure, comments, and organization</li> <li>Have students peer-review each other's projects</li> </ul> <p>These examples are designed to be flexible starting points. Adjust and expand them to suit your specific educational needs and student skill levels.</p>"},{"location":"projects/personality-bot-creator/","title":"Personality Bot Creator","text":"<p>Difficulty: Beginner Time: 30-45 minutes Learning Focus: Functions, creativity, system prompts</p>"},{"location":"projects/personality-bot-creator/#overview","title":"Overview","text":"<p>Students create and interact with a bot that has a unique personality of their design. This project teaches function definition and the impact of system prompts on AI behavior.</p>"},{"location":"projects/personality-bot-creator/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\n\n# Example personalities students can create:\ndef superhero_bot(prompt):\n    return get_response(\n        prompt,\n        system=\"You are a confident superhero who always thinks positively and believes any problem can be solved. You occasionally reference your superpowers and heroic deeds.\",\n        personality=\"superhero\"\n    )\n\ndef grumpy_cat_bot(prompt):\n    return get_response(\n        prompt,\n        system=\"You are a perpetually unimpressed cat. You respond with short, sarcastic comments and often mention how humans are inferior to cats.\",\n        personality=\"grumpy\"\n    )\n\ndef chef_bot(prompt):\n    return get_response(\n        prompt,\n        system=\"You are an enthusiastic chef who relates everything to cooking. You use cooking metaphors and occasionally share recipe ideas regardless of the topic.\",\n        personality=\"chef\"\n    )\n\n# Test your bot with various prompts\ntest_prompts = [\n    \"How's the weather today?\",\n    \"Can you help me with my homework?\",\n    \"What's the meaning of life?\",\n    \"Tell me about yourself.\"\n]\n\n# Choose which bot to use\nmy_bot = superhero_bot  # Change to your custom bot\n\n# Test it with each prompt\nfor prompt in test_prompts:\n    print(f\"Prompt: {prompt}\")\n    print(f\"Response: {my_bot(prompt)}\")\n    print(\"-\" * 50)\n</code></pre>"},{"location":"projects/personality-bot-creator/#extension-ideas","title":"Extension Ideas","text":"<p>Create a menu system that lets the user choose which personality to talk to.</p>"},{"location":"projects/smart-to-do-list/","title":"Smart To-Do List","text":"<p>Difficulty: Intermediate Time: 60-75 minutes Learning Focus: Data structures, file I/O, date handling, AI assistance</p>"},{"location":"projects/smart-to-do-list/#overview","title":"Overview","text":"<p>Build a smart to-do list application that helps users organize tasks with categories, priorities, and due dates. The application provides AI-assisted recommendations for task management and organization.</p>"},{"location":"projects/smart-to-do-list/#instructions","title":"Instructions","text":"<pre><code>import os\nimport json\nfrom datetime import datetime, timedelta\nfrom chatcraft import get_response\n\nclass SmartTodoList:\n    \"\"\"\n    A smart to-do list that can categorize tasks, set priorities, \n    track due dates, and provide AI-assisted task management.\n    \"\"\"\n\n    def __init__(self):\n        self.tasks = []\n        self.categories = [\"Work\", \"School\", \"Personal\", \"Shopping\", \"Health\", \"Other\"]\n        self.priorities = [\"High\", \"Medium\", \"Low\"]\n        self.data_dir = \"todo_data\"\n        self.data_file = os.path.join(self.data_dir, \"tasks.json\")\n\n        # Create data directory if it doesn't exist\n        os.makedirs(self.data_dir, exist_ok=True)\n\n        # Load existing tasks if available\n        self.load_tasks()\n\n    def load_tasks(self):\n        \"\"\"Load tasks from the data file.\"\"\"\n        if os.path.exists(self.data_file):\n            try:\n                with open(self.data_file, 'r') as f:\n                    self.tasks = json.load(f)\n                print(f\"Loaded {len(self.tasks)} tasks from {self.data_file}\")\n            except json.JSONDecodeError:\n                print(\"Error reading tasks file. Starting with empty task list.\")\n                self.tasks = []\n        else:\n            print(\"No existing tasks file found. Starting with empty task list.\")\n            self.tasks = []\n\n    def save_tasks(self):\n        \"\"\"Save tasks to the data file.\"\"\"\n        with open(self.data_file, 'w') as f:\n            json.dump(self.tasks, f, indent=2)\n        print(f\"Saved {len(self.tasks)} tasks to {self.data_file}\")\n\n    def add_task(self):\n        \"\"\"Add a new task to the list.\"\"\"\n        print(\"\\n=== Add New Task ===\")\n\n        # Get task details\n        title = input(\"Task title: \")\n\n        # Select category\n        print(\"\\nCategories:\")\n        for i, category in enumerate(self.categories, 1):\n            print(f\"{i}. {category}\")\n\n        category_choice = input(f\"Select category (1-{len(self.categories)}): \")\n        try:\n            category_idx = int(category_choice) - 1\n            category = self.categories[category_idx]\n        except (ValueError, IndexError):\n            print(\"Invalid category selection. Using 'Other'.\")\n            category = \"Other\"\n\n        # Select priority\n        print(\"\\nPriorities:\")\n        for i, priority in enumerate(self.priorities, 1):\n            print(f\"{i}. {priority}\")\n\n        priority_choice = input(f\"Select priority (1-{len(self.priorities)}): \")\n        try:\n            priority_idx = int(priority_choice) - 1\n            priority = self.priorities[priority_idx]\n        except (ValueError, IndexError):\n            print(\"Invalid priority selection. Using 'Medium'.\")\n            priority = \"Medium\"\n\n        # Set due date\n        due_date = None\n        has_due_date = input(\"\\nDoes this task have a due date? (y/n): \").lower() == 'y'\n\n        if has_due_date:\n            date_format = \"%Y-%m-%d\"\n            date_input = input(\"Enter due date (YYYY-MM-DD) or relative (e.g., 'tomorrow', '3 days'): \")\n\n            try:\n                # Parse relative dates\n                if date_input.lower() == 'today':\n                    due_date = datetime.now().strftime(date_format)\n                elif date_input.lower() == 'tomorrow':\n                    due_date = (datetime.now() + timedelta(days=1)).strftime(date_format)\n                elif 'days' in date_input.lower():\n                    # Parse \"X days\" format\n                    try:\n                        days = int(date_input.split()[0])\n                        due_date = (datetime.now() + timedelta(days=days)).strftime(date_format)\n                    except (ValueError, IndexError):\n                        print(\"Could not parse relative date. Please enter a specific date.\")\n                else:\n                    # Try to parse as YYYY-MM-DD\n                    due_date = datetime.strptime(date_input, date_format).strftime(date_format)\n            except ValueError:\n                print(\"Invalid date format. Due date will not be set.\")\n\n        # Add notes\n        notes = input(\"\\nAdd any notes (optional): \")\n\n        # Create task object\n        task = {\n            \"id\": len(self.tasks) + 1,\n            \"title\": title,\n            \"category\": category,\n            \"priority\": priority,\n            \"due_date\": due_date,\n            \"notes\": notes,\n            \"completed\": False,\n            \"created_at\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        }\n\n        # Add to task list\n        self.tasks.append(task)\n        print(f\"\\nTask '{title}' added successfully!\")\n\n        # Save updated tasks\n        self.save_tasks()\n\n    def view_tasks(self, show_completed=False):\n        \"\"\"Display tasks based on filters.\"\"\"\n        if not self.tasks:\n            print(\"\\nNo tasks found.\")\n            return\n\n        filtered_tasks = [t for t in self.tasks if t[\"completed\"] == show_completed]\n\n        if not filtered_tasks:\n            status = \"completed\" if show_completed else \"pending\"\n            print(f\"\\nNo {status} tasks found.\")\n            return\n\n        # Sort tasks: first by due date (None at the end), then by priority\n        def sort_key(task):\n            # Priority order: High, Medium, Low\n            priority_order = {\"High\": 0, \"Medium\": 1, \"Low\": 2}\n\n            # Sort by due date first (None/null dates come last)\n            if task[\"due_date\"]:\n                return (0, task[\"due_date\"], priority_order.get(task[\"priority\"], 1))\n            else:\n                return (1, \"9999-99-99\", priority_order.get(task[\"priority\"], 1))\n\n        sorted_tasks = sorted(filtered_tasks, key=sort_key)\n\n        # Display tasks\n        status = \"Completed\" if show_completed else \"Pending\"\n        print(f\"\\n=== {status} Tasks ===\")\n\n        for i, task in enumerate(sorted_tasks, 1):\n            due_str = f\"Due: {task['due_date']}\" if task['due_date'] else \"No due date\"\n\n            # Add warning for tasks due today or overdue\n            warning = \"\"\n            if task['due_date']:\n                try:\n                    due_date = datetime.strptime(task['due_date'], \"%Y-%m-%d\").date()\n                    today = datetime.now().date()\n\n                    if due_date &lt; today and not task['completed']:\n                        warning = \" [OVERDUE!]\"\n                    elif due_date == today and not task['completed']:\n                        warning = \" [DUE TODAY!]\"\n                except ValueError:\n                    pass\n\n            print(f\"{i}. [{task['priority']}] {task['title']}{warning} - {due_str} ({task['category']})\")\n\n        # Return the sorted tasks for selection\n        return sorted_tasks\n\n    def toggle_task_status(self):\n        \"\"\"Mark a task as completed or pending.\"\"\"\n        print(\"\\n=== Toggle Task Status ===\")\n\n        # Show pending tasks first\n        pending_tasks = self.view_tasks(show_completed=False)\n\n        if pending_tasks:\n            # Show completed tasks\n            print(\"\\n=== Completed Tasks ===\")\n            completed_tasks = self.view_tasks(show_completed=True)\n\n            # Ask which list to toggle from\n            toggle_from = input(\"\\nToggle task from (p)ending or (c)ompleted list? \").lower()\n\n            if toggle_from == 'p' and pending_tasks:\n                task_list = pending_tasks\n                current_status = False\n            elif toggle_from == 'c' and completed_tasks:\n                task_list = completed_tasks\n                current_status = True\n            else:\n                print(\"Invalid selection or no tasks in that category.\")\n                return\n\n            # Get task number\n            task_num = input(f\"Enter task number to toggle (1-{len(task_list)}): \")\n            try:\n                idx = int(task_num) - 1\n                selected_task = task_list[idx]\n\n                # Find this task in the main task list and toggle its status\n                for task in self.tasks:\n                    if task[\"id\"] == selected_task[\"id\"]:\n                        task[\"completed\"] = not current_status\n                        status = \"completed\" if task[\"completed\"] else \"pending\"\n                        print(f\"\\nTask '{task['title']}' marked as {status}.\")\n                        break\n\n                # Save updated tasks\n                self.save_tasks()\n\n            except (ValueError, IndexError):\n                print(\"Invalid task number.\")\n\n    def edit_task(self):\n        \"\"\"Edit an existing task.\"\"\"\n        print(\"\\n=== Edit Task ===\")\n\n        # Show all tasks for selection\n        print(\"\\nAll Tasks:\")\n        all_tasks = self.tasks.copy()\n\n        # Sort tasks by completion status, then by other criteria\n        def sort_key(task):\n            return (task[\"completed\"], task.get(\"due_date\", \"9999-99-99\"), task[\"priority\"])\n\n        sorted_tasks = sorted(all_tasks, key=sort_key)\n\n        for i, task in enumerate(sorted_tasks, 1):\n            status = \"\u2713\" if task[\"completed\"] else \"\u2610\"\n            due_str = f\"Due: {task['due_date']}\" if task['due_date'] else \"No due date\"\n            print(f\"{i}. {status} [{task['priority']}] {task['title']} - {due_str} ({task['category']})\")\n\n        # Get task to edit\n        task_num = input(f\"\\nEnter task number to edit (1-{len(sorted_tasks)}): \")\n        try:\n            idx = int(task_num) - 1\n            selected_task = sorted_tasks[idx]\n\n            print(f\"\\nEditing task: {selected_task['title']}\")\n\n            # Get updated values\n            title = input(f\"Title [{selected_task['title']}]: \") or selected_task['title']\n\n            # Select category\n            print(\"\\nCategories:\")\n            for i, category in enumerate(self.categories, 1):\n                print(f\"{i}. {category}\")\n\n            category_choice = input(f\"Select category [current: {selected_task['category']}]: \")\n            if category_choice:\n                try:\n                    category_idx = int(category_choice) - 1\n                    category = self.categories[category_idx]\n                except (ValueError, IndexError):\n                    print(\"Invalid category selection. Keeping current category.\")\n                    category = selected_task['category']\n            else:\n                category = selected_task['category']\n\n            # Select priority\n            print(\"\\nPriorities:\")\n            for i, priority in enumerate(self.priorities, 1):\n                print(f\"{i}. {priority}\")\n\n            priority_choice = input(f\"Select priority [current: {selected_task['priority']}]: \")\n            if priority_choice:\n                try:\n                    priority_idx = int(priority_choice) - 1\n                    priority = self.priorities[priority_idx]\n                except (ValueError, IndexError):\n                    print(\"Invalid priority selection. Keeping current priority.\")\n                    priority = selected_task['priority']\n            else:\n                priority = selected_task['priority']\n\n            # Update due date\n            current_due = selected_task['due_date'] or \"None\"\n            due_choice = input(f\"Update due date? Current: {current_due} (y/n): \").lower()\n\n            if due_choice == 'y':\n                date_format = \"%Y-%m-%d\"\n                date_input = input(\"Enter due date (YYYY-MM-DD) or relative (e.g., 'tomorrow', '3 days'): \")\n\n                try:\n                    # Parse relative dates\n                    if date_input.lower() == 'today':\n                        due_date = datetime.now().strftime(date_format)\n                    elif date_input.lower() == 'tomorrow':\n                        due_date = (datetime.now() + timedelta(days=1)).strftime(date_format)\n                    elif 'days' in date_input.lower():\n                        # Parse \"X days\" format\n                        try:\n                            days = int(date_input.split()[0])\n                            due_date = (datetime.now() + timedelta(days=days)).strftime(date_format)\n                        except (ValueError, IndexError):\n                            print(\"Could not parse relative date. Keeping current due date.\")\n                            due_date = selected_task['due_date']\n                    elif date_input.lower() in ('none', 'remove', 'clear'):\n                        due_date = None\n                    else:\n                        # Try to parse as YYYY-MM-DD\n                        due_date = datetime.strptime(date_input, date_format).strftime(date_format)\n                except ValueError:\n                    print(\"Invalid date format. Keeping current due date.\")\n                    due_date = selected_task['due_date']\n            else:\n                due_date = selected_task['due_date']\n\n            # Update notes\n            current_notes = selected_task['notes'] or \"None\"\n            notes_choice = input(f\"Update notes? Current: {current_notes} (y/n): \").lower()\n\n            if notes_choice == 'y':\n                notes = input(\"Enter new notes: \")\n            else:\n                notes = selected_task['notes']\n\n            # Find this task in the main task list and update it\n            for task in self.tasks:\n                if task[\"id\"] == selected_task[\"id\"]:\n                    task[\"title\"] = title\n                    task[\"category\"] = category\n                    task[\"priority\"] = priority\n                    task[\"due_date\"] = due_date\n                    task[\"notes\"] = notes\n                    print(f\"\\nTask '{title}' updated successfully!\")\n                    break\n\n            # Save updated tasks\n            self.save_tasks()\n\n        except (ValueError, IndexError):\n            print(\"Invalid task number.\")\n\n    def delete_task(self):\n        \"\"\"Delete a task from the list.\"\"\"\n        print(\"\\n=== Delete Task ===\")\n\n        # Show all tasks for selection\n        print(\"\\nAll Tasks:\")\n        all_tasks = self.tasks.copy()\n\n        # Sort tasks by completion status, then by other criteria\n        def sort_key(task):\n            return (task[\"completed\"], task.get(\"due_date\", \"9999-99-99\"), task[\"priority\"])\n\n        sorted_tasks = sorted(all_tasks, key=sort_key)\n\n        for i, task in enumerate(sorted_tasks, 1):\n            status = \"\u2713\" if task[\"completed\"] else \"\u2610\"\n            due_str = f\"Due: {task['due_date']}\" if task['due_date'] else \"No due date\"\n            print(f\"{i}. {status} [{task['priority']}] {task['title']} - {due_str} ({task['category']})\")\n\n        # Get task to delete\n        task_num = input(f\"\\nEnter task number to delete (1-{len(sorted_tasks)}): \")\n        try:\n            idx = int(task_num) - 1\n            selected_task = sorted_tasks[idx]\n\n            # Confirm deletion\n            confirm = input(f\"Are you sure you want to delete '{selected_task['title']}'? (y/n): \").lower()\n\n            if confirm == 'y':\n                # Remove task from list\n                self.tasks = [t for t in self.tasks if t[\"id\"] != selected_task[\"id\"]]\n                print(f\"\\nTask '{selected_task['title']}' deleted successfully!\")\n\n                # Save updated tasks\n                self.save_tasks()\n            else:\n                print(\"Deletion cancelled.\")\n\n        except (ValueError, IndexError):\n            print(\"Invalid task number.\")\n\n    def get_ai_recommendations(self):\n        \"\"\"Get AI-assisted recommendations for task management.\"\"\"\n        if not self.tasks:\n            print(\"\\nNo tasks found. Please add some tasks first.\")\n            return\n\n        print(\"\\n=== AI Task Management Recommendations ===\")\n        print(\"Analyzing your tasks...\")\n\n        try:\n            # Prepare task data for AI\n            today = datetime.now().date()\n\n            # Count tasks by category\n            category_counts = {}\n            for task in self.tasks:\n                cat = task[\"category\"]\n                if cat in category_counts:\n                    category_counts[cat] += 1\n                else:\n                    category_counts[cat] = 1\n\n            # Count overdue tasks\n            overdue_tasks = []\n            for task in self.tasks:\n                if task[\"due_date\"] and not task[\"completed\"]:\n                    try:\n                        due_date = datetime.strptime(task[\"due_date\"], \"%Y-%m-%d\").date()\n                        if due_date &lt; today:\n                            overdue_tasks.append({\n                                \"title\": task[\"title\"],\n                                \"due_date\": task[\"due_date\"],\n                                \"days_overdue\": (today - due_date).days,\n                                \"priority\": task[\"priority\"]\n                            })\n                    except ValueError:\n                        pass\n\n            # Get tasks due today\n            today_tasks = []\n            for task in self.tasks:\n                if task[\"due_date\"] and not task[\"completed\"]:\n                    try:\n                        due_date = datetime.strptime(task[\"due_date\"], \"%Y-%m-%d\").date()\n                        if due_date == today:\n                            today_tasks.append({\n                                \"title\": task[\"title\"],\n                                \"priority\": task[\"priority\"],\n                                \"category\": task[\"category\"]\n                            })\n                    except ValueError:\n                        pass\n\n            # Get high priority tasks\n            high_priority = []\n            for task in self.tasks:\n                if task[\"priority\"] == \"High\" and not task[\"completed\"]:\n                    high_priority.append({\n                        \"title\": task[\"title\"],\n                        \"due_date\": task[\"due_date\"],\n                        \"category\": task[\"category\"]\n                    })\n\n            # Create prompt for AI\n            prompt = f\"\"\"\n            Based on the following task data, please provide helpful task management recommendations:\n\n            Task summary:\n            - Total tasks: {len(self.tasks)}\n            - Completed tasks: {sum(1 for t in self.tasks if t[\"completed\"])}\n            - Pending tasks: {sum(1 for t in self.tasks if not t[\"completed\"])}\n\n            Category breakdown: {category_counts}\n\n            Overdue tasks ({len(overdue_tasks)}):\n            {overdue_tasks if overdue_tasks else \"None\"}\n\n            Tasks due today ({len(today_tasks)}):\n            {today_tasks if today_tasks else \"None\"}\n\n            High priority pending tasks ({len(high_priority)}):\n            {high_priority if high_priority else \"None\"}\n\n            Please provide:\n            1. A prioritized action plan for the next 24 hours\n            2. Task management tips based on the current workload\n            3. Suggestions for which tasks to focus on first\n\n            Keep your response friendly, practical and under 300 words.\n            \"\"\"\n\n            # Get AI recommendations\n            recommendations = get_response(prompt)\n            print(\"\\n\" + recommendations)\n\n        except Exception as e:\n            print(f\"Error getting AI recommendations: {e}\")\n            print(\"Unable to generate AI recommendations at this time.\")\n\n    def run(self):\n        \"\"\"Run the main to-do list interface.\"\"\"\n        print(\"=== Smart To-Do List ===\")\n\n        while True:\n            print(\"\\nOptions:\")\n            print(\"1. Add new task\")\n            print(\"2. View pending tasks\")\n            print(\"3. View completed tasks\")\n            print(\"4. Toggle task status\")\n            print(\"5. Edit task\")\n            print(\"6. Delete task\")\n            print(\"7. Get AI recommendations\")\n            print(\"8. Exit\")\n\n            choice = input(\"\\nSelect an option (1-8): \")\n\n            if choice == '1':\n                self.add_task()\n            elif choice == '2':\n                self.view_tasks(show_completed=False)\n            elif choice == '3':\n                self.view_tasks(show_completed=True)\n            elif choice == '4':\n                self.toggle_task_status()\n            elif choice == '5':\n                self.edit_task()\n            elif choice == '6':\n                self.delete_task()\n            elif choice == '7':\n                self.get_ai_recommendations()\n            elif choice == '8':\n                print(\"\\nExiting Smart To-Do List. Goodbye!\")\n                break\n            else:\n                print(\"Invalid choice. Please select a number between 1 and 8.\")\n\n# Run the to-do list\nif __name__ == \"__main__\":\n    todo_list = SmartTodoList()\n    todo_list.run()\n</code></pre>"},{"location":"projects/smart-to-do-list/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add recurring tasks (daily, weekly, monthly)</li> <li>Implement task dependencies (tasks that require other tasks to be completed first)</li> <li>Create a calendar view to visualize task distribution</li> <li>Add a Pomodoro timer feature for focused work sessions</li> <li>Implement task sharing or collaboration features</li> <li>Create a mobile-friendly web interface using a framework like Flask</li> </ul>"},{"location":"projects/subject-expert-tutor/","title":"Subject Expert Tutor","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: Domain-specific prompting, educational dialogue</p>"},{"location":"projects/subject-expert-tutor/#overview","title":"Overview","text":"<p>Create a specialized tutor bot for a specific subject area that can explain concepts and quiz the user.</p>"},{"location":"projects/subject-expert-tutor/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport time\n\ndef tutor_bot():\n    \"\"\"Interactive subject tutor that explains concepts and offers practice questions\"\"\"\n    # Available subjects\n    subjects = {\n        \"math\": \"You are a patient math tutor who explains concepts step-by-step. You use analogies to make abstract ideas concrete.\",\n        \"science\": \"You are an enthusiastic science educator who relates scientific concepts to everyday experiences. You're excited about discovery and experimentation.\",\n        \"history\": \"You are a storytelling history tutor who makes historical events come alive through narrative. You emphasize cause and effect in historical developments.\",\n        \"literature\": \"You are a thoughtful literature guide who helps students analyze texts. You ask probing questions that deepen understanding of themes and characters.\",\n        \"programming\": \"You are a coding mentor who explains programming concepts with clear examples. You break down problems into manageable steps.\"\n    }\n\n    print(\"=== Subject Expert Tutor ===\")\n    print(\"Available subjects:\")\n    for i, subject in enumerate(subjects.keys()):\n        print(f\"{i+1}. {subject.title()}\")\n\n    subject_choice = int(input(\"\\nSelect a subject (1-5): \")) - 1\n    subject = list(subjects.keys())[subject_choice]\n    system_prompt = subjects[subject]\n\n    print(f\"\\n=== {subject.title()} Tutor ===\")\n    print(\"1. Ask a specific question\")\n    print(\"2. Learn a new concept\")\n    print(\"3. Take a practice quiz\")\n\n    mode = input(\"\\nWhat would you like to do? \")\n\n    if mode == \"1\":\n        # Ask specific question\n        question = input(\"\\nWhat's your question about \" + subject + \"? \")\n\n        print(\"\\nThinking...\")\n        answer = get_response(question, system=system_prompt)\n\n        print(\"\\n\" + answer)\n\n    elif mode == \"2\":\n        # Learn new concept\n        topic = input(f\"\\nWhat {subject} concept would you like to learn about? \")\n\n        learn_prompt = f\"\"\"\n        Explain the concept of {topic} in {subject} in a way that's easy to understand.\n        Include:\n        1. A simple definition\n        2. Why it's important\n        3. A real-world example or application\n        4. Any key formulas or principles (if applicable)\n        \"\"\"\n\n        print(\"\\nResearching this topic...\")\n        explanation = get_response(learn_prompt, system=system_prompt)\n\n        print(\"\\n\" + explanation)\n\n        # Check understanding\n        check_prompt = f\"Create a quick check-for-understanding question about {topic} in {subject}.\"\n        check_question = get_response(check_prompt, system=system_prompt)\n\n        print(\"\\n=== Check Your Understanding ===\")\n        print(check_question)\n\n        user_answer = input(\"\\nYour answer: \")\n\n        feedback_prompt = f\"\"\"\n        The user is learning about {topic} in {subject}.\n        I asked them: {check_question}\n        They answered: {user_answer}\n\n        Provide constructive feedback on their answer. If they're on the right track,\n        acknowledge that while adding any missing information. If they're incorrect, \n        gently correct them and re-explain the concept briefly.\n        \"\"\"\n\n        feedback = get_response(feedback_prompt, system=system_prompt)\n        print(\"\\n\" + feedback)\n\n    elif mode == \"3\":\n        # Practice quiz\n        difficulty = input(\"\\nChoose difficulty (easy/medium/hard): \").lower()\n        num_questions = 3\n\n        quiz_prompt = f\"\"\"\n        Create a {difficulty} {subject} quiz with {num_questions} questions.\n        For each question:\n        1. Ask a {difficulty}-level question about {subject}\n        2. Provide 4 possible answers labeled A, B, C, D\n        3. Indicate the correct answer\n\n        Format each question exactly like this:\n        Q: (question text)\n        A: (option A)\n        B: (option B)\n        C: (option C)\n        D: (option D)\n        Correct: (correct letter)\n        \"\"\"\n\n        print(f\"\\nGenerating a {difficulty} {subject} quiz...\")\n        quiz = get_response(quiz_prompt, system=system_prompt)\n\n        # Parse and present quiz\n        questions = []\n        sections = quiz.split(\"Q: \")\n\n        for section in sections[1:]:\n            question_parts = section.split(\"Correct: \")\n            question_text = question_parts[0].strip()\n            correct_answer = question_parts[1].strip()[0]  # Just take the first letter\n\n            questions.append({\n                \"text\": question_text,\n                \"correct\": correct_answer\n            })\n\n        # Administer quiz\n        score = 0\n        for i, q in enumerate(questions):\n            print(f\"\\nQuestion {i+1}:\")\n            print(q[\"text\"])\n\n            user_answer = input(\"\\nYour answer (A/B/C/D): \").strip().upper()\n\n            if user_answer == q[\"correct\"]:\n                print(\"\u2713 Correct!\")\n                score += 1\n            else:\n                print(f\"\u2717 Incorrect. The correct answer was {q['correct']}.\")\n\n                # Get explanation\n                explain_prompt = f\"\"\"\n                The question was: {q['text']}\n                The correct answer is {q['correct']}.\n                Explain why this is the correct answer in a helpful way.\n                \"\"\"\n\n                explanation = get_response(explain_prompt, system=system_prompt)\n                print(\"\\nExplanation:\")\n                print(explanation)\n\n            # Small pause between questions\n            if i &lt; len(questions) - 1:\n                time.sleep(1)\n\n        # Final score and feedback\n        print(f\"\\nQuiz complete! You scored {score}/{len(questions)}.\")\n\n        feedback_prompt = f\"\"\"\n        The user just completed a {difficulty} {subject} quiz and scored {score}/{len(questions)}.\n        Provide some encouraging feedback and suggest what they might want to study next.\n        \"\"\"\n\n        feedback = get_response(feedback_prompt, system=system_prompt)\n        print(\"\\n\" + feedback)\n\n    else:\n        print(\"Invalid choice.\")\n\n# Run the tutor bot\nif __name__ == \"__main__\":\n    tutor_bot()\n</code></pre>"},{"location":"projects/subject-expert-tutor/#extension-ideas","title":"Extension Ideas","text":"<p>Add a spaced repetition system that tracks concepts users struggle with and revisits them.</p>"},{"location":"projects/text-adventure-game-engine/","title":"Text Adventure Game Engine","text":"<p>Difficulty: Advanced Time: 90-120 minutes Learning Focus: Object-oriented programming, game design, file I/O, AI interaction</p>"},{"location":"projects/text-adventure-game-engine/#overview","title":"Overview","text":"<p>Create a text adventure game engine that allows students to build interactive stories with rooms, items, and characters. The engine supports saving/loading games and provides AI-powered hints to guide players.</p>"},{"location":"projects/text-adventure-game-engine/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport json\nimport os\n\nclass Room:\n    \"\"\"A location in the game world with description and connections to other rooms.\"\"\"\n    def __init__(self, name, description, exits=None, items=None):\n        self.name = name\n        self.description = description\n        self.exits = exits or {}  # Dictionary mapping direction -&gt; room name\n        self.items = items or []  # List of item names\n\n    def add_exit(self, direction, room_name):\n        \"\"\"Add an exit from this room.\"\"\"\n        self.exits[direction] = room_name\n\n    def add_item(self, item):\n        \"\"\"Add an item to this room.\"\"\"\n        self.items.append(item)\n\n    def remove_item(self, item):\n        \"\"\"Remove an item from this room.\"\"\"\n        if item in self.items:\n            self.items.remove(item)\n            return True\n        return False\n\n    def get_details(self):\n        \"\"\"Get a formatted description of the room including exits and items.\"\"\"\n        details = f\"{self.name}\\n\"\n        details += f\"{'-' * len(self.name)}\\n\"\n        details += f\"{self.description}\\n\"\n\n        if self.exits:\n            details += \"\\nExits:\"\n            for direction, room in self.exits.items():\n                details += f\" {direction}\"\n\n        if self.items:\n            details += \"\\n\\nYou can see:\"\n            for item in self.items:\n                details += f\"\\n- {item}\"\n\n        return details\n\n    def to_dict(self):\n        \"\"\"Convert room to dictionary for saving.\"\"\"\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"exits\": self.exits,\n            \"items\": self.items\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create room from dictionary data.\"\"\"\n        return cls(\n            data[\"name\"],\n            data[\"description\"],\n            data.get(\"exits\", {}),\n            data.get(\"items\", [])\n        )\n\n\nclass Player:\n    \"\"\"The player character with inventory and current location.\"\"\"\n    def __init__(self, name, current_room=\"Starting Room\"):\n        self.name = name\n        self.current_room = current_room\n        self.inventory = []\n        self.game_flags = {}  # For tracking game state, quests, etc.\n\n    def move(self, direction, world):\n        \"\"\"Try to move in a direction. Return success/failure message.\"\"\"\n        current_room = world.get_room(self.current_room)\n\n        if direction in current_room.exits:\n            self.current_room = current_room.exits[direction]\n            return f\"You move {direction}.\"\n        else:\n            return f\"You can't go {direction} from here.\"\n\n    def take(self, item_name, world):\n        \"\"\"Try to take an item from the current room.\"\"\"\n        current_room = world.get_room(self.current_room)\n\n        for item in current_room.items:\n            if item.lower() == item_name.lower():\n                current_room.remove_item(item)\n                self.inventory.append(item)\n                return f\"You take the {item}.\"\n\n        return f\"There is no {item_name} here.\"\n\n    def drop(self, item_name, world):\n        \"\"\"Try to drop an item from inventory into the current room.\"\"\"\n        current_room = world.get_room(self.current_room)\n\n        for item in self.inventory:\n            if item.lower() == item_name.lower():\n                self.inventory.remove(item)\n                current_room.add_item(item)\n                return f\"You drop the {item}.\"\n\n        return f\"You don't have a {item_name}.\"\n\n    def check_inventory(self):\n        \"\"\"Check what items the player is carrying.\"\"\"\n        if not self.inventory:\n            return \"Your inventory is empty.\"\n\n        result = \"You are carrying:\"\n        for item in self.inventory:\n            result += f\"\\n- {item}\"\n        return result\n\n    def to_dict(self):\n        \"\"\"Convert player to dictionary for saving.\"\"\"\n        return {\n            \"name\": self.name,\n            \"current_room\": self.current_room,\n            \"inventory\": self.inventory,\n            \"game_flags\": self.game_flags\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create player from dictionary data.\"\"\"\n        player = cls(data[\"name\"], data[\"current_room\"])\n        player.inventory = data.get(\"inventory\", [])\n        player.game_flags = data.get(\"game_flags\", {})\n        return player\n\n\nclass World:\n    \"\"\"The game world containing all rooms and game state.\"\"\"\n    def __init__(self, title=\"Adventure Game\"):\n        self.title = title\n        self.rooms = {}  # Dictionary mapping room name -&gt; Room object\n\n    def add_room(self, room):\n        \"\"\"Add a room to the world.\"\"\"\n        self.rooms[room.name] = room\n\n    def get_room(self, room_name):\n        \"\"\"Get a room by name.\"\"\"\n        return self.rooms.get(room_name)\n\n    def to_dict(self):\n        \"\"\"Convert world to dictionary for saving.\"\"\"\n        return {\n            \"title\": self.title,\n            \"rooms\": {name: room.to_dict() for name, room in self.rooms.items()}\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create world from dictionary data.\"\"\"\n        world = cls(data[\"title\"])\n        for name, room_data in data[\"rooms\"].items():\n            world.add_room(Room.from_dict(room_data))\n        return world\n\n\nclass GameEngine:\n    \"\"\"Main game engine for running the adventure.\"\"\"\n    def __init__(self, player, world):\n        self.player = player\n        self.world = world\n        self.running = False\n        self.commands = {\n            \"go\": self.cmd_go,\n            \"look\": self.cmd_look,\n            \"take\": self.cmd_take,\n            \"drop\": self.cmd_drop,\n            \"inventory\": self.cmd_inventory,\n            \"help\": self.cmd_help,\n            \"quit\": self.cmd_quit\n        }\n        self.save_dir = \"game_saves\"\n        os.makedirs(self.save_dir, exist_ok=True)\n\n    def cmd_go(self, args):\n        \"\"\"Handle movement command.\"\"\"\n        if not args:\n            return \"Go where? Try 'go north', 'go south', etc.\"\n\n        direction = args[0].lower()\n        return self.player.move(direction, self.world)\n\n    def cmd_look(self, args):\n        \"\"\"Look around the current room.\"\"\"\n        current_room = self.world.get_room(self.player.current_room)\n        return current_room.get_details()\n\n    def cmd_take(self, args):\n        \"\"\"Take an item from the room.\"\"\"\n        if not args:\n            return \"Take what? Try 'take [item name]'.\"\n\n        item_name = \" \".join(args)\n        return self.player.take(item_name, self.world)\n\n    def cmd_drop(self, args):\n        \"\"\"Drop an item from inventory.\"\"\"\n        if not args:\n            return \"Drop what? Try 'drop [item name]'.\"\n\n        item_name = \" \".join(args)\n        return self.player.drop(item_name, self.world)\n\n    def cmd_inventory(self, args):\n        \"\"\"Check inventory.\"\"\"\n        return self.player.check_inventory()\n\n    def cmd_help(self, args):\n        \"\"\"Show help information.\"\"\"\n        help_text = \"Available commands:\\n\"\n        help_text += \"- go [direction]: Move in a direction (north, south, east, west)\\n\"\n        help_text += \"- look: Examine your surroundings\\n\"\n        help_text += \"- take [item]: Take an item from the room\\n\"\n        help_text += \"- drop [item]: Drop an item from your inventory\\n\"\n        help_text += \"- inventory: Check what you're carrying\\n\"\n        help_text += \"- help: Show this help text\\n\"\n        help_text += \"- quit: Exit the game\\n\"\n        help_text += \"- hint: Get a helpful hint (AI-powered)\\n\"\n        help_text += \"- save [name]: Save your progress\\n\"\n        return help_text\n\n    def cmd_quit(self, args):\n        \"\"\"Quit the game.\"\"\"\n        self.running = False\n        return \"Thanks for playing!\"\n\n    def save_game(self, filename):\n        \"\"\"Save the current game state.\"\"\"\n        game_data = {\n            \"world\": self.world.to_dict(),\n            \"player\": self.player.to_dict()\n        }\n\n        filepath = os.path.join(self.save_dir, f\"{filename}.json\")\n        with open(filepath, 'w') as f:\n            json.dump(game_data, f, indent=2)\n\n        return f\"Game saved as '{filename}'\"\n\n    @classmethod\n    def load_game(cls, filename):\n        \"\"\"Load a game from a save file.\"\"\"\n        filepath = os.path.join(\"game_saves\", f\"{filename}.json\")\n\n        with open(filepath, 'r') as f:\n            game_data = json.load(f)\n\n        world = World.from_dict(game_data[\"world\"])\n        player = Player.from_dict(game_data[\"player\"])\n\n        return cls(player, world)\n\n    def process_input(self, user_input):\n        \"\"\"Process user input and return the result.\"\"\"\n        words = user_input.lower().split()\n\n        if not words:\n            return \"Please enter a command.\"\n\n        command = words[0]\n        args = words[1:] if len(words) &gt; 1 else []\n\n        if command in self.commands:\n            return self.commands[command](args)\n        else:\n            return f\"I don't understand '{command}'. Try 'help' for a list of commands.\"\n\n    def run(self):\n        \"\"\"Run the main game loop.\"\"\"\n        self.running = True\n\n        print(f\"Welcome to {self.world.title}!\")\n        print(f\"You are {self.player.name}, an adventurer seeking fortune and glory.\")\n        print(\"Type 'help' for a list of commands.\")\n\n        # Show the initial room\n        current_room = self.world.get_room(self.player.current_room)\n        print(\"\\n\" + current_room.get_details())\n\n        while self.running:\n            user_input = input(\"\\n&gt; \").strip()\n\n            # Special case for save command\n            if user_input.startswith(\"save \"):\n                save_name = user_input[5:].strip()\n                if save_name:\n                    print(self.save_game(save_name))\n                else:\n                    print(\"Please specify a save name: 'save [name]'\")\n                continue\n\n            # Special case for AI hint\n            if user_input.lower() == \"hint\":\n                try:\n                    current_room = self.world.get_room(self.player.current_room)\n                    inventory_str = \", \".join(self.player.inventory) if self.player.inventory else \"nothing\"\n\n                    hint_prompt = f\"\"\"\n                    In this text adventure game:\n                    - The player is in: {current_room.name}\n                    - Room description: {current_room.description}\n                    - Available exits: {', '.join(current_room.exits.keys()) if current_room.exits else 'none'}\n                    - Items in room: {', '.join(current_room.items) if current_room.items else 'none'}\n                    - Player is carrying: {inventory_str}\n\n                    Based on this situation, provide a gentle hint about what the player might try next.\n                    Keep it vague enough to not spoil puzzles but helpful enough to guide them.\n                    \"\"\"\n\n                    print(\"Thinking of a hint...\")\n                    hint = get_response(hint_prompt)\n                    print(f\"\\nHint: {hint}\")\n\n                except Exception as e:\n                    print(f\"Sorry, I couldn't come up with a hint right now: {e}\")\n\n                continue\n\n            result = self.process_input(user_input)\n            print(result)\n\n\ndef create_default_world():\n    \"\"\"Create a simple default world for demonstration.\"\"\"\n    world = World(\"The Forgotten Caverns\")\n\n    # Create rooms\n    entrance = Room(\n        \"Cave Entrance\",\n        \"You stand at the entrance to a mysterious cave. Sunlight filters in from above, casting eerie shadows on the walls.\"\n    )\n\n    main_passage = Room(\n        \"Main Passage\",\n        \"A narrow passage stretches deeper into the cave. Water drips from the ceiling, creating small puddles on the ground.\"\n    )\n\n    chamber = Room(\n        \"Crystal Chamber\",\n        \"This large chamber is filled with glowing crystals of various colors, illuminating the space with an otherworldly light.\"\n    )\n\n    side_tunnel = Room(\n        \"Side Tunnel\",\n        \"A tight tunnel branches off from the main passage. The air feels stale here.\"\n    )\n\n    underground_pool = Room(\n        \"Underground Pool\",\n        \"A still, dark pool of water fills most of this chamber. The surface reflects the subtle glow from the ceiling.\"\n    )\n\n    # Connect rooms\n    entrance.add_exit(\"north\", \"Main Passage\")\n\n    main_passage.add_exit(\"south\", \"Cave Entrance\")\n    main_passage.add_exit(\"north\", \"Crystal Chamber\")\n    main_passage.add_exit(\"east\", \"Side Tunnel\")\n\n    chamber.add_exit(\"south\", \"Main Passage\")\n    chamber.add_exit(\"west\", \"Underground Pool\")\n\n    side_tunnel.add_exit(\"west\", \"Main Passage\")\n\n    underground_pool.add_exit(\"east\", \"Crystal Chamber\")\n\n    # Add items\n    entrance.add_item(\"torch\")\n    entrance.add_item(\"rope\")\n\n    main_passage.add_item(\"rusty key\")\n\n    chamber.add_item(\"glowing crystal\")\n\n    underground_pool.add_item(\"ancient coin\")\n\n    # Add rooms to world\n    world.add_room(entrance)\n    world.add_room(main_passage)\n    world.add_room(chamber)\n    world.add_room(side_tunnel)\n    world.add_room(underground_pool)\n\n    return world\n\n\ndef play_adventure_game():\n    \"\"\"Start a new adventure game or load a saved one.\"\"\"\n    print(\"=== Text Adventure Game Engine ===\")\n    print(\"1. Start new game\")\n    print(\"2. Load saved game\")\n\n    choice = input(\"\\nSelect an option: \")\n\n    if choice == \"1\":\n        player_name = input(\"\\nWhat is your name, adventurer? \")\n        player = Player(player_name, \"Cave Entrance\")\n        world = create_default_world()\n        game = GameEngine(player, world)\n        game.run()\n\n    elif choice == \"2\":\n        # Check for save files\n        save_dir = \"game_saves\"\n        if not os.path.exists(save_dir) or not os.listdir(save_dir):\n            print(\"No save files found. Starting a new game...\")\n            player_name = input(\"\\nWhat is your name, adventurer? \")\n            player = Player(player_name, \"Cave Entrance\")\n            world = create_default_world()\n            game = GameEngine(player, world)\n        else:\n            # List save files\n            save_files = [f[:-5] for f in os.listdir(save_dir) if f.endswith(\".json\")]\n            print(\"\\nAvailable save files:\")\n            for i, save in enumerate(save_files, 1):\n                print(f\"{i}. {save}\")\n\n            save_idx = int(input(\"\\nSelect a save file (number): \")) - 1\n            if 0 &lt;= save_idx &lt; len(save_files):\n                try:\n                    game = GameEngine.load_game(save_files[save_idx])\n                    print(f\"Loaded save: {save_files[save_idx]}\")\n                except Exception as e:\n                    print(f\"Error loading save: {e}\")\n                    return\n            else:\n                print(\"Invalid selection. Starting a new game...\")\n                player_name = input(\"\\nWhat is your name, adventurer? \")\n                player = Player(player_name, \"Cave Entrance\")\n                world = create_default_world()\n                game = GameEngine(player, world)\n\n        game.run()\n\n    else:\n        print(\"Invalid choice. Exiting.\")\n\n\n# Run the game\nif __name__ == \"__main__\":\n    play_adventure_game()\n</code></pre>"},{"location":"projects/text-adventure-game-engine/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add more room types with special properties (e.g., dark rooms that require a light source)</li> <li>Implement NPCs (non-player characters) that the player can talk to</li> <li>Add simple puzzles that require specific items to solve</li> <li>Create a quest system with objectives and rewards</li> <li>Design a combat system for encounters with enemies</li> <li>Build a web-based interface using a framework like Flask</li> </ul>"},{"location":"projects/trivia-or-quiz-bot/","title":"Trivia or Quiz Bot","text":"<p>Difficulty: Beginner-Intermediate Time: 45-60 minutes Learning Focus: Loops, conditionals, lists</p>"},{"location":"projects/trivia-or-quiz-bot/#overview","title":"Overview","text":"<p>Build an interactive quiz bot that asks questions, tracks the user's score, provides feedback, and offers hints when needed.</p>"},{"location":"projects/trivia-or-quiz-bot/#instructions","title":"Instructions","text":"<pre><code>from chatcraft import get_response\nimport random\n\ndef create_quiz_bot():\n    # Define your quiz questions as (question, answer) tuples\n    questions = [\n        (\"What's 2 + 2?\", \"4\"),\n        (\"What is the capital of France?\", \"paris\"),\n        (\"What's the keyword for loops in Python?\", \"for\"),\n        (\"What year did the first iPhone release?\", \"2007\"),\n        (\"Who wrote 'Romeo and Juliet'?\", \"shakespeare\"),\n    ]\n\n    # Randomize questions\n    random.shuffle(questions)\n\n    # Initialize score\n    score = 0\n    total = len(questions)\n\n    # Introduction\n    print(\"Welcome to the Quiz Bot!\")\n    print(f\"I'll ask you {total} questions. Let's see how you do!\\n\")\n\n    # Loop through questions\n    for i, (question, answer) in enumerate(questions):\n        print(f\"Question {i+1}/{total}: {question}\")\n\n        # Get user's answer\n        user_answer = input(\"Your answer: \").strip().lower()\n\n        # Check if correct\n        if user_answer == answer.lower():\n            score += 1\n            print(\"Correct! \u2705\")\n\n            # Get enthusiastic feedback from the bot\n            feedback = get_response(\n                f\"The user correctly answered '{question}' with '{answer}'. Give a short, enthusiastic response.\",\n                system=\"You are an encouraging quiz host who keeps responses to one short sentence.\"\n            )\n            print(feedback)\n        else:\n            print(f\"Sorry, that's incorrect. \u274c The answer is: {answer}\")\n\n            # Get encouraging feedback from the bot\n            feedback = get_response(\n                f\"The user incorrectly answered '{question}' with '{user_answer}' instead of '{answer}'. Give a short, encouraging response.\",\n                system=\"You are a supportive quiz host who gives gentle encouragement in one sentence.\"\n            )\n            print(feedback)\n\n        print(\"-\" * 50)\n\n    # Calculate percentage\n    percentage = (score / total) * 100\n\n    # Final results\n    print(f\"\\nQuiz complete! Your score: {score}/{total} ({percentage:.1f}%)\")\n\n    # Get final feedback based on score\n    if percentage &gt;= 80:\n        result = \"excellent\"\n    elif percentage &gt;= 60:\n        result = \"good\"\n    else:\n        result = \"needs improvement\"\n\n    final_feedback = get_response(\n        f\"The user scored {percentage:.1f}% ({score}/{total}) on the quiz, which is {result}. Give them feedback and encouragement.\",\n        system=\"You are a supportive teacher giving a short, personalized assessment.\"\n    )\n\n    print(\"\\nBot's feedback:\")\n    print(final_feedback)\n\n# Run the quiz\nif __name__ == \"__main__\":\n    create_quiz_bot()\n</code></pre>"},{"location":"projects/trivia-or-quiz-bot/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add difficulty levels where harder questions are worth more points</li> <li>Include a hint system where users can ask for clues but lose points</li> <li>Make a specialized quiz for a specific subject the students are studying</li> <li>Add a timer element where users have to answer within a time limit</li> <li>Let students create their own question banks to quiz each other</li> </ul>"},{"location":"projects/weather-dashboard/","title":"Weather Dashboard","text":"<p>Difficulty: Intermediate-Advanced Time: 60-90 minutes Learning Focus: API integration, data visualization, environmental data analysis</p>"},{"location":"projects/weather-dashboard/#overview","title":"Overview","text":"<p>Create a weather dashboard that fetches real-time weather data and forecasts from an API, then visualizes it with charts and provides AI-powered weather advice based on conditions.</p>"},{"location":"projects/weather-dashboard/#instructions","title":"Instructions","text":"<pre><code>import requests\nimport matplotlib.pyplot as plt\nimport os\nfrom datetime import datetime, timedelta\nfrom chatcraft import get_response\n\nclass WeatherDashboard:\n    \"\"\"\n    A simple weather dashboard that retrieves and displays weather data.\n    Students will need to sign up for a free API key from OpenWeatherMap.\n    \"\"\"\n\n    def __init__(self):\n        self.api_key = None\n        self.base_url = \"https://api.openweathermap.org/data/2.5/\"\n        self.output_dir = \"weather_dashboard\"\n        os.makedirs(self.output_dir, exist_ok=True)\n\n    def setup(self):\n        \"\"\"Set up the dashboard with the API key.\"\"\"\n        print(\"=== Weather Dashboard Setup ===\")\n\n        # Check for existing API key\n        key_file = os.path.join(self.output_dir, \"api_key.txt\")\n        if os.path.exists(key_file):\n            with open(key_file, 'r') as f:\n                self.api_key = f.read().strip()\n            print(\"API key loaded from file.\")\n\n        # If no API key, prompt for one\n        if not self.api_key:\n            print(\"\\nYou need an OpenWeatherMap API key to use this dashboard.\")\n            print(\"Get a free API key at: https://openweathermap.org/api\")\n            self.api_key = input(\"Enter your API key: \").strip()\n\n            # Save API key for future use\n            save_key = input(\"Save this API key for future use? (y/n): \").lower() == 'y'\n            if save_key:\n                with open(key_file, 'w') as f:\n                    f.write(self.api_key)\n                print(\"API key saved.\")\n\n    def get_current_weather(self, location):\n        \"\"\"Get current weather for a location.\"\"\"\n        url = f\"{self.base_url}weather\"\n        params = {\n            'q': location,\n            'appid': self.api_key,\n            'units': 'metric'  # Use metric by default\n        }\n\n        try:\n            response = requests.get(url, params=params)\n            response.raise_for_status()  # Raise exception for HTTP errors\n            return response.json()\n        except requests.exceptions.HTTPError as http_err:\n            if response.status_code == 404:\n                print(f\"Location '{location}' not found. Please check the spelling.\")\n            else:\n                print(f\"HTTP error: {http_err}\")\n            return None\n        except Exception as err:\n            print(f\"Error: {err}\")\n            return None\n\n    def get_forecast(self, location, days=5):\n        \"\"\"Get weather forecast for a location.\"\"\"\n        url = f\"{self.base_url}forecast\"\n        params = {\n            'q': location,\n            'appid': self.api_key,\n            'units': 'metric',\n            'cnt': days * 8  # API returns data in 3-hour steps, 8 per day\n        }\n\n        try:\n            response = requests.get(url, params=params)\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.HTTPError as http_err:\n            if response.status_code == 404:\n                print(f\"Location '{location}' not found. Please check the spelling.\")\n            else:\n                print(f\"HTTP error: {http_err}\")\n            return None\n        except Exception as err:\n            print(f\"Error: {err}\")\n            return None\n\n    def display_current_weather(self, data):\n        \"\"\"Display current weather conditions.\"\"\"\n        if not data:\n            return\n\n        try:\n            city = data['name']\n            country = data['sys']['country']\n            temp = data['main']['temp']\n            feels_like = data['main']['feels_like']\n            humidity = data['main']['humidity']\n            pressure = data['main']['pressure']\n            weather_desc = data['weather'][0]['description']\n            wind_speed = data['wind']['speed']\n            clouds = data['clouds']['all']\n\n            # Convert Unix timestamp to readable format\n            sunrise = datetime.fromtimestamp(data['sys']['sunrise']).strftime('%H:%M')\n            sunset = datetime.fromtimestamp(data['sys']['sunset']).strftime('%H:%M')\n\n            print(\"\\n=== Current Weather Conditions ===\")\n            print(f\"Location: {city}, {country}\")\n            print(f\"Weather: {weather_desc.title()}\")\n            print(f\"Temperature: {temp}\u00b0C (Feels like: {feels_like}\u00b0C)\")\n            print(f\"Humidity: {humidity}%\")\n            print(f\"Pressure: {pressure} hPa\")\n            print(f\"Wind Speed: {wind_speed} m/s\")\n            print(f\"Cloud Cover: {clouds}%\")\n            print(f\"Sunrise: {sunrise}\")\n            print(f\"Sunset: {sunset}\")\n\n        except KeyError as e:\n            print(f\"Error parsing weather data: {e}\")\n\n    def plot_forecast(self, data, location):\n        \"\"\"Create forecast plots and save them.\"\"\"\n        if not data:\n            return\n\n        try:\n            # Extract forecast data\n            timestamps = []\n            temps = []\n            humidity = []\n            descriptions = []\n\n            for item in data['list']:\n                dt = datetime.fromtimestamp(item['dt'])\n                timestamps.append(dt)\n                temps.append(item['main']['temp'])\n                humidity.append(item['main']['humidity'])\n                descriptions.append(item['weather'][0]['description'])\n\n            # Create temperature forecast plot\n            plt.figure(figsize=(12, 6))\n            plt.plot(timestamps, temps, marker='o', color='#FF5733', linewidth=2)\n            plt.xlabel('Date &amp; Time')\n            plt.ylabel('Temperature (\u00b0C)')\n            plt.title(f'Temperature Forecast for {location}')\n            plt.grid(True, linestyle='--', alpha=0.7)\n            plt.xticks(rotation=45)\n            plt.tight_layout()\n\n            # Save the plot\n            temp_plot_file = os.path.join(self.output_dir, f\"{location.replace(',', '_')}_temp_forecast.png\")\n            plt.savefig(temp_plot_file)\n            plt.close()\n\n            # Create humidity forecast plot\n            plt.figure(figsize=(12, 6))\n            plt.plot(timestamps, humidity, marker='s', color='#3498DB', linewidth=2)\n            plt.xlabel('Date &amp; Time')\n            plt.ylabel('Humidity (%)')\n            plt.title(f'Humidity Forecast for {location}')\n            plt.grid(True, linestyle='--', alpha=0.7)\n            plt.xticks(rotation=45)\n            plt.tight_layout()\n\n            # Save the plot\n            humidity_plot_file = os.path.join(self.output_dir, f\"{location.replace(',', '_')}_humidity_forecast.png\")\n            plt.savefig(humidity_plot_file)\n            plt.close()\n\n            print(f\"\\nForecast plots saved to:\\n- {temp_plot_file}\\n- {humidity_plot_file}\")\n\n            return temp_plot_file, humidity_plot_file\n\n        except KeyError as e:\n            print(f\"Error parsing forecast data: {e}\")\n            return None, None\n\n    def get_weather_summary(self, current_data, forecast_data, location):\n        \"\"\"Generate a summary of the weather conditions and forecast.\"\"\"\n        if not current_data or not forecast_data:\n            return \"Unable to generate weather summary due to missing data.\"\n\n        try:\n            # Extract key information\n            current_temp = current_data['main']['temp']\n            current_desc = current_data['weather'][0]['description']\n\n            # Get min/max for the next few days\n            daily_temps = {}\n            for item in forecast_data['list']:\n                dt = datetime.fromtimestamp(item['dt'])\n                date_str = dt.strftime('%Y-%m-%d')\n\n                if date_str not in daily_temps:\n                    daily_temps[date_str] = {'temps': [], 'descs': []}\n\n                daily_temps[date_str]['temps'].append(item['main']['temp'])\n                daily_temps[date_str]['descs'].append(item['weather'][0]['description'])\n\n            # Create summary with key info\n            summary = f\"Weather Summary for {location}:\\n\\n\"\n            summary += f\"Current Conditions: {current_desc.title()} at {current_temp}\u00b0C\\n\\n\"\n            summary += \"Forecast:\\n\"\n\n            for date_str, data in daily_temps.items():\n                if data['temps']:  # Make sure we have data\n                    min_temp = min(data['temps'])\n                    max_temp = max(data['temps'])\n\n                    # Get most common description\n                    from collections import Counter\n                    desc_counter = Counter(data['descs'])\n                    most_common_desc = desc_counter.most_common(1)[0][0]\n\n                    # Format date nicely (e.g., \"Monday, Jan 15\")\n                    date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n                    formatted_date = date_obj.strftime('%A, %b %d')\n\n                    summary += f\"- {formatted_date}: {most_common_desc.title()}, {min_temp}\u00b0C to {max_temp}\u00b0C\\n\"\n\n            return summary\n\n        except KeyError as e:\n            print(f\"Error generating weather summary: {e}\")\n            return \"Unable to generate weather summary.\"\n\n    def get_ai_weather_advice(self, current_data, forecast_data, location):\n        \"\"\"Get AI-generated weather advice based on conditions.\"\"\"\n        if not current_data or not forecast_data:\n            return \"Unable to generate weather advice due to missing data.\"\n\n        try:\n            # Prepare weather information for the AI\n            current_temp = current_data['main']['temp']\n            current_desc = current_data['weather'][0]['description']\n            current_humidity = current_data['main']['humidity']\n            current_wind = current_data['wind']['speed']\n\n            # Extract forecast information\n            tomorrow_data = forecast_data['list'][:8]  # First 8 entries (24 hours)\n            tomorrow_descs = [item['weather'][0]['description'] for item in tomorrow_data]\n            tomorrow_temps = [item['main']['temp'] for item in tomorrow_data]\n\n            avg_tomorrow_temp = sum(tomorrow_temps) / len(tomorrow_temps)\n            min_tomorrow_temp = min(tomorrow_temps)\n            max_tomorrow_temp = max(tomorrow_temps)\n\n            # Create prompt for AI\n            prompt = f\"\"\"\n            Based on the following weather data for {location}:\n\n            Current conditions:\n            - Temperature: {current_temp}\u00b0C\n            - Description: {current_desc}\n            - Humidity: {current_humidity}%\n            - Wind speed: {current_wind} m/s\n\n            Tomorrow's forecast:\n            - Average temperature: {avg_tomorrow_temp:.1f}\u00b0C\n            - Range: {min_tomorrow_temp:.1f}\u00b0C to {max_tomorrow_temp:.1f}\u00b0C\n            - Conditions: {', '.join(set(tomorrow_descs))}\n\n            Please provide:\n            1. Practical advice for what to wear or prepare for today\n            2. Any weather warnings or precautions to be aware of\n            3. Suggested activities that would be appropriate for this weather\n\n            Keep your response conversational and under 150 words.\n            \"\"\"\n\n            try:\n                advice = get_response(prompt)\n                return advice\n            except Exception as e:\n                print(f\"Error getting AI weather advice: {e}\")\n                return \"Unable to generate AI weather advice at this time.\"\n\n        except KeyError as e:\n            print(f\"Error preparing data for AI advice: {e}\")\n            return \"Unable to generate weather advice due to missing data.\"\n\n    def run(self):\n        \"\"\"Run the main dashboard interface.\"\"\"\n        self.setup()\n\n        if not self.api_key:\n            print(\"No API key provided. Exiting.\")\n            return\n\n        print(\"\\n=== Weather Dashboard ===\")\n        location = input(\"Enter a city name (e.g., 'London' or 'London,UK'): \")\n\n        print(f\"\\nFetching weather data for {location}...\")\n        current_data = self.get_current_weather(location)\n\n        if current_data:\n            self.display_current_weather(current_data)\n\n            # Get forecast data\n            print(\"\\nFetching forecast data...\")\n            forecast_data = self.get_forecast(location)\n\n            if forecast_data:\n                # Plot forecast\n                temp_plot, humidity_plot = self.plot_forecast(forecast_data, location)\n\n                # Generate weather summary\n                summary = self.get_weather_summary(current_data, forecast_data, location)\n                print(\"\\n=== Weather Summary ===\")\n                print(summary)\n\n                # Get AI advice if requested\n                get_advice = input(\"\\nWould you like personalized weather advice? (y/n): \").lower() == 'y'\n                if get_advice:\n                    print(\"\\nGenerating advice...\")\n                    advice = self.get_ai_weather_advice(current_data, forecast_data, location)\n                    print(\"\\n=== Weather Advice ===\")\n                    print(advice)\n\n                # Save all info to a report file\n                save_report = input(\"\\nSave a weather report file? (y/n): \").lower() == 'y'\n                if save_report:\n                    try:\n                        report_file = os.path.join(self.output_dir, f\"{location.replace(',', '_')}_weather_report.txt\")\n                        with open(report_file, 'w') as f:\n                            f.write(f\"Weather Report for {location}\\n\")\n                            f.write(f\"Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\\n\")\n                            f.write(\"=== Current Conditions ===\\n\")\n\n                            # Extract current conditions\n                            f.write(f\"Temperature: {current_data['main']['temp']}\u00b0C\\n\")\n                            f.write(f\"Feels like: {current_data['main']['feels_like']}\u00b0C\\n\")\n                            f.write(f\"Weather: {current_data['weather'][0]['description'].title()}\\n\")\n                            f.write(f\"Humidity: {current_data['main']['humidity']}%\\n\")\n                            f.write(f\"Wind speed: {current_data['wind']['speed']} m/s\\n\")\n                            f.write(f\"Pressure: {current_data['main']['pressure']} hPa\\n\\n\")\n\n                            # Add summary\n                            f.write(\"=== Forecast Summary ===\\n\")\n                            f.write(summary + \"\\n\\n\")\n\n                            # Add advice if it was generated\n                            if get_advice:\n                                f.write(\"=== Weather Advice ===\\n\")\n                                f.write(advice + \"\\n\")\n\n                            # Add note about plot files\n                            if temp_plot and humidity_plot:\n                                f.write(\"\\nForecast plots saved as:\\n\")\n                                f.write(f\"- {os.path.basename(temp_plot)}\\n\")\n                                f.write(f\"- {os.path.basename(humidity_plot)}\\n\")\n\n                        print(f\"\\nWeather report saved to: {report_file}\")\n                    except Exception as e:\n                        print(f\"Error saving weather report: {e}\")\n\n        print(\"\\nThank you for using the Weather Dashboard!\")\n\n# Run the dashboard\nif __name__ == \"__main__\":\n    dashboard = WeatherDashboard()\n    dashboard.run()\n</code></pre>"},{"location":"projects/weather-dashboard/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add support for multiple locations and comparison views</li> <li>Implement unit conversion between metric and imperial</li> <li>Create a historical weather data retrieval and analysis feature</li> <li>Add precipitation and wind forecasts with appropriate visualizations</li> <li>Implement a daily weather notification system</li> <li>Create a map-based visualization of weather data</li> </ul>"},{"location":"projects/youtube-to-blog-converter/","title":"YouTube to Blog Converter","text":"<p>Difficulty: Beginner-Intermediate Time: 30-45 minutes Learning Focus: API integration, text processing, content repurposing</p>"},{"location":"projects/youtube-to-blog-converter/#overview","title":"Overview","text":"<p>Create a tool that converts YouTube video transcripts into well-formatted blog posts using AI. This project helps students understand how to extract data from one format and transform it into another valuable piece of content.</p>"},{"location":"projects/youtube-to-blog-converter/#instructions","title":"Instructions","text":"<pre><code>import re\nimport argparse\nfrom youtube_transcript_api import YouTubeTranscriptApi\nfrom chatcraft import get_response\n\ndef youtube_to_blog():\n    \"\"\"Convert YouTube video transcripts into blog post content using AI.\"\"\"\n    print(\"=== YouTube to Blog Converter ===\")\n    print(\"This tool extracts a transcript from a YouTube video and converts it to a blog post.\")\n\n    # Get video URL or ID\n    video_input = input(\"Enter YouTube video URL or video ID: \")\n\n    # Extract video ID from URL if needed\n    video_id = extract_video_id(video_input)\n\n    if not video_id:\n        print(\"Error: Could not extract a valid YouTube video ID.\")\n        return\n\n    print(f\"Processing video ID: {video_id}\")\n\n    # Get transcript\n    try:\n        transcript = get_transcript(video_id)\n        if not transcript:\n            return\n    except Exception as e:\n        print(f\"Error getting transcript: {e}\")\n        return\n\n    # Get video metadata if needed\n    video_title = input(\"Enter video title (or press Enter to skip): \")\n    video_author = input(\"Enter video creator/channel name (or press Enter to skip): \")\n\n    # Get blog style preferences\n    print(\"\\nBlog Style Options:\")\n    print(\"1. Informational/Educational\")\n    print(\"2. Conversational/Casual\")\n    print(\"3. Professional/Formal\")\n    print(\"4. Tutorial/How-To\")\n\n    style_choice = input(\"Select a style (1-4): \")\n\n    if style_choice == \"1\":\n        blog_style = \"informational\"\n    elif style_choice == \"2\":\n        blog_style = \"conversational\"\n    elif style_choice == \"3\":\n        blog_style = \"professional\"\n    elif style_choice == \"4\":\n        blog_style = \"tutorial\"\n    else:\n        print(\"Invalid choice. Using informational style.\")\n        blog_style = \"informational\"\n\n    # Get additional context\n    topic_keywords = input(\"Enter 3-5 keywords related to the video (comma separated): \")\n\n    # Get intended audience\n    audience = input(\"Who is the target audience for this blog post? \")\n\n    # Generate blog post with AI\n    generate_blog_post(transcript, video_title, video_author, blog_style, topic_keywords, audience)\n\ndef extract_video_id(video_input):\n    \"\"\"Extract the YouTube video ID from a URL or return the ID if already provided.\"\"\"\n    # Check if it's already a video ID (simple 11-character string)\n    if re.match(r'^[a-zA-Z0-9_-]{11}, video_input):\n        return video_input\n\n    # Try to extract from URL\n    youtube_regex = r'(?:youtube\\.com\\/(?:[^\\/\\n\\s]+\\/\\S+\\/|(?:v|e(?:mbed)?)\\/|\\S*?[?&amp;]v=)|youtu\\.be\\/)([a-zA-Z0-9_-]{11})'\n    match = re.search(youtube_regex, video_input)\n\n    if match:\n        return match.group(1)\n\n    return None\n\ndef get_transcript(video_id):\n    \"\"\"Get the transcript from a YouTube video.\"\"\"\n    try:\n        transcript_list = YouTubeTranscriptApi.get_transcript(video_id)\n\n        # Combine all transcript segments\n        full_transcript = \" \".join([item['text'] for item in transcript_list])\n\n        # Print a preview\n        preview_length = min(150, len(full_transcript))\n        print(f\"\\nTranscript preview ({len(full_transcript)} characters):\")\n        print(f\"{full_transcript[:preview_length]}...\")\n\n        return full_transcript\n\n    except Exception as e:\n        print(f\"Error: Could not retrieve transcript. {str(e)}\")\n        print(\"Possible reasons:\")\n        print(\"- The video might not have closed captions/subtitles\")\n        print(\"- The video ID might be incorrect\")\n        print(\"- The video owner may have disabled transcript access\")\n        return None\n\ndef generate_blog_post(transcript, title, author, style, keywords, audience):\n    \"\"\"Generate a blog post from the transcript using AI.\"\"\"\n    print(\"\\nGenerating blog post...\")\n\n    # Create a prompt for the AI\n    prompt = f\"\"\"\n    Convert this YouTube video transcript into a well-structured blog post:\n\n    VIDEO INFORMATION:\n    Title: {title if title else \"Not provided\"}\n    Creator: {author if author else \"Not provided\"}\n    Style: {style}\n    Keywords: {keywords}\n    Target Audience: {audience}\n\n    TRANSCRIPT:\n    {transcript[:4000]}  # Limit transcript length if needed\n\n    Please create a complete blog post with:\n    1. An engaging headline/title\n    2. Introduction that hooks the reader\n    3. Well-structured sections with subheadings\n    4. Conclusion or call-to-action\n    5. Add relevant statistics or examples where appropriate\n\n    Format the post using markdown syntax for headings, lists, etc.\n    The tone should be {style} and appropriate for the specified audience.\n    Expand on any concepts from the video that need more explanation.\n    Add 3-5 relevant tags at the end of the post.\n\n    Length: Aim for ~1000-1500 words.\n    \"\"\"\n\n    try:\n        # Generate blog post using the prompt\n        blog_post = get_response(prompt)\n\n        # Save the blog post to a file\n        filename = f\"blog_post_{title.replace(' ', '_')[:30] if title else 'from_youtube'}.md\"\n        with open(filename, 'w') as f:\n            f.write(blog_post)\n\n        print(f\"\\nBlog post successfully generated and saved to: {filename}\")\n\n        # Print a preview of the blog post\n        preview_lines = blog_post.split('\\n')[:10]\n        print(\"\\nBlog Post Preview:\")\n        print(\"\\n\".join(preview_lines) + \"\\n...\")\n\n    except Exception as e:\n        print(f\"Error generating blog post: {e}\")\n\nif __name__ == \"__main__\":\n    youtube_to_blog()\n</code></pre>"},{"location":"projects/youtube-to-blog-converter/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Add support for multiple languages and translation</li> <li>Implement a social media post generator from the same content</li> <li>Create a scheduler to process videos in batch</li> <li>Add image extraction from video thumbnails or frames</li> <li>Build a web interface with Flask or Streamlit</li> <li>Implement SEO optimization suggestions for the generated content</li> </ul>"}]}